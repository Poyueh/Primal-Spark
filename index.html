<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <!-- Â¢ûÂä† maximum-scale=1.0, user-scalable=no Èò≤Ê≠¢ÊâãÊ©üË™§Ëß∏Á∏ÆÊîæ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÂéüÂàù‰πãÁÅ´ Primal Spark (EmojiÁâà)</title>
    
    <!-- 1. ËºâÂÖ• Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. ËºâÂÖ• React Ëàá ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- 3. ËºâÂÖ• Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* ‰øùÊåÅ body ÁÑ°Êç≤ÂãïÔºåÂÖßÂÆπÂçÄÂüüËá™Â∑±Êç≤Âãï */
        body { margin: 0; overflow: hidden; background-color: #111; }
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        /* Ëá™ÂÆöÁæ©Êç≤Ëª∏Ê®£Âºè */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #4a4a4a; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }

        /* ËÆìËß∏ÊéßÈªûÊìäÊõ¥ÈùàÊïè */
        button { touch-action: manipulation; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const { createRoot } = ReactDOM;

        // --- Icon Components ---
        const Icon = ({ char, className, size }) => (
            <span className={className} style={{ fontSize: size || 16, lineHeight: 1 }}>{char}</span>
        );

        const Icons = {
            Sparkles: (p) => <Icon char="‚ú®" {...p}/>,
            Heart: (p) => <Icon char="‚ù§Ô∏è" {...p}/>,
            Utensils: (p) => <Icon char="üçñ" {...p}/>,
            Shield: (p) => <Icon char="üõ°Ô∏è" {...p}/>,
            CloudRain: (p) => <Icon char="üåßÔ∏è" {...p}/>,
            Snowflake: (p) => <Icon char="‚ùÑÔ∏è" {...p}/>,
            Sun: (p) => <Icon char="‚òÄÔ∏è" {...p}/>,
            Cloud: (p) => <Icon char="‚òÅÔ∏è" {...p}/>,
            Flame: (p) => <Icon char="üî•" {...p}/>,
            Mountain: (p) => <Icon char="‚õ∞Ô∏è" {...p}/>,
            Skull: (p) => <Icon char="üíÄ" {...p}/>,
            RefreshCw: (p) => <Icon char="üîÑ" {...p}/>,
            X: (p) => <Icon char="‚ùå" {...p}/>,
            Brain: (p) => <Icon char="üß†" {...p}/>,
            ScrollText: (p) => <Icon char="üìú" {...p}/>,
            MessageCircle: (p) => <Icon char="üí¨" {...p}/>,
            HelpCircle: (p) => <Icon char="‚ùì" {...p}/>,
            Users: (p) => <Icon char="üë•" {...p}/>,
            Hammer: (p) => <Icon char="üî®" {...p}/>,
            Zap: (p) => <Icon char="‚ö°" {...p}/>,
            Home: (p) => <Icon char="üè†" {...p}/>,
            Biohazard: (p) => <Icon char="‚ò£Ô∏è" {...p}/>
        };

        const apiKey = ""; 

        // --- Mock Data ---
        const MOCK_THOUGHTS = ["ÈÄôÊ£µÊ®πÂèØ‰ª•Áî®‰æÜËìãÊàøÂ≠ê...", "Áü≥È†≠ÈõñÁÑ∂Á°¨Ôºå‰ΩÜËÉΩÂÅöÊàêÂ∑•ÂÖ∑„ÄÇ", "ÊàëÂÄëÈúÄË¶ÅÊõ¥Â§öÈò≤Á¶¶„ÄÇ", "ÂâµÈÄ†ÊòØÁîüÂ≠òÁöÑÈóúÈçµ„ÄÇ", "Â•ΩÁ¥ØÔºå‰ΩÜÂÄºÂæó„ÄÇ", "‰ªäÊôöÊúâËÇâÂêÉ‰∫ÜÔºÅ", "Áã©ÁçµÈúÄË¶ÅËÄêÂøÉ„ÄÇ", "‰∏çÊÉ≥Ê≠ªÂú®ÈÄôË£°...", "Á•ûÂú®ËÄÉÈ©óÊàëÂÄëÂóéÔºü", "Ê¥ûË£°ÁúüÊ∫´Êöñ...", "Â§ñÈù¢Â•ΩÂèØÊÄï..."];
        const MOCK_SAGAS = ["Êóè‰∫∫Â≠∏ÊúÉ‰∫ÜÂà©Áî®Â§ßÂú∞ÁöÑÊÅ©Ë≥úÔºåÂ∑•ÂÖ∑ÁöÑÊï≤ÊìäËÅ≤ÈüøÂæπÊ£ÆÊûó„ÄÇ", "Á¨¨‰∏ÄÊääÁü≥ÊñßÁöÑË™ïÁîüÔºåÊ®ôË™åËëóÊàëÂÄë‰∏çÂÜçÊòØËá™ÁÑ∂ÁöÑÂ•¥Èö∏„ÄÇ", "Êô∫ÊÖß‰πãÁÅ´Âú®ÈÉ®ËêΩ‰∏≠ÂÇ≥ÈÅûÔºåÂâµÈÄ†ÂäõÂºïÈ†òÊàëÂÄëÂâçË°å„ÄÇ", "Ëã±ÂãáÁöÑÁçµ‰∫∫Â∏∂ËëóÁçµÁâ©Ê≠∏‰æÜÔºåÈÉ®ËêΩÂÖÖÊªø‰∫ÜÊ≠°ÂëºËÅ≤„ÄÇ", "Â§©ÁÅ´ÈôçËá®ÔºåÊóè‰∫∫Âú®ÁµïÊúõ‰∏≠Â∞ãÊâæÂà∞‰∫ÜÈÅøÈõ£ÁöÑÂ≤©Ê¥ûÔºåÊñáÊòéÂæó‰ª•Âª∂Á∫å„ÄÇ"];

        // --- Constants ---
        const PIXEL_FONT = "'Courier New', Courier, monospace";
        const TILE_SIZE = 32;
        const SCALE = 2.0; 

        const PALETTE = {
            OUTLINE: '#1a1c2c', SKIN: '#ffccaa', SKIN_SHADOW: '#d48e7e',
            GRASS_BG: '#388e3c', GRASS_L: '#4caf50', GRASS_D: '#1b5e20',
            DIRT: '#5d4037', WATER: '#4a69bd',
            SAND: '#e6c98e', MOUNTAIN_BG: '#5d4037', MOUNTAIN_FG: '#8d6e63',
            CAVE_DARK: '#1a1a1a',
            WHEAT_1: '#a5d6a7', WHEAT_2: '#e6ee9c', WHEAT_3: '#fbc02d',
            STONE_L: '#b0bec5', STONE_M: '#78909c', STONE_D: '#546e7a',
            WOOD_L: '#8d6e63', WOOD_D: '#3e2723',
            LEAF_L: '#66bb6a', LEAF_D: '#2e7d32', LEAF_PINE: '#1b5e20',
            FLOWER_R: '#e57373', FLOWER_Y: '#fff176', MUSHROOM: '#f44336',
            FUR_WOLF: '#90a4ae', FUR_BEAR: '#4e342e', FUR_DEER: '#a1887f', FUR_RABBIT: '#fafafa',
            WHITE: '#ffffff', TRANSPARENT: null,
            TOOL_AXE: '#8d6e63', TOOL_HEAD: '#90a4ae', TOOL_SPEAR: '#d7ccc8',
            SICK_SKIN: '#88aa88' // ÁòüÁñ´ËÜöËâ≤
        };

        const DISASTERS = {
            NONE: { name: 'ÁÑ°', color: null },
            METEOR: { name: 'üî• ÊòüÊÆû', color: 'rgba(80, 20, 10, 0.4)' },
            PLAGUE: { name: 'ü¶† ÁòüÁñ´', color: 'rgba(20, 50, 20, 0.3)' },
            DROUGHT: { name: '‚òÄ ‰πæÊó±', color: 'rgba(100, 80, 0, 0.3)' },
            FLOOD: { name: 'üåä Ê¥™Ê∞¥', color: 'rgba(0, 50, 100, 0.4)' },
            LOCUSTS: { name: 'ü¶ó ËùóÁÅΩ', color: 'rgba(60, 50, 20, 0.3)' },
            BLIZZARD: { name: '‚ùÑ ÂáúÂÜ¨', color: 'rgba(200, 240, 255, 0.5)' },
            QUAKE: { name: 'üåã Âú∞Èúá', color: 'rgba(50, 30, 30, 0.5)' }, // Shake handled in logic
            BEASTS: { name: 'üê∫ Áç∏ÊΩÆ', color: 'rgba(50, 0, 0, 0.2)' },
            DARKNESS: { name: 'üåë Ê∞∏Â§ú', color: 'rgba(0, 0, 0, 0.8)' },
            THUNDER: { name: '‚ö° Èõ∑ÁΩ∞', color: 'rgba(50, 50, 80, 0.4)' }
        };

        const callGemini = async (prompt, type) => {
            if (!apiKey) { 
                await new Promise(r => setTimeout(r, 800));
                if (type === 'SAGA') return MOCK_SAGAS[Math.floor(Math.random() * MOCK_SAGAS.length)];
                return MOCK_THOUGHTS[Math.floor(Math.random() * MOCK_THOUGHTS.length)];
            }
            try {
                const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || null;
            } catch (error) { return null; }
        };

        const SPRITE_MATRICES = {
            CHAR_M: ["........................",".......HHHHHH...........","......HSSSSSSH..........",".....HSSKSSKSSH.........",".....HSSSSSSSSH.........","......SSSSSSSS..........","....CCCSCCCCSCCC........","....CCCSCCCCSCCC........","....CCCCCCCCCCCC........","....KKKCCCCCCKKK........","....K.KCCCCCCK.K........","......KSSSSSSK..........","......KSSSSSSK..........","......KKK..KKK.........."],
            CHAR_F: ["........................","......HHHHHHHH..........",".....HSSSSSSSSH.........",".....HSSKSSKSSH.........",".....HSSSSSSSSH.........",".....SSSSSSSSSS.........","....CCCSCCCCSCCC........","...CCCCSCCCCSCCCC.......","...CCCCCCCCCCCCCC.......","...CCCCCCCCCCCCCC.......","....CCCCCCCCCCCC........",".....KSSSSSSssk.........",".....KSSSSSSssk.........",".....KKK....KKK........."],
            TREE_OAK: [".......LLLLLL.......",".....LLLLLLLLLL.....","....LLLLLLLLLLLL....","...LLLLLLLLLLLLLL...","...LLLLLLLLLLLLLL...","....LLLLLLLLLLLL....",".....LLLLLLLLLL.....",".......WWWWWW.......",".......WWWWWW.......",".......WWWWWW.......","......WWWWWWWW......"],
            TREE_PINE: ["..........L.........",".........LLL........","........LLLLL.......",".......LLLLLLL......",".........LLL........","........LLLLL.......",".......LLLLLLL......","......LLLLLLLLL.....",".....LLLLLLLLLLL....","........WWWWW.......",".......WWWWWWW......"],
            BUSH: ["....................","......LLLLLLL.......",".....LLLLLLLLL......","....LLLLLLLLLLL.....","....LLLLLLLLLLL.....",".....LLLLLLLLL......"],
            FLOWER: [".........R..........","........RYR.........",".........R..........",".........G..........",".........G.........."],
            MUSHROOM: ["........RRR.........",".......RRRRR........",".......RWWWR........","........WWW.........","........WWW........."],
            ROCK: [".......KKKKKK.......",".....KKMMMMMMKK.....","....KMMLLLLLLMMK....","...KMLLLLLLLLLLMK...","...KMMMMMMMMMMMMK...","...KDDDDDDDDDDDDK...","....KKDDDDDDDDKK....","......KKKKKKKK......"],
            RABBIT: [".......KK...........","......KWWK..........",".....KWWWWK.........",".....KWWWWK.........","......KKKK.........."],
            WOLF: ["....................",".......K............","......KGK...........",".....KGGGK..........","....KGGGGGK...K.....","...KGGGGGGGGKKGK....","...KGGGGGGGGGGGK....","....KGGGGGGGGGK.....","....K.K.....K.K....."],
            BEAR: [".........KK...KK....","......KKKBBKKKBBK...",".....KBBBBBBBBBBBK..","....KBBBBBBBBBBBBBK.","...KBBBBBBBBBBBBBBBK","...KBBBBBBBBBBBBBBBK","...KBBBBBBBBBBBBBBBK","....KB.B.B.....B.B..","....KK.K.K.....K.K.."],
            DEER: ["...........K...K....","............K.K.....","..........KKKBKK....",".........KBBBBBBK...","........KBBBBBBBBK..",".......KBBBBBBBBBK..",".......K.B.....B....",".......K.K.....K...."],
            WHEAT_GROW: ["................","....1......1....","...111....111...","....1......1....","................"],
            WHEAT_READY: ["....3......3....","...333....333...","...333....333...","....3......3....","....3......3...."],
            CAVE_ENTRANCE: [ // 32x32 large deco
                ".....KKKKKKKKK.....",
                "...KKXXXXXXXXXKK...",
                "..KXXXXXXXXXXXXXK..",
                ".KXXXXXXXXXXXXXXXK.",
                ".KXXXXXXXXXXXXXXXK.",
                "KXXXXXXXXXXXXXXXXXK",
                "KXXXXXXXXXXXXXXXXXK",
                "KXXXXXX.....XXXXXXK",
                "KXXXXXX.....XXXXXXK",
                "KXXXXXX.....XXXXXXK"
            ]
        };

        const MAP_WIDTH = 24; const MAP_HEIGHT = 24; const DAY_TICKS = 800; 

        const WEATHER = {
            SUNNY: { id: 'SUNNY', name: 'Êô¥Â§©', color: 'rgba(255,255,0,0.1)' },
            RAIN: { id: 'RAIN', name: 'Èõ®Â§©', color: 'rgba(0,0,50,0.3)' },
            SNOW: { id: 'SNOW', name: 'ÈôçÈõ™', color: 'rgba(200,240,255,0.2)' }
        };

        const ZODIACS = [
            { sign: 'Áâ°Áæä', gender: 'M', color: '#c0392b', hair: '#2c3e50', trait: 'Â•ΩÈ¨•' },
            { sign: 'ÈáëÁâõ', gender: 'F', color: '#27ae60', hair: '#5d4037', trait: 'Âõ∫Âü∑' },
            { sign: 'ÈõôÂ≠ê', gender: 'M', color: '#f39c12', hair: '#e67e22', trait: 'ÂñÑËÆä' },
            { sign: 'Â∑®Ëüπ', gender: 'F', color: '#7f8c8d', hair: '#34495e', trait: 'È°ßÂÆ∂' },
            { sign: 'ÁçÖÂ≠ê', gender: 'M', color: '#e67e22', hair: '#f1c40f', trait: 'Èú∏Ê∞£' },
            { sign: 'ËôïÂ•≥', gender: 'F', color: '#16a085', hair: '#2ecc71', trait: 'Ë¨πÊÖé' },
            { sign: 'Â§©Áß§', gender: 'M', color: '#e84393', hair: '#fd79a8', trait: 'Áå∂Ë±´' },
            { sign: 'Â§©Ë†ç', gender: 'F', color: '#8e44ad', hair: '#2c3e50', trait: 'ÊïèÈä≥' },
            { sign: 'Â∞ÑÊâã', gender: 'M', color: '#2980b9', hair: '#3498db', trait: 'ÂÜíÈö™' },
            { sign: 'Êë©ÁæØ', gender: 'F', color: '#576574', hair: '#1e272e', trait: 'Â†ÖÂøç' },
            { sign: 'Ê∞¥Áì∂', gender: 'M', color: '#00d2d3', hair: '#00cec9', trait: 'Âè§ÊÄ™' },
            { sign: 'ÈõôÈ≠ö', gender: 'F', color: '#a29bfe', hair: '#6c5ce7', trait: 'Êµ™Êº´' }
        ];

        const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const noise = (x, y) => Math.sin(x/3.5) + Math.cos(y/4.5);

        const renderMatrix = (ctx, matrix, colors, offsetX = 0, offsetY = 0) => {
            matrix.forEach((row, y) => {
                for (let x = 0; x < row.length; x++) {
                    const char = row[x];
                    if (char === '.') continue;
                    let fill = colors[char] || PALETTE.OUTLINE;
                    if (char === 'K') fill = PALETTE.OUTLINE;
                    ctx.fillStyle = fill;
                    ctx.fillRect(offsetX + x, offsetY + y, 1, 1);
                }
            });
        };

        const createSprites = () => {
            const cache = {};
            const createCanvas = (w, h) => { const c = document.createElement('canvas'); c.width = w; c.height = h; return { c, ctx: c.getContext('2d') }; };

            const { c: grassC, ctx: grassCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            grassCtx.fillStyle = PALETTE.GRASS_BG; grassCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            grassCtx.fillStyle = PALETTE.GRASS_L; for(let i=0; i<30; i++) grassCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            grassCtx.fillStyle = PALETTE.GRASS_D; for(let i=0; i<20; i++) grassCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.grass = grassC;

            const { c: dirtC, ctx: dirtCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            dirtCtx.fillStyle = PALETTE.DIRT; dirtCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            dirtCtx.fillStyle = PALETTE.WOOD_D; for(let i=0; i<40; i++) dirtCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.dirt = dirtC;

            // New Terrain Sprites
            const { c: sandC, ctx: sandCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            sandCtx.fillStyle = PALETTE.SAND; sandCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            sandCtx.fillStyle = '#d4b483'; for(let i=0; i<30; i++) sandCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.sand = sandC;

            const { c: mtC, ctx: mtCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            mtCtx.fillStyle = PALETTE.MOUNTAIN_BG; mtCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            mtCtx.fillStyle = PALETTE.MOUNTAIN_FG; for(let i=0; i<25; i++) { 
                let rx = rand(0,30); let ry = rand(0,30); mtCtx.fillRect(rx, ry, 2, 2); 
            }
            cache.mountain = mtC;

            const makeSprite = (name, mat, colors, wMult=1, hMult=1, ox=0, oy=0) => {
                const { c, ctx } = createCanvas(TILE_SIZE*wMult, TILE_SIZE*hMult);
                renderMatrix(ctx, mat, colors, ox, oy);
                cache[name] = c;
            };

            makeSprite('tree_oak', SPRITE_MATRICES.TREE_OAK, {'L': PALETTE.LEAF_D, 'W': PALETTE.WOOD_D}, 1, 2, 6, 10);
            makeSprite('tree_pine', SPRITE_MATRICES.TREE_PINE, {'L': PALETTE.LEAF_PINE, 'W': PALETTE.WOOD_D}, 1, 2, 6, 8);
            makeSprite('bush', SPRITE_MATRICES.BUSH, {'L': PALETTE.LEAF_L}, 1, 1, 4, 16);
            makeSprite('flower', SPRITE_MATRICES.FLOWER, {'R': PALETTE.FLOWER_R, 'Y': PALETTE.FLOWER_Y, 'G': PALETTE.GRASS_L}, 1, 1, 10, 16);
            makeSprite('mushroom', SPRITE_MATRICES.MUSHROOM, {'R': PALETTE.MUSHROOM, 'W': PALETTE.WHITE}, 1, 1, 10, 16);
            makeSprite('rock', SPRITE_MATRICES.ROCK, {'K': PALETTE.OUTLINE, 'M': PALETTE.STONE_M, 'L': PALETTE.STONE_L, 'D': PALETTE.STONE_D}, 1, 1, 8, 16);
            makeSprite('rabbit', SPRITE_MATRICES.RABBIT, {'W': PALETTE.FUR_RABBIT}, 1, 1, 8, 16);
            makeSprite('wolf', SPRITE_MATRICES.WOLF, {'G': PALETTE.FUR_WOLF}, 1, 1, 4, 12);
            makeSprite('bear', SPRITE_MATRICES.BEAR, {'B': PALETTE.FUR_BEAR}, 1.5, 1.5, 4, 10);
            makeSprite('deer', SPRITE_MATRICES.DEER, {'B': PALETTE.FUR_DEER}, 1, 1.5, 4, 10);
            makeSprite('wheat_1', SPRITE_MATRICES.WHEAT_GROW, { '1': PALETTE.WHEAT_1 }, 1, 1, 8, 16);
            makeSprite('wheat_2', SPRITE_MATRICES.WHEAT_READY, { '3': PALETTE.WHEAT_3 }, 1, 1, 8, 16);
            
            makeSprite('cave', SPRITE_MATRICES.CAVE_ENTRANCE, { 'X': PALETTE.CAVE_DARK, 'K': PALETTE.MOUNTAIN_FG }, 2, 2, 16, 24);

            return cache;
        };

        const generateMapData = () => {
            const newMap = [];
            const centerX = MAP_WIDTH / 2;
            const centerY = MAP_HEIGHT / 2;

            for(let y=0; y<MAP_HEIGHT; y++) {
                const row = [];
                for(let x=0; x<MAP_WIDTH; x++) {
                    const n = noise(x + Math.random()*10, y + Math.random()*10);
                    let type = 'GRASS';
                    let decoration = null;
                    
                    // Generate Base Terrain
                    if (n > 0.8) type = 'WATER';
                    else if (n > 0.6) type = 'SAND'; // Beach
                    else if (n < -0.6) type = 'MOUNTAIN_GROUND'; // Rocky area
                    else if (n < -0.3) type = 'FOREST';
                    
                    // Force Cave Base Area
                    const dist = Math.sqrt((x-centerX)**2 + (y-centerY)**2);
                    if (dist < 5) {
                        type = 'MOUNTAIN_GROUND';
                        if (dist < 1.5) decoration = 'CAVE'; // Center decoration
                        else if (Math.random() < 0.1) decoration = 'ROCK'; // Scattered rocks around cave
                    } else {
                        // Regular decorations
                        if (type === 'FOREST') {
                            if (Math.random() > 0.6) decoration = 'TREE_OAK';
                            else decoration = 'TREE_PINE';
                            if (Math.random() < 0.1) decoration = 'MUSHROOM';
                        } else if (type === 'GRASS') {
                            const rnd = Math.random();
                            if (rnd < 0.05) decoration = 'ROCK';
                            else if (rnd < 0.1) decoration = 'BUSH';
                            else if (rnd < 0.15) decoration = 'FLOWER';
                        } else if (type === 'MOUNTAIN_GROUND') {
                            if (Math.random() < 0.15) decoration = 'ROCK';
                        }
                    }
                    
                    // Only put one CAVE at exact center effectively
                    if (decoration === 'CAVE' && (Math.abs(x - centerX) > 0.5 || Math.abs(y - centerY) > 0.5)) decoration = null;
                    if (Math.abs(x - centerX) < 0.5 && Math.abs(y - centerY) < 0.5) decoration = 'CAVE';

                    row.push({ x, y, type, decoration });
                }
                newMap.push(row);
            }
            return newMap;
        };

        const generateSimsData = () => ZODIACS.map((z, i) => ({
            id: `sim_${Date.now()}_${i}`, ...z,
            x: MAP_WIDTH/2 + rand(-1,1), y: MAP_HEIGHT/2 + rand(-1,1) + 2, // Start outside cave
            hp: 100, hunger: 100, energy: 100,
            state: 'IDLE', targetX: null, targetY: null, actionTimer: 0, targetId: null, // Added targetId
            inventory: { wood:0, food:0, stone:0 },
            tools: { axe: false, pick: false, spear: false },
            thought: 'ÂèàÊòØÊñ∞ÁöÑ‰∏ÄÂ§©...',
            animFrame: rand(0,10), dir: 1,
            hidden: false, // For entering cave
            sick: false // For Plague
        }));

        const generateCreaturesData = () => {
            const initCreatures = [];
            for(let i=0; i<8; i++) {
                const type = Math.random() < 0.4 ? 'RABBIT' : (Math.random() < 0.7 ? 'DEER' : (Math.random() < 0.9 ? 'WOLF' : 'BEAR'));
                initCreatures.push({
                    id: `c_${Date.now()}_${i}`, type,
                    x: rand(1, MAP_WIDTH-2), y: rand(1, MAP_HEIGHT-2),
                    hp: type==='BEAR'?200 : type==='WOLF'?80 : 30,
                    targetX: null, targetY: null,
                    state: 'WANDER', animFrame: rand(0,10), dir: 1
                });
            }
            return initCreatures;
        };

        const App = () => {
            const [sprites, setSprites] = useState(null);
            const [map, setMap] = useState([]);
            const [sims, setSims] = useState([]);
            const [creatures, setCreatures] = useState([]);
            const [farms, setFarms] = useState([]);
            const [particles, setParticles] = useState([]);
            const [tribe, setTribe] = useState({ wood: 0, stone: 0, food: 100, tech: 0 });
            const [weather, setWeather] = useState(WEATHER.SUNNY);
            const [weatherTimer, setWeatherTimer] = useState(1000);
            const [time, setTime] = useState(0);
            const [day, setDay] = useState(1);
            const [era, setEra] = useState(1);
            const [mana, setMana] = useState(999999);
            const [selectedId, setSelectedId] = useState(null);
            const [events, setEvents] = useState(['Êóè‰∫∫‰ª∞ÊúõÊòüÁ©∫ÔºåÊïÖ‰∫ãÈñãÂßã‰∫Ü...']);
            const [isGameOver, setIsGameOver] = useState(false);
            const [isSoulSearching, setIsSoulSearching] = useState(false);
            const [isWritingSaga, setIsWritingSaga] = useState(false);
            const [disaster, setDisaster] = useState(DISASTERS.NONE); // Current Disaster
            const [disasterTimer, setDisasterTimer] = useState(0);
            const [shake, setShake] = useState(0); // Screen shake offset

            const canvasRef = useRef(null);
            const tickRef = useRef(0);
            const requestRef = useRef();

            useEffect(() => {
                setSprites(createSprites());
                setMap(generateMapData());
                setSims(generateSimsData());
                setCreatures(generateCreaturesData());
            }, []);

            useEffect(() => {
                if (sims.length > 0 && sims.every(s => s.state === 'DEAD') && !isGameOver) {
                    setIsGameOver(true);
                }
            }, [sims, isGameOver]);

            const startNextEra = () => {
                setEra(e => e + 1); setDay(1); setTime(0); setMana(999999);
                setMap(generateMapData()); setSims(generateSimsData()); setCreatures(generateCreaturesData());
                setFarms([]); setTribe(prev => ({ ...prev, food: 100, wood: 0, stone: 0 }));
                setIsGameOver(false); setDisaster(DISASTERS.NONE); setDisasterTimer(0);
                setEvents(e => [`=== Á¨¨ ${era + 1} Á¥ÄÂÖÉÈñãÂïü ===`, `ÊñáÊòéÁ≠âÁ¥ö Lv.${tribe.tech} ÁπºÊâøÂÆåÁï¢`, ...e]);
            };

            const handleSoulSearch = async (sim) => {
                if (mana < 10) return;
                setIsSoulSearching(true); setMana(prev => prev - 10);
                const prompt = `You are an AI storytelling engine. Roleplay as a primitive tribesman (Sign:${sim.sign}, Trait:${sim.trait}, State:${sim.state}). Generate a short inner monologue (max 15 words) in Traditional Chinese.`;
                const thought = await callGemini(prompt, 'SOUL');
                if (thought) {
                    setSims(prev => prev.map(s => s.id === sim.id ? { ...s, thought: thought.trim() } : s));
                    setEvents(e => [`${sim.sign} ÁöÑÈùàÈ≠ÇÁôºÂá∫‰∫Ü‰ΩéË™û...`, ...e]);
                } else {
                    setEvents(e => [`‚ùå ÈÄ£ÁµêÁ•ûÁïåÂ§±Êïó (Ë´ãÊ™¢Êü• API Key)`, ...e]);
                    setMana(prev => prev + 10);
                }
                setIsSoulSearching(false);
            };

            const handleTribeSaga = async () => {
                if (mana < 50) return;
                setIsWritingSaga(true); setMana(prev => prev - 50);
                const prompt = `Write a cryptic, mythic, single-sentence log entry (max 20 words) for a primitive tribe in Traditional Chinese. Context: Era ${era}, Tech Lv ${tribe.tech}, Pop ${sims.length}, Food ${Math.floor(tribe.food)}, Weather ${weather.name}, Disaster ${disaster.name}.`;
                const saga = await callGemini(prompt, 'SAGA');
                if (saga) setEvents(e => [`üìú Âè≤Ë©©: ${saga.trim()}`, ...e]);
                else { setEvents(e => [`‚ùå Âè≤Ë©©Êí∞ÂØ´Â§±Êïó`, ...e]); setMana(prev => prev + 50); }
                setIsWritingSaga(false);
            };

            const castSpell = (type) => {
                if (type === 'DISASTER') {
                    if (mana < 100) return;
                    setMana(m => m - 100);
                    
                    // Pick random disaster (excluding NONE)
                    const keys = Object.keys(DISASTERS).filter(k => k !== 'NONE');
                    const pickKey = keys[Math.floor(Math.random() * keys.length)];
                    const selectedDisaster = DISASTERS[pickKey];
                    
                    setDisaster(selectedDisaster);
                    setDisasterTimer(600); // 10 seconds duration approx
                    
                    setEvents(e => [`‚ö†Ô∏è Á•ûË´≠Ôºö${selectedDisaster.name} ÈôçËá®ÔºÅ`, ...e]);
                    
                    // Immediate Effects
                    if (pickKey === 'LOCUSTS') setTribe(t => ({...t, food: 0}));
                    if (pickKey === 'BEASTS') {
                        const newBeasts = [];
                        for(let i=0; i<5; i++) {
                            newBeasts.push({
                                id: `beast_${Date.now()}_${i}`, type: Math.random()>0.5?'WOLF':'BEAR',
                                x: MAP_WIDTH/2 + rand(-5,5), y: MAP_HEIGHT/2 + rand(-5,5),
                                hp: 80, targetX: null, targetY: null, state: 'WANDER', animFrame: 0, dir: 1
                            });
                        }
                        setCreatures(prev => [...prev, ...newBeasts]);
                    }
                    return;
                }

                if (mana < 20) return;
                if (['FOOD', 'HEAL', 'BUFF'].includes(type) && selectedId && selectedId !== 'CAVE_CENTER') {
                    setSims(prev => prev.map(s => {
                        if (s.id !== selectedId) return s;
                        if (type === 'FOOD') { setMana(m => m - 30); setEvents(e => [`Ë≥ú‰∫à ${s.sign} È£üÁâ©`, ...e]); return { ...s, hunger: 100 }; }
                        else if (type === 'HEAL') { setMana(m => m - 30); setEvents(e => [`${s.sign} ÂÇ∑Âè£ÁôíÂêà`, ...e]); return { ...s, hp: 100, sick: false }; }
                        else if (type === 'BUFF') { setMana(m => m - 30); setEvents(e => [`${s.sign} Áç≤ÂæóÁ•ûÂäõ`, ...e]); return { ...s, energy: 100, thought: 'Á•ûËàáÊàëÂêåÂú®ÔºÅ' }; }
                        return s;
                    }));
                    return;
                }
                setMana(m => m - 20);
                if (type === 'SUN') { setWeather(WEATHER.SUNNY); setDisaster(DISASTERS.NONE); setEvents(e => ['Á•ûËπüÔºöÁ•àÊô¥', ...e]); }
                else if (type === 'RAIN') { setWeather(WEATHER.RAIN); setDisaster(DISASTERS.NONE); setEvents(e => ['Á•ûËπüÔºöÁ•àÈõ®', ...e]); }
                else if (type === 'TECH') { setTribe(t => ({...t, tech: t.tech + 1})); setEvents(e => ['Á•ûËπüÔºöÊô∫ÊÖßÂïüËíô', ...e]); }
            };

            const update = useCallback(() => {
                if (isGameOver) return;
                const isNight = time > DAY_TICKS * 0.6 || disaster === DISASTERS.DARKNESS;
                
                // Disaster Timer
                if (disaster !== DISASTERS.NONE) {
                    setDisasterTimer(prev => {
                        if (prev <= 1) {
                            setDisaster(DISASTERS.NONE);
                            setEvents(e => ['Â§©ÁÅΩÂ∑≤ÈÄÄÂéª„ÄÇ', ...e]);
                            return 0;
                        }
                        return prev - 1;
                    });
                }

                // Weather Change (Only if no disaster overrides)
                if (tickRef.current % 10 === 0 && disaster === DISASTERS.NONE) {
                    setWeatherTimer(prev => prev - 1);
                    if (weatherTimer <= 0) {
                        const r = Math.random();
                        let nextW = r < 0.3 ? WEATHER.RAIN : (r < 0.4 ? WEATHER.SNOW : WEATHER.SUNNY);
                        setWeather(nextW); setWeatherTimer(rand(500, 1500));
                        setEvents(e => [`Â§©Ê∞£: ${nextW.name}`, ...e.slice(0,4)]);
                    }
                }

                // Disaster / Weather Effects
                // Particles
                setParticles(prev => {
                    const newP = [];
                    // Meteor
                    if (disaster === DISASTERS.METEOR && tickRef.current % 2 === 0) { 
                        newP.push({ x: rand(0, MAP_WIDTH * TILE_SIZE), y: -50, speed: rand(8,15), life: 60, color: '#ff4500', type: 'METEOR' });
                    }
                    // Locusts
                    if (disaster === DISASTERS.LOCUSTS && tickRef.current % 2 === 0) {
                        newP.push({ x: -10, y: rand(0, MAP_HEIGHT * TILE_SIZE), speed: rand(5,8), speedY: rand(-1,1), life: 100, color: '#5d4037', type: 'LOCUST' });
                    }
                    // Thunder
                    if (disaster === DISASTERS.THUNDER && Math.random() < 0.05) {
                        // Lightning Logic handled in Sims update, strictly visual here? 
                        // Maybe add flash particle
                    }
                    // Rain/Snow
                    if (disaster === DISASTERS.NONE && weather.id !== 'SUNNY' || disaster === DISASTERS.BLIZZARD || disaster === DISASTERS.FLOOD || disaster === DISASTERS.THUNDER) {
                         const pCount = weather.id === 'RAIN' || disaster === DISASTERS.FLOOD || disaster === DISASTERS.THUNDER ? 5 : 2;
                         const isSnow = weather.id === 'SNOW' || disaster === DISASTERS.BLIZZARD;
                         for(let i=0; i<pCount; i++) newP.push({ x: rand(0, MAP_WIDTH * TILE_SIZE), y: -10, speed: isSnow ? rand(1,3) : rand(8,12), life: 100, type: isSnow ? 'SNOW' : 'RAIN' });
                    }

                    return [...prev.map(p => {
                        let nx = p.x; let ny = p.y;
                        if (p.type === 'LOCUST') { nx += p.speed; ny += p.speedY; }
                        else if (p.type === 'SNOW') { ny += p.speed; nx += Math.sin(ny/10); }
                        else { ny += p.speed; if (p.type === 'METEOR') nx -= 2; }
                        return { ...p, x: nx, y: ny, life: p.life-1 };
                    }).filter(p => p.y < MAP_HEIGHT * TILE_SIZE + 50 && p.x < MAP_WIDTH * TILE_SIZE + 50 && p.life > 0), ...newP];
                });

                // Screen Shake (Earthquake)
                if (disaster === DISASTERS.QUAKE) setShake(prev => (tickRef.current % 4 === 0 ? rand(-3, 3) : 0));
                else setShake(0);

                // Farms Logic (Drought/Flood/Locusts)
                setFarms(prev => prev.map(f => {
                    if (disaster === DISASTERS.DROUGHT || disaster === DISASTERS.FLOOD || disaster === DISASTERS.LOCUSTS) return { ...f, stage: 0 }; // Kill crops
                    if (f.stage < 100) return { ...f, stage: Math.min(100, f.stage + 0.1 * (weather.id === 'RAIN' ? 2 : (weather.id === 'SNOW' ? 0 : 1))) };
                    return f;
                }));

                // Creatures
                setCreatures(prev => prev.map(c => {
                    if (c.hp <= 0) return null;
                    let nextC = { ...c };
                    
                    // Disaster Damage to Creatures
                    if (tickRef.current % 30 === 0) {
                        if (disaster === DISASTERS.METEOR && Math.random() < 0.1) nextC.hp -= 20;
                        if (disaster === DISASTERS.QUAKE && Math.random() < 0.2) nextC.hp -= 5;
                        if (disaster === DISASTERS.THUNDER && Math.random() < 0.05) { nextC.hp -= 50; setParticles(p=>[...p, {x: nextC.x*TILE_SIZE, y:nextC.y*TILE_SIZE, life:5, color:'#fff', type:'FLASH'}]); }
                    }

                    // ... (Existing Movement Logic) ...
                    let moveX = 0; let moveY = 0;
                    if (['WOLF', 'BEAR'].includes(nextC.type)) {
                        let targetSim = null; let minDist = 6; 
                        sims.forEach(s => { if (s.state !== 'DEAD' && !s.hidden) { const d = Math.sqrt((s.x - nextC.x)**2 + (s.y - nextC.y)**2); if (d < minDist) { minDist = d; targetSim = s; } } });
                        if (targetSim && minDist > 0.8) { const dx = targetSim.x - nextC.x; const dy = targetSim.y - nextC.y; moveX = Math.sign(dx) * 0.04; moveY = Math.sign(dy) * 0.04; }
                        else if (!targetSim) { if (tickRef.current % 20 === 0 && Math.random() < 0.1) { nextC.targetX = Math.max(0, Math.min(MAP_WIDTH-1, c.x + rand(-3, 3))); nextC.targetY = Math.max(0, Math.min(MAP_HEIGHT-1, c.y + rand(-3, 3))); } }
                    } else { if (tickRef.current % 20 === 0 && Math.random() < 0.1) { nextC.targetX = Math.max(0, Math.min(MAP_WIDTH-1, c.x + rand(-3, 3))); nextC.targetY = Math.max(0, Math.min(MAP_HEIGHT-1, c.y + rand(-3, 3))); } }

                    if (nextC.targetX !== null && !moveX && !moveY) {
                        const dx = nextC.targetX - nextC.x; const dy = nextC.targetY - nextC.y;
                        if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) nextC.targetX = null;
                        else { const speed = c.type === 'RABBIT' ? 0.08 : 0.04; moveX = Math.sign(dx) * speed; moveY = Math.sign(dy) * speed; }
                    }
                    // Flood slows movement
                    if (disaster === DISASTERS.FLOOD) { moveX *= 0.5; moveY *= 0.5; }

                    if (moveX || moveY) { nextC.x += moveX; nextC.y += moveY; nextC.dir = Math.sign(moveX); nextC.animFrame++; }
                    return nextC;
                }).filter(Boolean));

                // Sims Logic
                setSims(prev => prev.map(s => {
                    if (s.state === 'DEAD') return s;
                    let nextS = { ...s };
                    
                    // Metabolism & Disaster Effects
                    if (tickRef.current % 10 === 0) {
                        let hLoss = 0.2; let eLoss = 0.1;
                        if ((weather.id === 'SNOW' || disaster === DISASTERS.BLIZZARD) && !isInBase(nextS)) eLoss *= 3; // Cold drains energy fast
                        if (nextS.state === 'SLEEP' || nextS.state === 'HIDING') { eLoss = -0.5; hLoss = 0.1; }
                        
                        // Plague Effect
                        if (disaster === DISASTERS.PLAGUE && Math.random() < 0.1) nextS.sick = true;
                        if (nextS.sick) { nextS.hp -= 0.2; if(Math.random()<0.05) nextS.thought = 'È†≠Â•ΩÊöà...'; }

                        // Drought Effect
                        if (disaster === DISASTERS.DROUGHT) { hLoss *= 1.5; } // Thirsty/Hungry faster

                        nextS.hunger -= hLoss; nextS.energy -= eLoss;
                        if (nextS.hunger <= 0) nextS.hp -= 0.5;
                        if (nextS.hp <= 0) { nextS.state = 'DEAD'; setEvents(e => [`${nextS.sign} ÂõûÊ≠∏‰∫ÜÂ§ßÂú∞...`, ...e]); return nextS; }
                    }

                    // Physical Disaster Damage (Meteor, Quake, Thunder)
                    if (!nextS.hidden) {
                        if (tickRef.current % 30 === 0) {
                            if (disaster === DISASTERS.METEOR && Math.random() < 0.1) { nextS.hp -= 15; setEvents(e => [`${nextS.sign} Ë¢´ÊµÅÊòüÊìä‰∏≠!`, ...e]); }
                            if (disaster === DISASTERS.QUAKE && Math.random() < 0.2) nextS.hp -= 5;
                            if (disaster === DISASTERS.THUNDER && Math.random() < 0.05) { nextS.hp -= 50; setParticles(p=>[...p, {x: nextS.x*TILE_SIZE, y:nextS.y*TILE_SIZE, life:5, color:'#fff', type:'FLASH'}]); setEvents(e => [`${nextS.sign} Ë¢´Èõ∑Âäà‰∏≠!`, ...e]); }
                        }
                    }

                    // Hostile Check
                    let nearestHostile = null; let hostileDist = Infinity;
                    if (!nextS.hidden) { 
                        creatures.forEach(c => { if (['WOLF', 'BEAR'].includes(c.type) && c.hp > 0) { const d = Math.sqrt((c.x - nextS.x)**2 + (c.y - nextS.y)**2); if (d < hostileDist) { hostileDist = d; nearestHostile = c; } } });
                        
                        if (nearestHostile && hostileDist < 8) {
                            const panicHP = nextS.tools.spear ? 30 : (nextS.tools.axe || nextS.tools.pick ? 50 : 80);
                            if (nextS.hp < panicHP && nextS.state !== 'HIDING' && nextS.state !== 'SLEEP') {
                                nextS.state = 'FLEE'; nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2; nextS.thought = 'ÊïëÂëΩÔºÅÂø´ÂõûÊ¥ûÁ©¥ÔºÅ';
                            } else if (hostileDist < 4 && nextS.state !== 'HUNT' && nextS.state !== 'DEFEND' && nextS.state !== 'FLEE') {
                                nextS.state = 'DEFEND'; nextS.targetId = nearestHostile.id; nextS.thought = 'ÂèçÊìäÔºÅ';
                            }
                        }
                        if (nearestHostile && hostileDist < 1 && tickRef.current % 40 === 0) {
                            const dmg = nearestHostile.type === 'BEAR' ? 15 : 8;
                            nextS.hp -= dmg; setParticles(p => [...p, {x: nextS.x*TILE_SIZE, y: nextS.y*TILE_SIZE, color: '#ff0000', speed:1, life:10}]);
                            if (nextS.hp <= 0) { nextS.state = 'DEAD'; return nextS; }
                        }
                    }

                    // Disaster Flee Trigger (Physical Disasters)
                    const physicalDisasters = [DISASTERS.METEOR, DISASTERS.BLIZZARD, DISASTERS.THUNDER];
                    if (physicalDisasters.includes(disaster) && !nextS.hidden && nextS.state !== 'FLEE' && nextS.state !== 'DEAD') {
                        nextS.state = 'FLEE'; nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2; nextS.thought = 'Â§©ÁÅΩÔºÅÂø´Ë∫≤ÔºÅ';
                    }
                    // Darkness Panic
                    if (disaster === DISASTERS.DARKNESS && !nextS.hidden && Math.random() < 0.05) {
                        nextS.thought = 'Â•ΩÈªë...Â•ΩÂèØÊÄï...'; nextS.targetX = nextS.x; nextS.targetY = nextS.y; // Stop moving
                    }

                    // FSM execution (Simplified for brevity)
                    const distToTarget = nextS.targetX !== null ? Math.sqrt((nextS.x - nextS.targetX)**2 + (nextS.y - nextS.targetY)**2) : 0;
                    const inBase = isInBase(nextS);

                    if (nextS.state === 'IDLE') {
                        // ... (Logic same as before, simplified) ...
                        if (nextS.hunger < 50) {
                            if (tribe.food > 0 && inBase) { setTribe(t => ({...t, food: Math.max(0, t.food-10)})); nextS.hunger = 100; nextS.thought = 'ÂêÉÈ£Ω‰∫ÜÔºÅ'; }
                            else {
                                const harvestable = farms.find(f => f.stage >= 100);
                                if (harvestable && tribe.tech >= 1) { nextS.state = 'FARMING'; nextS.targetX = harvestable.x; nextS.targetY = harvestable.y; }
                                else { nextS.state = 'GATHER'; nextS.targetX = rand(1, MAP_WIDTH-2); nextS.targetY = rand(1, MAP_HEIGHT-2); }
                            }
                        } else if (nextS.energy < 20 || (isNight && !inBase)) {
                            nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2;
                            if (inBase) { nextS.state = 'SLEEP'; nextS.hidden = true; nextS.thought = 'ÈÄ≤Ê¥û‰ºëÊÅØ...'; }
                        } else {
                            if (nextS.hidden) { nextS.hidden = false; nextS.y += 1; }
                            // Random tasks...
                            if(Math.random() < 0.05) { nextS.targetX = nextS.x + rand(-2,2); nextS.targetY = nextS.y + rand(-2,2); }
                        }
                    }
                    else if (nextS.state === 'FLEE') {
                        const distToCave = Math.sqrt((nextS.x - MAP_WIDTH/2)**2 + (nextS.y - MAP_HEIGHT/2)**2);
                        if (distToCave < 1.5) { nextS.hidden = true; nextS.state = 'HIDING'; nextS.thought = 'Âëº...Ë∫≤Ëµ∑‰æÜ„ÄÇ'; nextS.targetX = null; }
                    }
                    else if (nextS.state === 'HIDING') {
                        if (tickRef.current % 10 === 0) nextS.hp = Math.min(100, nextS.hp + 1);
                        let safe = true;
                        // Check if disaster passed
                        if (physicalDisasters.includes(disaster)) safe = false;
                        creatures.forEach(c => { if (['WOLF', 'BEAR'].includes(c.type) && c.hp > 0) { const d = Math.sqrt((c.x - MAP_WIDTH/2)**2 + (c.y - MAP_HEIGHT/2)**2); if (d < 8) safe = false; } });
                        
                        if (safe && nextS.hp > 60) { nextS.state = 'IDLE'; nextS.hidden = false; nextS.y += 1; nextS.thought = 'ÂÆâÂÖ®‰∫ÜÂóéÔºü'; }
                    }
                    else if (['CRAFT_AXE','CRAFT_PICK','CRAFT_SPEAR','CHOP','MINE','GATHER'].includes(nextS.state)) {
                        // Resource gathering & Crafting logic (Same as before, condensed)
                        if(nextS.actionTimer > 0) nextS.actionTimer--;
                        else if (distToTarget < 0.5) {
                             if(nextS.state.includes('CRAFT')) {
                                 if (nextS.state === 'CRAFT_AXE') { nextS.tools.axe = true; setTribe(t => ({...t, wood: t.wood-10, stone: t.stone-5})); }
                                 else if (nextS.state === 'CRAFT_PICK') { nextS.tools.pick = true; setTribe(t => ({...t, wood: t.wood-10, stone: t.stone-5})); }
                                 else { nextS.tools.spear = true; setTribe(t => ({...t, wood: t.wood-10, stone: t.stone-5})); }
                                 setEvents(e => [`üí° ${nextS.sign} Ë£Ω‰Ωú‰∫ÜÂ∑•ÂÖ∑`, ...e]); nextS.state='IDLE';
                             } else if (nextS.state === 'CHOP') { setTribe(t=>({...t, wood:t.wood+20})); setMap(pm=>{const nm=[...pm]; nm[Math.round(nextS.targetY)][Math.round(nextS.targetX)].decoration=null; return nm;}); nextS.state='IDLE'; }
                             else if (nextS.state === 'MINE') { setTribe(t=>({...t, stone:t.stone+10})); setMap(pm=>{const nm=[...pm]; nm[Math.round(nextS.targetY)][Math.round(nextS.targetX)].decoration=null; return nm;}); nextS.state='IDLE'; }
                             else if (nextS.state === 'GATHER') { nextS.inventory.food+=10; setTribe(t=>({...t, food:t.food+5, wood:t.wood+2, stone:t.stone+1})); nextS.state='IDLE'; }
                        }
                    }
                    else if (['HUNT','DEFEND'].includes(nextS.state)) {
                        // Combat Logic (Same as before, condensed)
                        let target = nextS.state==='DEFEND' ? creatures.find(c=>c.id===nextS.targetId) : creatures[0]; // simplified finding
                        if (target && target.hp>0) {
                            nextS.targetX = target.x; nextS.targetY = target.y;
                            if (distToTarget < 1.5) {
                                nextS.actionTimer--;
                                if (nextS.actionTimer <= 0) {
                                    nextS.actionTimer = 40;
                                    setCreatures(prevC => prevC.map(c => { if(c.id===target.id){ const nh = c.hp - (nextS.tools.spear?25:10); if(nh<=0) { setTribe(t=>({...t, food:t.food+20})); setEvents(e=>[`${nextS.sign} ÊìäÊÆ∫ÈáéÁç∏`,...e]); } return {...c, hp:nh}; } return c; }));
                                    setParticles(p=>[...p, {x:target.x*TILE_SIZE, y:target.y*TILE_SIZE, speed:0, life:10, color:'#f00'}]);
                                }
                            }
                        } else nextS.state = 'IDLE';
                    }
                    else if (nextS.state === 'SLEEP') { if(nextS.energy>=100){ nextS.state='IDLE'; nextS.hidden=false; nextS.y+=1; } }

                    // Movement
                    if (nextS.targetX !== null && !nextS.hidden) {
                        const dx = nextS.targetX - nextS.x; const dy = nextS.targetY - nextS.y;
                        if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) nextS.targetX = null;
                        else {
                            let speed = 0.05; if (nextS.state === 'FLEE') speed = 0.08; 
                            if (disaster === DISASTERS.FLOOD) speed *= 0.5;
                            nextS.x += Math.sign(dx) * speed; nextS.y += Math.sign(dy) * speed;
                            nextS.animFrame++; nextS.dir = Math.sign(dx);
                        }
                    }
                    return nextS;
                }));
            }, [time, weather, farms, tribe, isGameOver, map, creatures, disaster]);

            const isInBase = (sim) => Math.sqrt((sim.x - MAP_WIDTH/2)**2 + (sim.y - MAP_HEIGHT/2)**2) < 5;

            const draw = useCallback(() => {
                const canvas = canvasRef.current; if (!canvas || !sprites) return;
                const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
                ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save(); ctx.scale(SCALE, SCALE);
                if (shake > 0) ctx.translate(shake, shake); // Earthquake Shake

                // Draw Map
                map.forEach(row => row.forEach(tile => {
                    const px = tile.x * TILE_SIZE; const py = tile.y * TILE_SIZE;
                    if (tile.type === 'SAND') ctx.drawImage(sprites.sand, px, py);
                    else if (tile.type === 'MOUNTAIN_GROUND') ctx.drawImage(sprites.mountain, px, py);
                    else if (tile.type === 'WATER') { ctx.fillStyle = PALETTE.WATER; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
                    else ctx.drawImage(sprites.grass, px, py);
                }));

                // Flood Overlay
                if (disaster === DISASTERS.FLOOD) { ctx.fillStyle = 'rgba(0, 50, 150, 0.3)'; ctx.fillRect(0,0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); }

                // Farms
                farms.forEach(f => { const px = f.x * TILE_SIZE; const py = f.y * TILE_SIZE; ctx.drawImage(sprites.dirt, px, py); if (f.stage > 80) ctx.drawImage(sprites.wheat_2, px, py); else if (f.stage > 20) ctx.drawImage(sprites.wheat_1, px, py); else { ctx.fillStyle = '#8d6e63'; ctx.fillRect(px+10, py+10, 2, 2); } });

                const objects = [];
                map.forEach(row => row.forEach(tile => { if (tile.decoration) objects.push({ y: tile.y, type: 'DECO', subtype: tile.decoration, x: tile.x }); }));
                sims.forEach(sim => { if(!sim.hidden) objects.push({ y: sim.y, type: 'SIM', data: sim }) });
                creatures.forEach(c => objects.push({ y: c.y, type: 'CREATURE', data: c }));
                objects.sort((a, b) => a.y - b.y);

                objects.forEach(obj => {
                    const px = obj.x * TILE_SIZE; const py = obj.y * TILE_SIZE;
                    if (obj.type === 'DECO') {
                        if (obj.subtype === 'CAVE') ctx.drawImage(sprites.cave, px - 16, py - 24);
                        else if (obj.subtype === 'TREE_OAK') ctx.drawImage(sprites.tree_oak, px, py - TILE_SIZE);
                        else if (obj.subtype === 'TREE_PINE') ctx.drawImage(sprites.tree_pine, px, py - TILE_SIZE);
                        else if (obj.subtype === 'ROCK') ctx.drawImage(sprites.rock, px, py);
                        else if (obj.subtype === 'BUSH') ctx.drawImage(sprites.bush, px, py);
                        else if (obj.subtype === 'FLOWER') ctx.drawImage(sprites.flower, px, py);
                        else if (obj.subtype === 'MUSHROOM') ctx.drawImage(sprites.mushroom, px, py);
                    } else if (obj.type === 'SIM') drawSim(ctx, obj.data);
                    else if (obj.type === 'CREATURE') drawCreature(ctx, obj.data);
                });

                if (selectedId) {
                    const target = [...sims, ...creatures].find(i => i.id === selectedId);
                    if (target && !target.hidden) {
                        const px = target.x * TILE_SIZE; const py = target.y * TILE_SIZE;
                        ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1.5; ctx.setLineDash([4, 2]);
                        ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE); ctx.setLineDash([]);
                    }
                }

                // Cave Count
                const hiddenCount = sims.filter(s => s.hidden).length;
                if (hiddenCount > 0) {
                    const cx = (MAP_WIDTH/2) * TILE_SIZE; const cy = (MAP_HEIGHT/2) * TILE_SIZE - 40;
                    ctx.fillStyle = '#fff'; ctx.font = '12px monospace'; ctx.shadowColor = "black"; ctx.shadowBlur = 2; ctx.fillText(`${hiddenCount}‰∫∫`, cx, cy); ctx.shadowBlur = 0;
                }

                // Particles
                particles.forEach(p => {
                    ctx.fillStyle = p.color || '#fff';
                    const w = p.type === 'METEOR' ? 4 : (p.type === 'FLASH' ? 32 : 2);
                    const h = p.type === 'METEOR' ? 4 : (p.type === 'FLASH' ? 32 : 2);
                    if (p.type === 'METEOR') { ctx.fillStyle = '#ff8800'; ctx.fillRect(p.x/SCALE+2, p.y/SCALE-4, 2, 4); ctx.fillStyle = '#ff4500'; }
                    ctx.fillRect(p.x / SCALE, p.y / SCALE, w, h);
                });
                
                // Overlays
                if (disaster === DISASTERS.DARKNESS) { ctx.fillStyle = 'rgba(0, 0, 0, 0.85)'; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); }
                else if (time > DAY_TICKS * 0.6) { ctx.fillStyle = 'rgba(10, 10, 30, 0.6)'; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); }
                if (weather.id === 'METEOR') { ctx.fillStyle = 'rgba(50, 10, 0, 0.3)'; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); }
                if (disaster !== DISASTERS.NONE && disaster.color) { ctx.fillStyle = disaster.color; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); }

                ctx.restore();
            }, [map, sprites, sims, creatures, weather, particles, farms, time, selectedId, tribe, disaster, shake]);

            const drawSim = (ctx, s) => {
                if (s.state === 'DEAD') { ctx.fillStyle = '#555'; ctx.fillRect(s.x*TILE_SIZE+14, s.y*TILE_SIZE+10, 4, 12); ctx.fillRect(s.x*TILE_SIZE+10, s.y*TILE_SIZE+14, 12, 4); return; }
                const px = Math.floor(s.x * TILE_SIZE); const py = Math.floor(s.y * TILE_SIZE);
                const bounce = (s.state !== 'IDLE' && s.state !== 'SLEEP') ? Math.sin(s.animFrame) * 2 : 0;
                const matrix = s.gender === 'M' ? SPRITE_MATRICES.CHAR_M : SPRITE_MATRICES.CHAR_F;
                const skinColor = s.sick ? PALETTE.SICK_SKIN : PALETTE.SKIN; // Sick visual
                const colorMap = { 'H': s.hair, 'S': skinColor, 's': PALETTE.SKIN_SHADOW, 'C': s.color, 'K': PALETTE.OUTLINE };
                renderMatrix(ctx, matrix, colorMap, px + 4, py + 4 + bounce);
                
                if (s.tools.spear || s.state === 'HUNT' || s.state === 'DEFEND' || s.state === 'CRAFT_SPEAR') {
                    ctx.fillStyle = PALETTE.TOOL_AXE; ctx.fillRect(px+22, py+6+bounce, 2, 14); ctx.fillStyle = PALETTE.TOOL_SPEAR; ctx.fillRect(px+21, py+4+bounce, 4, 3);
                } else if (s.tools.axe) {
                    ctx.fillStyle = PALETTE.TOOL_AXE; ctx.fillRect(px+20, py+10+bounce, 2, 8); ctx.fillStyle = PALETTE.TOOL_HEAD; ctx.fillRect(px+18, py+10+bounce, 6, 3);
                }

                if (s.state === 'SLEEP') { ctx.font = '10px monospace'; ctx.fillStyle = '#fff'; ctx.fillText('zZ', px+20, py); }
                if (s.state.includes('CRAFT')) { ctx.font = '10px monospace'; ctx.fillStyle = '#ffff00'; ctx.fillText('üî®', px, py); }
                if (s.state === 'FLEE') { ctx.font = '10px monospace'; ctx.fillStyle = '#ff0000'; ctx.fillText('!', px+10, py-5); }
                if (s.sick) { ctx.font = '10px monospace'; ctx.fillStyle = '#00ff00'; ctx.fillText('‚ò£Ô∏è', px, py-5); }
            };

            const drawCreature = (ctx, c) => {
                const px = Math.floor(c.x * TILE_SIZE); const py = Math.floor(c.y * TILE_SIZE);
                const bounce = Math.sin(c.animFrame) * 2;
                let matrix, colorMap, ox=0, oy=0;
                if (c.type === 'RABBIT') { matrix = SPRITE_MATRICES.RABBIT; colorMap = {'W': PALETTE.FUR_RABBIT, 'K': PALETTE.OUTLINE}; ox=4; oy=10; }
                else if (c.type === 'WOLF') { matrix = SPRITE_MATRICES.WOLF; colorMap = {'G': PALETTE.FUR_WOLF, 'K': PALETTE.OUTLINE}; ox=2; oy=6; }
                else if (c.type === 'BEAR') { matrix = SPRITE_MATRICES.BEAR; colorMap = {'B': PALETTE.FUR_BEAR, 'K': PALETTE.OUTLINE}; ox=-6; oy=-6; }
                else if (c.type === 'DEER') { matrix = SPRITE_MATRICES.DEER; colorMap = {'B': PALETTE.FUR_DEER, 'K': PALETTE.OUTLINE}; ox=2; oy=-2; }
                ctx.save(); if (c.dir < 0) { ctx.translate(px + TILE_SIZE, 0); ctx.scale(-1, 1); ctx.translate(-px, 0); }
                renderMatrix(ctx, matrix, colorMap, px + ox, py + oy + bounce);
                ctx.restore();
            };

            useEffect(() => {
                const loop = () => {
                    tickRef.current++;
                    if (tickRef.current % 5 === 0) { setTime(t => (t + 1) % DAY_TICKS); if (time === 0) setDay(d => d+1); update(); }
                    draw(); requestRef.current = requestAnimationFrame(loop);
                };
                requestRef.current = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(requestRef.current);
            }, [draw, update]);

            const handleCanvasClick = useCallback((e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = (e.clientX - rect.left) / SCALE / TILE_SIZE;
                const y = (e.clientY - rect.top) / SCALE / TILE_SIZE;
                
                let closest = null; let minDist = 2.5;
                const visibleObjs = [...sims.filter(s => !s.hidden), ...creatures];
                visibleObjs.forEach(obj => { const dist = Math.sqrt((obj.x + 0.5 - x)**2 + (obj.y + 0.5 - y)**2); if (dist < minDist) { closest = obj; minDist = dist; } });

                if (closest) setSelectedId(closest.id);
                else {
                    const distToCenter = Math.sqrt((x - MAP_WIDTH/2)**2 + (y - MAP_HEIGHT/2)**2);
                    if (distToCenter < 2.0) setSelectedId('CAVE_CENTER'); else setSelectedId(null);
                }
            }, [sims, creatures]);

            const selectedObj = [...sims, ...creatures].find(s => s.id === selectedId);
            const aliveCount = sims.filter(s => s.state !== 'DEAD').length;

            return (
                <div className="flex flex-col h-[100dvh] bg-[#1a1c2c] text-[#c2c3c7]" style={{ fontFamily: PIXEL_FONT }}>
                    {/* Top Bar */}
                    <div className="bg-[#292b3c] p-2 md:p-3 border-b-4 border-[#121215] flex justify-between items-center shadow-lg shrink-0 z-20 relative gap-2">
                        <div className="flex gap-2 md:gap-4 items-center">
                            <div className="text-[#ffcd75] font-bold flex items-center gap-1 md:gap-2 text-sm md:text-base"><Icons.Sparkles size={14} className="md:w-4 md:h-4"/> {mana}</div>
                            <div className="flex items-center gap-1 md:gap-2 bg-[#1a1c2c] px-2 py-1 rounded border border-[#5d4037] text-xs md:text-sm">
                                {weather.id === 'SUNNY' ? <Icons.Sun size={14} className="text-yellow-400"/> : weather.id === 'RAIN' ? <Icons.CloudRain size={14} className="text-blue-400"/> : (weather.id === 'METEOR' ? <Icons.Zap size={14} className="text-orange-500"/> : <Icons.Snowflake size={14} className="text-white"/>)}
                                <span>{disaster !== DISASTERS.NONE ? disaster.name : weather.name}</span>
                            </div>
                            <div className="hidden md:block text-xs text-gray-400">Á¨¨ {era} Á¥ÄÂÖÉ Day {day}</div>
                        </div>
                        <div className="flex gap-2 md:gap-3 text-xs font-bold text-[#8b9bb4] items-center">
                            <span className="flex items-center gap-1"><Icons.Users size={12}/> {aliveCount}</span>
                            <span>üçé {Math.floor(tribe.food)}</span>
                            <span className="hidden sm:inline">ü™µ {tribe.wood}</span>
                            <span className="hidden sm:inline">üß± {tribe.stone}</span>
                            <span>üî® Lv.{tribe.tech}</span>
                        </div>
                    </div>

                    {/* Main Game Area */}
                    <div className="flex-1 flex flex-col md:flex-row overflow-hidden relative">
                        {isGameOver && (
                            <div className="absolute inset-0 z-50 bg-black/90 flex flex-col items-center justify-center animate-in fade-in zoom-in duration-500">
                                <Icons.Skull size={64} className="text-red-600 mb-4 animate-bounce"/>
                                <h1 className="text-4xl text-red-500 font-bold mb-2">ÊñáÊòéÊªÖ‰∫°</h1>
                                <button onClick={startNextEra} className="bg-red-900 hover:bg-red-800 text-white px-8 py-4 rounded border-2 border-red-500 flex items-center gap-3 text-xl mt-8">
                                    <Icons.RefreshCw size={24}/> ÈñãÂïüÁ¨¨ {era+1} Á¥ÄÂÖÉ
                                </button>
                            </div>
                        )}

                        <div className="relative flex-1 bg-black overflow-hidden flex">
                            <div className="w-full h-full overflow-auto flex items-center justify-center p-4 touch-pan-x touch-pan-y">
                                <canvas ref={canvasRef} width={MAP_WIDTH * TILE_SIZE * SCALE} height={MAP_HEIGHT * TILE_SIZE * SCALE} onClick={handleCanvasClick} className="border-4 border-[#3e2723] shadow-2xl cursor-crosshair" style={{ imageRendering: 'pixelated' }} />
                            </div>
                            <div className="absolute bottom-4 left-4 md:bottom-6 md:left-6 flex flex-col-reverse gap-1 pointer-events-none opacity-90 items-start max-w-[70%] md:max-w-none z-10">
                                {events.slice(0, 5).map((ev, i) => (
                                    <div key={i} className="bg-black/60 text-[#fff] px-2 py-1 md:px-3 md:py-1.5 text-[10px] md:text-xs rounded border-l-2 border-[#ffcd75] shadow-sm backdrop-blur-sm animate-in fade-in slide-in-from-left-2 duration-300">
                                        {ev}
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div className="w-full h-[35vh] md:w-72 md:h-full bg-[#292b3c] border-t-4 md:border-t-0 md:border-l-4 border-[#121215] p-2 md:p-4 pb-8 md:pb-4 flex flex-col gap-2 md:gap-4 shrink-0 z-10 relative overflow-y-auto shadow-2xl">
                            <div className="bg-[#1a1c2c] p-2 md:p-3 rounded border border-[#3e2723]">
                                <h3 className="text-[#ffcd75] text-xs md:text-sm mb-2 font-bold border-b border-[#3e2723] pb-1">Á•ûËπü</h3>
                                <div className="grid grid-cols-4 md:grid-cols-2 gap-2">
                                    <button onClick={() => castSpell('SUN')} className="bg-[#3e2723] hover:bg-[#5d4037] p-2 rounded flex flex-col items-center justify-center gap-1 transition-colors aspect-square md:aspect-auto"><Icons.Sun size={18} className="text-yellow-400"/><span className="text-[10px]">Á•àÊô¥</span></button>
                                    <button onClick={() => castSpell('RAIN')} className="bg-[#3e2723] hover:bg-[#5d4037] p-2 rounded flex flex-col items-center justify-center gap-1 transition-colors aspect-square md:aspect-auto"><Icons.CloudRain size={18} className="text-blue-400"/><span className="text-[10px]">Á•àÈõ®</span></button>
                                    <button onClick={() => castSpell('TECH')} className="bg-[#3e2723] hover:bg-[#5d4037] p-2 rounded flex flex-col items-center justify-center gap-1 transition-colors aspect-square md:aspect-auto"><Icons.Brain size={18} className="text-purple-400"/><span className="text-[10px]">Êô∫ÊÖß</span></button>
                                    <button onClick={handleTribeSaga} disabled={isWritingSaga || mana < 50} className={`bg-indigo-900 hover:bg-indigo-800 p-2 rounded flex flex-col items-center justify-center gap-1 transition-colors border border-indigo-500 aspect-square md:aspect-auto ${isWritingSaga ? 'opacity-50' : ''}`}><Icons.ScrollText size={18} className="text-indigo-300"/><span className="text-[10px] text-indigo-200">Âè≤Ë©©</span></button>
                                    <button onClick={() => castSpell('DISASTER')} disabled={mana < 100} className={`col-span-4 md:col-span-2 bg-red-900/50 hover:bg-red-800 p-2 rounded flex flex-row md:flex-col items-center justify-center gap-2 transition-colors border border-red-700 ${mana < 100 ? 'opacity-50 cursor-not-allowed' : ''}`}>
                                        <Icons.Biohazard size={18} className="text-orange-400 animate-pulse"/>
                                        <span className="text-[10px] text-red-200 font-bold">Â§©ÁÅΩ (100)</span>
                                    </button>
                                </div>
                            </div>

                            <div className="flex-1 bg-[#1a1c2c] p-2 md:p-3 rounded border border-[#3e2723] relative flex flex-col min-h-[140px] md:min-h-[300px]">
                                <div className="flex justify-between items-center border-b border-[#3e2723] mb-2 pb-1"><h3 className="text-[#8b9bb4] text-xs md:text-sm font-bold">ËßÄÂØü</h3>{selectedId && <button onClick={() => setSelectedId(null)} className="text-gray-500 hover:text-white"><Icons.X size={14}/></button>}</div>
                                
                                {selectedId === 'CAVE_CENTER' ? (
                                    <div className="flex flex-col gap-2 flex-1 animate-fade-in overflow-y-auto">
                                        <div className="flex items-center gap-2 text-[#8d6e63]">
                                            <Icons.Home size={20}/>
                                            <span className="font-bold">Â≤©Áü≥Ê¥ûÁ©¥ (Cave)</span>
                                        </div>
                                        <div className="text-xs text-gray-400">ÂÖßÈÉ®‰∫∫Êï∏: {sims.filter(s=>s.hidden).length}</div>
                                        <div className="mt-2 overflow-y-auto flex-1 space-y-2 pr-1">
                                           {sims.filter(s => s.hidden).map(s => (
                                               <div key={s.id} className="bg-[#111] p-2 rounded border border-gray-800 text-xs">
                                                   <div className="flex justify-between mb-1">
                                                       <span className="font-bold" style={{color: '#ffccaa'}}>{s.sign}Â∫ß</span>
                                                       <span className="text-gray-500 text-[10px]">{s.state}</span>
                                                   </div>
                                                   <div className="text-[#a5d6a7] italic">"{s.thought}"</div>
                                               </div>
                                           ))}
                                           {sims.filter(s => s.hidden).length === 0 && <div className="text-gray-600 text-center py-4 text-xs">Ê¥ûÂÖßÁ©∫ÁÑ°‰∏Ä‰∫∫</div>}
                                        </div>
                                    </div>
                                ) : selectedObj ? (
                                    <div className="flex flex-col gap-1 md:gap-2 flex-1 animate-fade-in overflow-y-auto">
                                        {selectedObj.sign ? ( 
                                            <>
                                                <div className="flex items-center gap-2 md:gap-3">
                                                    <div className="w-8 h-8 md:w-10 md:h-10 border border-gray-600 bg-black relative overflow-hidden shrink-0"><div className="absolute top-2 left-2 w-6 h-6" style={{backgroundColor: selectedObj.hair, borderRadius: '50% 50% 0 0'}}></div><div className="absolute top-4 left-1 w-8 h-8" style={{backgroundColor: selectedObj.color, borderRadius: '50% 50% 0 0'}}></div></div>
                                                    <div><div className="font-bold text-[#ffccaa] text-sm md:text-base">{selectedObj.sign}Â∫ß</div><div className="text-[10px] text-gray-500">{selectedObj.state}</div></div>
                                                </div>
                                                
                                                <div className="space-y-1 mt-1 text-xs">
                                                    <div className="flex justify-between"><span>HP</span><span>{Math.floor(selectedObj.hp)}</span></div>
                                                    <div className="h-1 bg-gray-700"><div className="h-full bg-red-500" style={{width: `${Math.max(0, selectedObj.hp)}%`}}></div></div>
                                                    <div className="flex justify-between"><span>È£ΩÈ£ü</span><span>{Math.floor(selectedObj.hunger)}</span></div>
                                                    <div className="h-1 bg-gray-700"><div className="h-full bg-orange-500" style={{width: `${Math.max(0, selectedObj.hunger)}%`}}></div></div>
                                                    <div className="flex justify-between text-gray-400 mt-1 border-t border-gray-800 pt-1">
                                                        <span>Â∑•ÂÖ∑</span>
                                                        <span>{[selectedObj.tools.axe?'Êñß':'', selectedObj.tools.pick?'Èé¨':''].filter(Boolean).join(',') || 'ÁÑ°'}</span>
                                                        {selectedObj.tools.spear && <span>, Èï∑Áüõ</span>}
                                                    </div>
                                                </div>

                                                <div className="mt-1 bg-[#111] p-1.5 text-[10px] md:text-xs text-[#a5d6a7] italic border border-gray-800 flex flex-col gap-1"><span>"{selectedObj.thought}"</span><button onClick={() => handleSoulSearch(selectedObj)} disabled={isSoulSearching || mana < 10} className="self-end flex items-center gap-1 bg-gray-800 hover:bg-gray-700 px-2 py-1 rounded text-purple-300 border border-purple-900"><Icons.MessageCircle size={10}/> ÂÇæËÅΩ (10)</button></div>
                                                
                                                <div className="mt-auto grid grid-cols-3 gap-1 pt-2 border-t border-[#3e2723]">
                                                    <button onClick={() => castSpell('FOOD')} className="bg-[#3e2723] hover:bg-[#5d4037] p-1.5 rounded flex flex-col items-center gap-0.5"><Icons.Utensils size={14} className="text-orange-400"/><span className="text-[10px]">Ë≥úÈ£ü</span></button>
                                                    <button onClick={() => castSpell('HEAL')} className="bg-[#3e2723] hover:bg-[#5d4037] p-1.5 rounded flex flex-col items-center gap-0.5"><Icons.Heart size={14} className="text-red-400"/><span className="text-[10px]">Ê≤ªÁôí</span></button>
                                                    <button onClick={() => castSpell('BUFF')} className="bg-[#3e2723] hover:bg-[#5d4037] p-1.5 rounded flex flex-col items-center gap-0.5"><Icons.Shield size={14} className="text-blue-400"/><span className="text-[10px]">Ë≥úÁ¶è</span></button>
                                                </div>
                                            </>
                                        ) : (<><div className="font-bold text-[#ffccaa] text-sm md:text-lg">{selectedObj.type}</div><div className="text-[10px] md:text-xs text-gray-500">ÈáéÁîüÁîüÁâ©</div></>)}
                                    </div>
                                ) : (<div className="h-full flex flex-col items-center justify-center text-gray-600 text-xs gap-2 opacity-50"><Icons.HelpCircle size={24}/><div className="text-center">ÈÅ∏ÊìáÁõÆÊ®ô</div></div>)}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>