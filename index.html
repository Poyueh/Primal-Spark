<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <!-- å¢åŠ  maximum-scale=1.0, user-scalable=no é˜²æ­¢æ‰‹æ©Ÿèª¤è§¸ç¸®æ”¾ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åŸåˆä¹‹ç« Primal Spark (Emojiç‰ˆ)</title>
    
    <!-- 1. è¼‰å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. è¼‰å…¥ React èˆ‡ ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- 3. è¼‰å…¥ Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* ä¿æŒ body ç„¡æ²å‹•ï¼Œå…§å®¹å€åŸŸè‡ªå·±æ²å‹• */
        body { margin: 0; overflow: hidden; background-color: #111; }
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        /* è‡ªå®šç¾©æ²è»¸æ¨£å¼ */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #4a4a4a; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }

        /* è®“è§¸æ§é»æ“Šæ›´éˆæ• */
        button { touch-action: manipulation; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const { createRoot } = ReactDOM;

        // --- Icon Components ---
        const Icon = ({ char, className, size }) => (
            <span className={className} style={{ fontSize: size || 16, lineHeight: 1 }}>{char}</span>
        );

        const Icons = {
            Sparkles: (p) => <Icon char="âœ¨" {...p}/>,
            Heart: (p) => <Icon char="â¤ï¸" {...p}/>,
            Utensils: (p) => <Icon char="ğŸ–" {...p}/>,
            Shield: (p) => <Icon char="ğŸ›¡ï¸" {...p}/>,
            CloudRain: (p) => <Icon char="ğŸŒ§ï¸" {...p}/>,
            Snowflake: (p) => <Icon char="â„ï¸" {...p}/>,
            Sun: (p) => <Icon char="â˜€ï¸" {...p}/>,
            Cloud: (p) => <Icon char="â˜ï¸" {...p}/>,
            Flame: (p) => <Icon char="ğŸ”¥" {...p}/>,
            Mountain: (p) => <Icon char="â›°ï¸" {...p}/>,
            Skull: (p) => <Icon char="ğŸ’€" {...p}/>,
            RefreshCw: (p) => <Icon char="ğŸ”„" {...p}/>,
            X: (p) => <Icon char="âŒ" {...p}/>,
            Brain: (p) => <Icon char="ğŸ§ " {...p}/>,
            ScrollText: (p) => <Icon char="ğŸ“œ" {...p}/>,
            MessageCircle: (p) => <Icon char="ğŸ’¬" {...p}/>,
            HelpCircle: (p) => <Icon char="â“" {...p}/>,
            Users: (p) => <Icon char="ğŸ‘¥" {...p}/>,
            Hammer: (p) => <Icon char="ğŸ”¨" {...p}/>
        };

        const apiKey = ""; 

        // --- Mock Data ---
        const MOCK_THOUGHTS = ["é€™æ£µæ¨¹å¯ä»¥ç”¨ä¾†è“‹æˆ¿å­...", "çŸ³é ­é›–ç„¶ç¡¬ï¼Œä½†èƒ½åšæˆå·¥å…·ã€‚", "æˆ‘å€‘éœ€è¦æ›´å¤šé˜²ç¦¦ã€‚", "å‰µé€ æ˜¯ç”Ÿå­˜çš„é—œéµã€‚", "å¥½ç´¯ï¼Œä½†å€¼å¾—ã€‚"];
        const MOCK_SAGAS = ["æ—äººå­¸æœƒäº†åˆ©ç”¨å¤§åœ°çš„æ©è³œï¼Œå·¥å…·çš„æ•²æ“Šè²éŸ¿å¾¹æ£®æ—ã€‚", "ç¬¬ä¸€æŠŠçŸ³æ–§çš„èª•ç”Ÿï¼Œæ¨™èªŒè‘—æˆ‘å€‘ä¸å†æ˜¯è‡ªç„¶çš„å¥´éš¸ã€‚", "æ™ºæ…§ä¹‹ç«åœ¨éƒ¨è½ä¸­å‚³éï¼Œå‰µé€ åŠ›å¼•é ˜æˆ‘å€‘å‰è¡Œã€‚"];

        // --- Constants ---
        const PIXEL_FONT = "'Courier New', Courier, monospace";
        const TILE_SIZE = 32;
        const SCALE = 2.0; 

        const PALETTE = {
            OUTLINE: '#1a1c2c', SKIN: '#ffccaa', SKIN_SHADOW: '#d48e7e',
            GRASS_BG: '#388e3c', GRASS_L: '#4caf50', GRASS_D: '#1b5e20',
            DIRT: '#5d4037', WATER: '#4a69bd',
            WHEAT_1: '#a5d6a7', WHEAT_2: '#e6ee9c', WHEAT_3: '#fbc02d',
            STONE_L: '#b0bec5', STONE_M: '#78909c', STONE_D: '#546e7a',
            WOOD_L: '#8d6e63', WOOD_D: '#3e2723',
            LEAF_L: '#66bb6a', LEAF_D: '#2e7d32', LEAF_PINE: '#1b5e20',
            FLOWER_R: '#e57373', FLOWER_Y: '#fff176', MUSHROOM: '#f44336',
            FUR_WOLF: '#90a4ae', FUR_BEAR: '#4e342e', FUR_DEER: '#a1887f', FUR_RABBIT: '#fafafa',
            WHITE: '#ffffff', TRANSPARENT: null,
            TOOL_AXE: '#8d6e63', TOOL_HEAD: '#90a4ae', TOOL_SPEAR: '#d7ccc8'
        };

        const callGemini = async (prompt, type) => {
            if (!apiKey) { 
                await new Promise(r => setTimeout(r, 800));
                if (type === 'SAGA') return MOCK_SAGAS[Math.floor(Math.random() * MOCK_SAGAS.length)];
                return MOCK_THOUGHTS[Math.floor(Math.random() * MOCK_THOUGHTS.length)];
            }
            try {
                const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || null;
            } catch (error) { return null; }
        };

        const SPRITE_MATRICES = {
            CHAR_M: ["........................",".......HHHHHH...........","......HSSSSSSH..........",".....HSSKSSKSSH.........",".....HSSSSSSSSH.........","......SSSSSSSS..........","....CCCSCCCCSCCC........","....CCCSCCCCSCCC........","....CCCCCCCCCCCC........","....KKKCCCCCCKKK........","....K.KCCCCCCK.K........","......KSSSSSSK..........","......KSSSSSSK..........","......KKK..KKK.........."],
            CHAR_F: ["........................","......HHHHHHHH..........",".....HSSSSSSSSH.........",".....HSSKSSKSSH.........",".....HSSSSSSSSH.........",".....SSSSSSSSSS.........","....CCCSCCCCSCCC........","...CCCCSCCCCSCCCC.......","...CCCCCCCCCCCCCC.......","...CCCCCCCCCCCCCC.......","....CCCCCCCCCCCC........",".....KSSSSSSssk.........",".....KSSSSSSssk.........",".....KKK....KKK........."],
            TREE_OAK: [".......LLLLLL.......",".....LLLLLLLLLL.....","....LLLLLLLLLLLL....","...LLLLLLLLLLLLLL...","...LLLLLLLLLLLLLL...","....LLLLLLLLLLLL....",".....LLLLLLLLLL.....",".......WWWWWW.......",".......WWWWWW.......",".......WWWWWW.......","......WWWWWWWW......"],
            TREE_PINE: ["..........L.........",".........LLL........","........LLLLL.......",".......LLLLLLL......",".........LLL........","........LLLLL.......",".......LLLLLLL......","......LLLLLLLLL.....",".....LLLLLLLLLLL....","........WWWWW.......",".......WWWWWWW......"],
            BUSH: ["....................","......LLLLLLL.......",".....LLLLLLLLL......","....LLLLLLLLLLL.....","....LLLLLLLLLLL.....",".....LLLLLLLLL......"],
            FLOWER: [".........R..........","........RYR.........",".........R..........",".........G..........",".........G.........."],
            MUSHROOM: ["........RRR.........",".......RRRRR........",".......RWWWR........","........WWW.........","........WWW........."],
            ROCK: [".......KKKKKK.......",".....KKMMMMMMKK.....","....KMMLLLLLLMMK....","...KMLLLLLLLLLLMK...","...KMMMMMMMMMMMMK...","...KDDDDDDDDDDDDK...","....KKDDDDDDDDKK....","......KKKKKKKK......"],
            RABBIT: [".......KK...........","......KWWK..........",".....KWWWWK.........",".....KWWWWK.........","......KKKK.........."],
            WOLF: ["....................",".......K............","......KGK...........",".....KGGGK..........","....KGGGGGK...K.....","...KGGGGGGGGKKGK....","...KGGGGGGGGGGGK....","....KGGGGGGGGGK.....","....K.K.....K.K....."],
            BEAR: [".........KK...KK....","......KKKBBKKKBBK...",".....KBBBBBBBBBBBK..","....KBBBBBBBBBBBBBK.","...KBBBBBBBBBBBBBBBK","...KBBBBBBBBBBBBBBBK","...KBBBBBBBBBBBBBBBK","....KB.B.B.....B.B..","....KK.K.K.....K.K.."],
            DEER: ["...........K...K....","............K.K.....","..........KKKBKK....",".........KBBBBBBK...","........KBBBBBBBBK..",".......KBBBBBBBBBK..",".......K.B.....B....",".......K.K.....K...."],
            WHEAT_GROW: ["................","....1......1....","...111....111...","....1......1....","................"],
            WHEAT_READY: ["....3......3....","...333....333...","...333....333...","....3......3....","....3......3...."]
        };

        const MAP_WIDTH = 24; const MAP_HEIGHT = 24; const DAY_TICKS = 800; 

        const WEATHER = {
            SUNNY: { id: 'SUNNY', name: 'æ™´å¤©', color: 'rgba(255,255,0,0.1)' },
            RAIN: { id: 'RAIN', name: 'é›¨å¤©', color: 'rgba(0,0,50,0.3)' },
            SNOW: { id: 'SNOW', name: 'é™é›ª', color: 'rgba(200,240,255,0.2)' }
        };

        const ZODIACS = [
            { sign: 'ç‰¡ç¾Š', gender: 'M', color: '#c0392b', hair: '#2c3e50', trait: 'å¥½é¬¥' },
            { sign: 'é‡‘ç‰›', gender: 'F', color: '#27ae60', hair: '#5d4037', trait: 'å›ºåŸ·' },
            { sign: 'é›™å­', gender: 'M', color: '#f39c12', hair: '#e67e22', trait: 'å–„è®Š' },
            { sign: 'å·¨èŸ¹', gender: 'F', color: '#7f8c8d', hair: '#34495e', trait: 'é¡§å®¶' },
            { sign: 'ç…å­', gender: 'M', color: '#e67e22', hair: '#f1c40f', trait: 'éœ¸æ°£' },
            { sign: 'è™•å¥³', gender: 'F', color: '#16a085', hair: '#2ecc71', trait: 'è¬¹æ…' },
            { sign: 'å¤©ç§¤', gender: 'M', color: '#e84393', hair: '#fd79a8', trait: 'çŒ¶è±«' },
            { sign: 'å¤©è ', gender: 'F', color: '#8e44ad', hair: '#2c3e50', trait: 'æ•éŠ³' },
            { sign: 'å°„æ‰‹', gender: 'M', color: '#2980b9', hair: '#3498db', trait: 'å†’éšª' },
            { sign: 'æ‘©ç¾¯', gender: 'F', color: '#576574', hair: '#1e272e', trait: 'å …å¿' },
            { sign: 'æ°´ç“¶', gender: 'M', color: '#00d2d3', hair: '#00cec9', trait: 'å¤æ€ª' },
            { sign: 'é›™é­š', gender: 'F', color: '#a29bfe', hair: '#6c5ce7', trait: 'æµªæ¼«' }
        ];

        const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const noise = (x, y) => Math.sin(x/3.5) + Math.cos(y/4.5);

        const renderMatrix = (ctx, matrix, colors, offsetX = 0, offsetY = 0) => {
            matrix.forEach((row, y) => {
                for (let x = 0; x < row.length; x++) {
                    const char = row[x];
                    if (char === '.') continue;
                    let fill = colors[char] || PALETTE.OUTLINE;
                    if (char === 'K') fill = PALETTE.OUTLINE;
                    ctx.fillStyle = fill;
                    ctx.fillRect(offsetX + x, offsetY + y, 1, 1);
                }
            });
        };

        const createSprites = () => {
            const cache = {};
            const createCanvas = (w, h) => { const c = document.createElement('canvas'); c.width = w; c.height = h; return { c, ctx: c.getContext('2d') }; };

            const { c: grassC, ctx: grassCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            grassCtx.fillStyle = PALETTE.GRASS_BG; grassCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            grassCtx.fillStyle = PALETTE.GRASS_L; for(let i=0; i<30; i++) grassCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            grassCtx.fillStyle = PALETTE.GRASS_D; for(let i=0; i<20; i++) grassCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.grass = grassC;

            const { c: dirtC, ctx: dirtCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            dirtCtx.fillStyle = PALETTE.DIRT; dirtCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            dirtCtx.fillStyle = PALETTE.WOOD_D; for(let i=0; i<40; i++) dirtCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.dirt = dirtC;

            const makeSprite = (name, mat, colors, wMult=1, hMult=1, ox=0, oy=0) => {
                const { c, ctx } = createCanvas(TILE_SIZE*wMult, TILE_SIZE*hMult);
                renderMatrix(ctx, mat, colors, ox, oy);
                cache[name] = c;
            };

            makeSprite('tree_oak', SPRITE_MATRICES.TREE_OAK, {'L': PALETTE.LEAF_D, 'W': PALETTE.WOOD_D}, 1, 2, 6, 10);
            makeSprite('tree_pine', SPRITE_MATRICES.TREE_PINE, {'L': PALETTE.LEAF_PINE, 'W': PALETTE.WOOD_D}, 1, 2, 6, 8);
            makeSprite('bush', SPRITE_MATRICES.BUSH, {'L': PALETTE.LEAF_L}, 1, 1, 4, 16);
            makeSprite('flower', SPRITE_MATRICES.FLOWER, {'R': PALETTE.FLOWER_R, 'Y': PALETTE.FLOWER_Y, 'G': PALETTE.GRASS_L}, 1, 1, 10, 16);
            makeSprite('mushroom', SPRITE_MATRICES.MUSHROOM, {'R': PALETTE.MUSHROOM, 'W': PALETTE.WHITE}, 1, 1, 10, 16);
            makeSprite('rock', SPRITE_MATRICES.ROCK, {'K': PALETTE.OUTLINE, 'M': PALETTE.STONE_M, 'L': PALETTE.STONE_L, 'D': PALETTE.STONE_D}, 1, 1, 8, 16);
            makeSprite('rabbit', SPRITE_MATRICES.RABBIT, {'W': PALETTE.FUR_RABBIT}, 1, 1, 8, 16);
            makeSprite('wolf', SPRITE_MATRICES.WOLF, {'G': PALETTE.FUR_WOLF}, 1, 1, 4, 12);
            makeSprite('bear', SPRITE_MATRICES.BEAR, {'B': PALETTE.FUR_BEAR}, 1.5, 1.5, 4, 10);
            makeSprite('deer', SPRITE_MATRICES.DEER, {'B': PALETTE.FUR_DEER}, 1, 1.5, 4, 10);
            makeSprite('wheat_1', SPRITE_MATRICES.WHEAT_GROW, { '1': PALETTE.WHEAT_1 }, 1, 1, 8, 16);
            makeSprite('wheat_2', SPRITE_MATRICES.WHEAT_READY, { '3': PALETTE.WHEAT_3 }, 1, 1, 8, 16);

            return cache;
        };

        const generateMapData = () => {
            const newMap = [];
            for(let y=0; y<MAP_HEIGHT; y++) {
                const row = [];
                for(let x=0; x<MAP_WIDTH; x++) {
                    const n = noise(x + Math.random()*10, y + Math.random()*10);
                    let type = 'GRASS';
                    let decoration = null;
                    if (Math.abs(n) > 1.2) type = 'MOUNTAIN';
                    else if (n < -0.4) type = 'FOREST';
                    else if (n > 0.8) type = 'WATER';
                    const dist = Math.sqrt((x-MAP_WIDTH/2)**2 + (y-MAP_HEIGHT/2)**2);
                    if (dist < 5) type = 'BASE';
                    if (dist > 9 && n > 0.5) type = 'WATER';
                    if (type === 'FOREST') {
                        if (Math.random() > 0.6) decoration = 'TREE_OAK';
                        else decoration = 'TREE_PINE';
                        if (Math.random() < 0.1) decoration = 'MUSHROOM';
                    } else if (type === 'GRASS') {
                        const rnd = Math.random();
                        if (rnd < 0.05) decoration = 'ROCK';
                        else if (rnd < 0.1) decoration = 'BUSH';
                        else if (rnd < 0.15) decoration = 'FLOWER';
                    }
                    row.push({ x, y, type, decoration });
                }
                newMap.push(row);
            }
            return newMap;
        };

        const generateSimsData = () => ZODIACS.map((z, i) => ({
            id: `sim_${Date.now()}_${i}`, ...z,
            x: MAP_WIDTH/2 + rand(-2,2), y: MAP_HEIGHT/2 + rand(-2,2),
            hp: 100, hunger: 100, energy: 100,
            state: 'IDLE', targetX: null, targetY: null, actionTimer: 0,
            inventory: { wood:0, food:0, stone:0 },
            tools: { axe: false, pick: false, spear: false },
            thought: 'åˆæ˜¯æ–°çš„ä¸€å¤©...',
            animFrame: rand(0,10), dir: 1
        }));

        const generateCreaturesData = () => {
            const initCreatures = [];
            for(let i=0; i<8; i++) {
                const type = Math.random() < 0.4 ? 'RABBIT' : (Math.random() < 0.7 ? 'DEER' : (Math.random() < 0.9 ? 'WOLF' : 'BEAR'));
                initCreatures.push({
                    id: `c_${Date.now()}_${i}`, type,
                    x: rand(1, MAP_WIDTH-2), y: rand(1, MAP_HEIGHT-2),
                    hp: type==='BEAR'?200 : type==='WOLF'?80 : 30,
                    targetX: null, targetY: null,
                    state: 'WANDER', animFrame: rand(0,10), dir: 1
                });
            }
            return initCreatures;
        };

        const App = () => {
            const [sprites, setSprites] = useState(null);
            const [map, setMap] = useState([]);
            const [sims, setSims] = useState([]);
            const [creatures, setCreatures] = useState([]);
            const [farms, setFarms] = useState([]);
            const [particles, setParticles] = useState([]);
            const [tribe, setTribe] = useState({ wood: 0, stone: 0, food: 100, tech: 0 });
            const [weather, setWeather] = useState(WEATHER.SUNNY);
            const [weatherTimer, setWeatherTimer] = useState(1000);
            const [time, setTime] = useState(0);
            const [day, setDay] = useState(1);
            const [era, setEra] = useState(1);
            const [mana, setMana] = useState(999999);
            const [selectedId, setSelectedId] = useState(null);
            const [events, setEvents] = useState(['æ—äººä»°æœ›æ˜Ÿç©ºï¼Œæ•…äº‹é–‹å§‹äº†...']);
            const [isGameOver, setIsGameOver] = useState(false);
            const [isSoulSearching, setIsSoulSearching] = useState(false);
            const [isWritingSaga, setIsWritingSaga] = useState(false);

            const canvasRef = useRef(null);
            const tickRef = useRef(0);
            const requestRef = useRef();

            useEffect(() => {
                setSprites(createSprites());
                setMap(generateMapData());
                setSims(generateSimsData());
                setCreatures(generateCreaturesData());
            }, []);

            useEffect(() => {
                if (sims.length > 0 && sims.every(s => s.state === 'DEAD') && !isGameOver) {
                    setIsGameOver(true);
                }
            }, [sims, isGameOver]);

            const startNextEra = () => {
                setEra(e => e + 1); setDay(1); setTime(0); setMana(999999);
                setMap(generateMapData()); setSims(generateSimsData()); setCreatures(generateCreaturesData());
                setFarms([]); setTribe(prev => ({ ...prev, food: 100, wood: 0, stone: 0 }));
                setIsGameOver(false);
                setEvents(e => [`=== ç¬¬ ${era + 1} ç´€å…ƒé–‹å•Ÿ ===`, `æ–‡æ˜ç­‰ç´š Lv.${tribe.tech} ç¹¼æ‰¿å®Œç•¢`, ...e]);
            };

            const handleSoulSearch = async (sim) => {
                if (mana < 10) return;
                setIsSoulSearching(true); setMana(prev => prev - 10);
                const prompt = `You are an AI storytelling engine. Roleplay as a primitive tribesman (Sign:${sim.sign}, Trait:${sim.trait}, State:${sim.state}). Generate a short inner monologue (max 15 words) in Traditional Chinese.`;
                const thought = await callGemini(prompt, 'SOUL');
                if (thought) {
                    setSims(prev => prev.map(s => s.id === sim.id ? { ...s, thought: thought.trim() } : s));
                    setEvents(e => [`${sim.sign} çš„éˆé­‚ç™¼å‡ºäº†ä½èª...`, ...e]);
                } else {
                    setEvents(e => [`âŒ é€£çµç¥ç•Œå¤±æ•— (è«‹æª¢æŸ¥ API Key)`, ...e]);
                    setMana(prev => prev + 10);
                }
                setIsSoulSearching(false);
            };

            const handleTribeSaga = async () => {
                if (mana < 50) return;
                setIsWritingSaga(true); setMana(prev => prev - 50);
                const prompt = `Write a cryptic, mythic, single-sentence log entry (max 20 words) for a primitive tribe in Traditional Chinese. Context: Era ${era}, Tech Lv ${tribe.tech}, Pop ${sims.length}, Food ${Math.floor(tribe.food)}, Weather ${weather.name}.`;
                const saga = await callGemini(prompt, 'SAGA');
                if (saga) setEvents(e => [`ğŸ“œ å²è©©: ${saga.trim()}`, ...e]);
                else { setEvents(e => [`âŒ å²è©©æ’°å¯«å¤±æ•—`, ...e]); setMana(prev => prev + 50); }
                setIsWritingSaga(false);
            };

            const update = useCallback(() => {
                if (isGameOver) return;
                const isNight = time > DAY_TICKS * 0.6;
                
                // Weather Change
                if (tickRef.current % 10 === 0) {
                    setWeatherTimer(prev => prev - 1);
                    if (weatherTimer <= 0) {
                        const r = Math.random();
                        let nextW = r < 0.3 ? WEATHER.RAIN : (r < 0.4 ? WEATHER.SNOW : WEATHER.SUNNY);
                        setWeather(nextW); setWeatherTimer(rand(500, 1500));
                        setEvents(e => [`å¤©æ°£: ${nextW.name}`, ...e.slice(0,4)]);
                    }
                }

                // Particles
                if (weather.id !== 'SUNNY') {
                    setParticles(prev => {
                        const newP = [];
                        const pCount = weather.id === 'RAIN' ? 5 : 2;
                        for(let i=0; i<pCount; i++) newP.push({ x: rand(0, MAP_WIDTH * TILE_SIZE), y: -10, speed: weather.id === 'RAIN' ? rand(8,12) : rand(1,3), life: 100 });
                        return [...prev.map(p => ({ ...p, y: p.y + p.speed, x: weather.id === 'SNOW' ? p.x + Math.sin(p.y/10) : p.x, life: p.life-1 })).filter(p => p.y < MAP_HEIGHT * TILE_SIZE && p.life > 0), ...newP];
                    });
                } else setParticles([]);

                // Farms
                setFarms(prev => prev.map(f => f.stage < 100 ? { ...f, stage: Math.min(100, f.stage + 0.1 * (weather.id === 'RAIN' ? 2 : (weather.id === 'SNOW' ? 0 : 1))) } : f));

                // Creatures
                setCreatures(prev => prev.map(c => {
                    if (c.hp <= 0) return null;
                    let nextC = { ...c };
                    if (tickRef.current % 20 === 0 && Math.random() < 0.1) {
                        nextC.targetX = Math.max(0, Math.min(MAP_WIDTH-1, c.x + rand(-3, 3)));
                        nextC.targetY = Math.max(0, Math.min(MAP_HEIGHT-1, c.y + rand(-3, 3)));
                    }
                    if (nextC.targetX !== null) {
                        const speed = c.type === 'RABBIT' ? 0.08 : c.type === 'DEER' ? 0.06 : 0.04;
                        const dx = nextC.targetX - nextC.x; const dy = nextC.targetY - nextC.y;
                        if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) nextC.targetX = null;
                        else { nextC.x += Math.sign(dx) * speed; nextC.y += Math.sign(dy) * speed; nextC.dir = Math.sign(dx); nextC.animFrame++; }
                    }
                    return nextC;
                }).filter(Boolean));

                // Sims AI Logic
                setSims(prev => prev.map(s => {
                    if (s.state === 'DEAD') return s;
                    let nextS = { ...s };
                    
                    // Metabolism
                    if (tickRef.current % 10 === 0) {
                        let hLoss = 0.2; let eLoss = 0.1;
                        if (weather.id === 'SNOW' && !isInBase(nextS)) eLoss *= 2;
                        nextS.hunger -= hLoss; nextS.energy -= eLoss;
                        if (nextS.hunger <= 0) nextS.hp -= 0.5;
                        if (nextS.hp <= 0) { nextS.state = 'DEAD'; setEvents(e => [`${nextS.sign} å›æ­¸äº†å¤§åœ°...`, ...e]); return nextS; }
                    }

                    // FSM
                    const distToTarget = nextS.targetX !== null ? Math.sqrt((nextS.x - nextS.targetX)**2 + (nextS.y - nextS.targetY)**2) : 0;
                    const inBase = isInBase(nextS);

                    if (nextS.state === 'IDLE') {
                        // Survival Priorities
                        if (nextS.hunger < 50) {
                            if (tribe.food > 0 && inBase) { setTribe(t => ({...t, food: Math.max(0, t.food-10)})); nextS.hunger = 100; nextS.thought = 'åƒé£½äº†ï¼'; }
                            else {
                                const harvestable = farms.find(f => f.stage >= 100);
                                if (harvestable && tribe.tech >= 1) { nextS.state = 'FARMING'; nextS.targetX = harvestable.x; nextS.targetY = harvestable.y; }
                                else { nextS.state = 'GATHER'; nextS.targetX = rand(1, MAP_WIDTH-2); nextS.targetY = rand(1, MAP_HEIGHT-2); }
                            }
                        } 
                        else if (nextS.energy < 20 || (isNight && !inBase)) {
                            nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2;
                            if (inBase) { nextS.state = 'SLEEP'; nextS.thought = 'ä¼‘æ¯...'; }
                        }
                        else {
                            // Work / Creativity Logic
                            const needsWood = tribe.wood < 50;
                            const needsStone = tribe.stone < 20;
                            const roll = Math.random();

                            if (needsWood && roll < 0.6) {
                                if (nextS.tools.axe) {
                                    // Find Tree
                                    const tree = map.flat().find(t => (t.decoration === 'TREE_OAK' || t.decoration === 'TREE_PINE') && Math.random() < 0.2);
                                    if (tree) { nextS.state = 'CHOP'; nextS.targetX = tree.x; nextS.targetY = tree.y; nextS.thought = 'å»ä¼æœ¨ã€‚'; nextS.actionTimer = 60; }
                                } else if (tribe.wood >= 10 && tribe.stone >= 5) {
                                    // Craft Axe
                                    nextS.state = 'CRAFT_AXE'; nextS.thought = 'æˆ‘éœ€è¦å·¥å…·...'; nextS.actionTimer = 50;
                                } else {
                                    // Gather normally
                                    nextS.state = 'GATHER'; nextS.targetX = rand(1, MAP_WIDTH-2); nextS.targetY = rand(1, MAP_HEIGHT-2);
                                }
                            } else if (needsStone && roll > 0.6) {
                                if (nextS.tools.pick) {
                                    const rock = map.flat().find(t => t.decoration === 'ROCK' && Math.random() < 0.2);
                                    if (rock) { nextS.state = 'MINE'; nextS.targetX = rock.x; nextS.targetY = rock.y; nextS.thought = 'å»æ¡ç¤¦ã€‚'; nextS.actionTimer = 80; }
                                } else if (tribe.wood >= 10 && tribe.stone >= 5) {
                                    nextS.state = 'CRAFT_PICK'; nextS.thought = 'æˆ‘æƒ³åšæŠŠé¬å­ã€‚'; nextS.actionTimer = 50;
                                } else {
                                    // æ–°å¢ï¼šå¦‚æœç¼ºçŸ³é ­ä¸”æ²’å·¥å…·æ²’è³‡æºï¼Œå°±å…ˆå»æ¡é›†
                                    nextS.state = 'GATHER'; nextS.targetX = rand(1, MAP_WIDTH-2); nextS.targetY = rand(1, MAP_HEIGHT-2);
                                }
                            } else {
                                if (Math.random() < 0.05) { nextS.targetX = nextS.x + rand(-2, 2); nextS.targetY = nextS.y + rand(-2, 2); }
                            }
                        }
                    } 
                    else if (nextS.state === 'CRAFT_AXE' || nextS.state === 'CRAFT_PICK') {
                        nextS.actionTimer--;
                        if (nextS.actionTimer <= 0) {
                            if (nextS.state === 'CRAFT_AXE') { nextS.tools.axe = true; setTribe(t => ({...t, wood: t.wood-10, stone: t.stone-5})); setEvents(e => [`ğŸ’¡ ${nextS.sign} è£½ä½œäº†çŸ³æ–§`, ...e]); }
                            else { nextS.tools.pick = true; setTribe(t => ({...t, wood: t.wood-10, stone: t.stone-5})); setEvents(e => [`ğŸ’¡ ${nextS.sign} è£½ä½œäº†çŸ³é¬`, ...e]); }
                            nextS.state = 'IDLE'; nextS.thought = 'å®Œæˆå·¥å…·äº†ï¼';
                            // Add particle effect
                            setParticles(prev => [...prev, { x: nextS.x*TILE_SIZE, y: nextS.y*TILE_SIZE, speed: -1, life: 20, color: '#fff' }]);
                        }
                    }
                    else if (nextS.state === 'CHOP' || nextS.state === 'MINE') {
                        if (distToTarget < 0.5) {
                            nextS.actionTimer--;
                            if (nextS.actionTimer <= 0) {
                                // Resource collected
                                if (nextS.state === 'CHOP') { 
                                    setTribe(t => ({...t, wood: t.wood + 20})); 
                                    nextS.thought = 'æœ¨é ­åˆ°æ‰‹ã€‚';
                                    setMap(prevMap => {
                                        const newMap = [...prevMap];
                                        const row = [...newMap[Math.round(nextS.targetY)]];
                                        row[Math.round(nextS.targetX)] = { ...row[Math.round(nextS.targetX)], decoration: null };
                                        newMap[Math.round(nextS.targetY)] = row;
                                        return newMap;
                                    });
                                } else { 
                                    setTribe(t => ({...t, stone: t.stone + 10})); 
                                    nextS.thought = 'æ¡åˆ°çŸ³é ­äº†ã€‚'; 
                                    setMap(prevMap => {
                                        const newMap = [...prevMap];
                                        const row = [...newMap[Math.round(nextS.targetY)]];
                                        row[Math.round(nextS.targetX)] = { ...row[Math.round(nextS.targetX)], decoration: null };
                                        newMap[Math.round(nextS.targetY)] = row;
                                        return newMap;
                                    });
                                }
                                nextS.state = 'IDLE';
                            }
                        }
                    }
                    else if (nextS.state === 'GATHER') {
                        if (distToTarget < 0.5) { 
                            // å¢åŠ çŸ³é ­ç”¢å‡ºï¼Œè§£æ±ºå¡è³‡æºå•é¡Œ
                            nextS.inventory.food += 10; 
                            setTribe(t => ({...t, food: t.food + 5, wood: t.wood + 2, stone: t.stone + 1})); 
                            nextS.state = 'IDLE'; nextS.thought = 'æ’¿åˆ°ä¸€äº›æ±è¥¿ã€‚'; 
                        }
                    }
                    else if (nextS.state === 'SLEEP') {
                        nextS.energy += 0.5; if (nextS.energy >= 100) { nextS.state = 'IDLE'; nextS.thought = 'ç¡é£½äº†ã€‚'; }
                    }

                    // Movement
                    if (nextS.targetX !== null) {
                        const dx = nextS.targetX - nextS.x; const dy = nextS.targetY - nextS.y;
                        if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) nextS.targetX = null;
                        else {
                            const speed = (nextS.state==='SLEEP'||nextS.state.includes('CRAFT')?0:0.05) * (weather.id==='SNOW'?0.6:1);
                            nextS.x += Math.sign(dx) * speed; nextS.y += Math.sign(dy) * speed;
                            nextS.animFrame++; nextS.dir = Math.sign(dx);
                        }
                    }
                    return nextS;
                }));
            }, [time, weather, farms, tribe, isGameOver, map]); // Added map dependency

            const isInBase = (sim) => Math.sqrt((sim.x - MAP_WIDTH/2)**2 + (sim.y - MAP_HEIGHT/2)**2) < 5;

            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas || !sprites) return;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;

                ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save(); ctx.scale(SCALE, SCALE);

                // Draw Map
                map.forEach(row => row.forEach(tile => {
                    const px = tile.x * TILE_SIZE; const py = tile.y * TILE_SIZE;
                    ctx.drawImage(sprites.grass, px, py);
                    if (tile.type === 'WATER') {
                        ctx.fillStyle = PALETTE.WATER; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                        if (Math.sin(time/20 + tile.x) > 0.5) { ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(px + 4, py + 8, 8, 2); }
                    } else if (tile.type === 'BASE') ctx.drawImage(sprites.dirt, px, py);
                }));

                // Draw Farms
                farms.forEach(f => {
                    const px = f.x * TILE_SIZE; const py = f.y * TILE_SIZE;
                    ctx.drawImage(sprites.dirt, px, py);
                    if (f.stage > 80) ctx.drawImage(sprites.wheat_2, px, py);
                    else if (f.stage > 20) ctx.drawImage(sprites.wheat_1, px, py);
                    else { ctx.fillStyle = '#8d6e63'; ctx.fillRect(px+10, py+10, 2, 2); ctx.fillRect(px+20, py+16, 2, 2); }
                });

                const objects = [];
                map.forEach(row => row.forEach(tile => { if (tile.decoration) objects.push({ y: tile.y, type: 'DECO', subtype: tile.decoration, x: tile.x }); }));
                sims.forEach(sim => objects.push({ y: sim.y, type: 'SIM', data: sim }));
                creatures.forEach(c => objects.push({ y: c.y, type: 'CREATURE', data: c }));
                objects.sort((a, b) => a.y - b.y);

                objects.forEach(obj => {
                    const px = obj.x * TILE_SIZE; const py = obj.y * TILE_SIZE;
                    if (obj.type === 'DECO') {
                        if (obj.subtype === 'TREE_OAK') ctx.drawImage(sprites.tree_oak, px, py - TILE_SIZE);
                        else if (obj.subtype === 'TREE_PINE') ctx.drawImage(sprites.tree_pine, px, py - TILE_SIZE);
                        else if (obj.subtype === 'ROCK') ctx.drawImage(sprites.rock, px, py);
                        else if (obj.subtype === 'BUSH') ctx.drawImage(sprites.bush, px, py);
                        else if (obj.subtype === 'FLOWER') ctx.drawImage(sprites.flower, px, py);
                        else if (obj.subtype === 'MUSHROOM') ctx.drawImage(sprites.mushroom, px, py);
                    } else if (obj.type === 'SIM') drawSim(ctx, obj.data);
                    else if (obj.type === 'CREATURE') drawCreature(ctx, obj.data);
                });

                // Selection Ring
                if (selectedId) {
                    const target = [...sims, ...creatures].find(i => i.id === selectedId);
                    if (target) {
                        const px = target.x * TILE_SIZE; const py = target.y * TILE_SIZE;
                        ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1.5; ctx.setLineDash([4, 2]);
                        ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
                        ctx.setLineDash([]);
                    }
                }

                // Fire
                if (tribe.tech >= 1) {
                    const bx = (MAP_WIDTH/2) * TILE_SIZE; const by = (MAP_HEIGHT/2) * TILE_SIZE;
                    const fireSize = weather.id === 'RAIN' ? 2 : (Math.sin(time/5)*2 + 6);
                    if (weather.id !== 'RAIN' || Math.random() > 0.5) {
                        ctx.fillStyle = '#ff5722'; ctx.beginPath(); ctx.arc(bx + 16, by + 16, fireSize, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#ffca28'; ctx.beginPath(); ctx.arc(bx + 16, by + 16, fireSize/2, 0, Math.PI*2); ctx.fill();
                    }
                }

                // Particles
                particles.forEach(p => {
                    ctx.fillStyle = p.color || (weather.id === 'RAIN' ? '#4fc3f7' : '#ffffff');
                    const w = weather.id === 'RAIN' ? 1 : 2; const h = weather.id === 'RAIN' ? 4 : 2;
                    ctx.fillRect(p.x / SCALE, p.y / SCALE, w, h);
                });
                
                // Night Overlay
                if (time > DAY_TICKS * 0.6) { ctx.fillStyle = 'rgba(10, 10, 30, 0.6)'; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); }
                ctx.fillStyle = weather.color; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE);

                ctx.restore();
            }, [map, sprites, sims, creatures, weather, particles, farms, time, selectedId, tribe]);

            const drawSim = (ctx, s) => {
                if (s.state === 'DEAD') { ctx.fillStyle = '#555'; ctx.fillRect(s.x*TILE_SIZE+14, s.y*TILE_SIZE+10, 4, 12); ctx.fillRect(s.x*TILE_SIZE+10, s.y*TILE_SIZE+14, 12, 4); return; }
                const px = Math.floor(s.x * TILE_SIZE); const py = Math.floor(s.y * TILE_SIZE);
                const bounce = (s.state !== 'IDLE' && s.state !== 'SLEEP') ? Math.sin(s.animFrame) * 2 : 0;
                const matrix = s.gender === 'M' ? SPRITE_MATRICES.CHAR_M : SPRITE_MATRICES.CHAR_F;
                const colorMap = { 'H': s.hair, 'S': PALETTE.SKIN, 's': PALETTE.SKIN_SHADOW, 'C': s.color, 'K': PALETTE.OUTLINE };
                renderMatrix(ctx, matrix, colorMap, px + 4, py + 4 + bounce);
                
                // Tools Rendering
                if (s.tools.axe || s.state === 'CHOP' || s.state === 'CRAFT_AXE') {
                    ctx.fillStyle = PALETTE.TOOL_AXE; ctx.fillRect(px+20, py+10+bounce, 2, 8); // Handle
                    ctx.fillStyle = PALETTE.TOOL_HEAD; ctx.fillRect(px+18, py+10+bounce, 6, 3); // Head
                } else if (s.tools.pick || s.state === 'MINE' || s.state === 'CRAFT_PICK') {
                    ctx.fillStyle = PALETTE.TOOL_AXE; ctx.fillRect(px+20, py+10+bounce, 2, 8);
                    ctx.fillStyle = PALETTE.TOOL_HEAD; ctx.fillRect(px+17, py+10+bounce, 8, 2);
                }

                if (s.state === 'SLEEP') { ctx.font = '10px monospace'; ctx.fillStyle = '#fff'; ctx.fillText('zZ', px+20, py); }
                if (s.state.includes('CRAFT')) { ctx.font = '10px monospace'; ctx.fillStyle = '#ffff00'; ctx.fillText('ğŸ”¨', px, py); }
            };

            const drawCreature = (ctx, c) => {
                const px = Math.floor(c.x * TILE_SIZE); const py = Math.floor(c.y * TILE_SIZE);
                const bounce = Math.sin(c.animFrame) * 2;
                let matrix, colorMap, ox=0, oy=0;
                if (c.type === 'RABBIT') { matrix = SPRITE_MATRICES.RABBIT; colorMap = {'W': PALETTE.FUR_RABBIT, 'K': PALETTE.OUTLINE}; ox=4; oy=10; }
                else if (c.type === 'WOLF') { matrix = SPRITE_MATRICES.WOLF; colorMap = {'G': PALETTE.FUR_WOLF, 'K': PALETTE.OUTLINE}; ox=2; oy=6; }
                else if (c.type === 'BEAR') { matrix = SPRITE_MATRICES.BEAR; colorMap = {'B': PALETTE.FUR_BEAR, 'K': PALETTE.OUTLINE}; ox=-6; oy=-6; }
                else if (c.type === 'DEER') { matrix = SPRITE_MATRICES.DEER; colorMap = {'B': PALETTE.FUR_DEER, 'K': PALETTE.OUTLINE}; ox=2; oy=-2; }
                ctx.save();
                if (c.dir < 0) { ctx.translate(px + TILE_SIZE, 0); ctx.scale(-1, 1); ctx.translate(-px, 0); }
                renderMatrix(ctx, matrix, colorMap, px + ox, py + oy + bounce);
                ctx.restore();
            };

            useEffect(() => {
                const loop = () => {
                    tickRef.current++;
                    if (tickRef.current % 5 === 0) {
                        setTime(t => (t + 1) % DAY_TICKS);
                        if (time === 0) setDay(d => d+1);
                        update();
                    }
                    draw();
                    requestRef.current = requestAnimationFrame(loop);
                };
                requestRef.current = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(requestRef.current);
            }, [draw, update]);

            const handleCanvasClick = useCallback((e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = (e.clientX - rect.left) / SCALE / TILE_SIZE;
                const y = (e.clientY - rect.top) / SCALE / TILE_SIZE;
                
                const allObjs = [...sims, ...creatures];
                let closest = null; let minDist = 2.5;

                allObjs.forEach(obj => {
                    const dist = Math.sqrt((obj.x + 0.5 - x)**2 + (obj.y + 0.5 - y)**2);
                    if (dist < minDist) { closest = obj; minDist = dist; }
                });
                setSelectedId(closest ? closest.id : null);
            }, [sims, creatures]);

            const castSpell = (type) => {
                if (mana < 20) return;
                if (['FOOD', 'HEAL', 'BUFF'].includes(type) && selectedId) {
                    setSims(prev => prev.map(s => {
                        if (s.id !== selectedId) return s;
                        if (type === 'FOOD') { setMana(m => m - 30); setEvents(e => [`è³œäºˆ ${s.sign} é£Ÿç‰©`, ...e]); return { ...s, hunger: 100 }; }
                        else if (type === 'HEAL') { setMana(m => m - 30); setEvents(e => [`${s.sign} å‚·å£ç™’åˆ`, ...e]); return { ...s, hp: 100 }; }
                        else if (type === 'BUFF') { setMana(m => m - 30); setEvents(e => [`${s.sign} ç²å¾—ç¥åŠ›`, ...e]); return { ...s, energy: 100, thought: 'ç¥èˆ‡æˆ‘åŒåœ¨ï¼' }; }
                        return s;
                    }));
                    return;
                }
                setMana(m => m - 20);
                if (type === 'SUN') { setWeather(WEATHER.SUNNY); setEvents(e => ['ç¥è¹Ÿï¼šç¥ˆæ™´', ...e]); }
                else if (type === 'RAIN') { setWeather(WEATHER.RAIN); setEvents(e => ['ç¥è¹Ÿï¼šç¥ˆé›¨', ...e]); }
                else if (type === 'TECH') { setTribe(t => ({...t, tech: t.tech + 1})); setEvents(e => ['ç¥è¹Ÿï¼šæ™ºæ…§å•Ÿè’™', ...e]); }
            };

            const selectedObj = [...sims, ...creatures].find(s => s.id === selectedId);
            const aliveCount = sims.filter(s => s.state !== 'DEAD').length;

            return (
                <div className="flex flex-col h-[100dvh] bg-[#1a1c2c] text-[#c2c3c7]" style={{ fontFamily: PIXEL_FONT }}>
                    {/* Header: æ‰‹æ©Ÿç‰ˆç²¾ç°¡è³‡è¨Šï¼Œé›»è…¦ç‰ˆå®Œæ•´é¡¯ç¤º */}
                    <div className="bg-[#292b3c] p-2 md:p-3 border-b-4 border-[#121215] flex justify-between items-center shadow-lg shrink-0 z-20 relative gap-2">
                        <div className="flex gap-2 md:gap-4 items-center">
                            <div className="text-[#ffcd75] font-bold flex items-center gap-1 md:gap-2 text-sm md:text-base"><Icons.Sparkles size={14} className="md:w-4 md:h-4"/> {mana}</div>
                            <div className="flex items-center gap-1 md:gap-2 bg-[#1a1c2c] px-2 py-1 rounded border border-[#5d4037] text-xs md:text-sm">
                                {weather.id === 'SUNNY' ? <Icons.Sun size={14} className="text-yellow-400"/> : weather.id === 'RAIN' ? <Icons.CloudRain size={14} className="text-blue-400"/> : <Icons.Snowflake size={14} className="text-white"/>}
                                <span>{weather.name}</span>
                            </div>
                            <div className="hidden md:block text-xs text-gray-400">ç¬¬ {era} ç´€å…ƒ Day {day}</div>
                        </div>
                        <div className="flex gap-2 md:gap-3 text-xs font-bold text-[#8b9bb4] items-center">
                            <span className="flex items-center gap-1"><Icons.Users size={12}/> {aliveCount}</span>
                            <span>ğŸ {Math.floor(tribe.food)}</span>
                            <span className="hidden sm:inline">ğŸªµ {tribe.wood}</span>
                            <span className="hidden sm:inline">ğŸ§± {tribe.stone}</span>
                            <span>ğŸ”¨ Lv.{tribe.tech}</span>
                        </div>
                    </div>

                    {/* Main Layout: Flex-col on Mobile, Flex-row on Desktop */}
                    <div className="flex-1 flex flex-col md:flex-row overflow-hidden relative">
                        {isGameOver && (
                            <div className="absolute inset-0 z-50 bg-black/90 flex flex-col items-center justify-center animate-in fade-in zoom-in duration-500">
                                <Icons.Skull size={64} className="text-red-600 mb-4 animate-bounce"/>
                                <h1 className="text-4xl text-red-500 font-bold mb-2">æ–‡æ˜æ»…äº¡</h1>
                                <button onClick={startNextEra} className="bg-red-900 hover:bg-red-800 text-white px-8 py-4 rounded border-2 border-red-500 flex items-center gap-3 text-xl mt-8">
                                    <Icons.RefreshCw size={24}/> é–‹å•Ÿç¬¬ {era+1} ç´€å…ƒ
                                </button>
                            </div>
                        )}

                        {/* ä¿®æ­£ï¼šå¢åŠ ä¸€å€‹ relative çš„å®¹å™¨åŒ…è£¹ åœ°åœ– èˆ‡ æ—¥èªŒ */}
                        <div className="relative flex-1 bg-black overflow-hidden flex">
                            {/* Canvas Area: Scrollable for Panning - æ—¥èªŒå·²ç§»å‡ºæ­¤å€å¡Š */}
                            <div className="w-full h-full overflow-auto flex items-center justify-center p-4 touch-pan-x touch-pan-y">
                                <canvas ref={canvasRef} width={MAP_WIDTH * TILE_SIZE * SCALE} height={MAP_HEIGHT * TILE_SIZE * SCALE} onClick={handleCanvasClick} className="border-4 border-[#3e2723] shadow-2xl cursor-crosshair" style={{ imageRendering: 'pixelated' }} />
                            </div>

                            {/* Fixed Logs UI: ç§»åˆ°é€™è£¡ï¼Œä½œç‚º Scrollable Area çš„å…„å¼Ÿå…ƒç´ ï¼Œçµ•å°å®šä½ */}
                            <div className="absolute bottom-4 left-4 md:bottom-6 md:left-6 flex flex-col-reverse gap-1 pointer-events-none opacity-90 items-start max-w-[70%] md:max-w-none z-10">
                                {events.slice(0, 5).map((ev, i) => (
                                    <div key={i} className="bg-black/60 text-[#fff] px-2 py-1 md:px-3 md:py-1.5 text-[10px] md:text-xs rounded border-l-2 border-[#ffcd75] shadow-sm backdrop-blur-sm animate-in fade-in slide-in-from-left-2 duration-300">
                                        {ev}
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Control Panel: Bottom Sheet (Mobile) / Sidebar (Desktop) */}
                        <div className="w-full h-[35vh] md:w-72 md:h-full bg-[#292b3c] border-t-4 md:border-t-0 md:border-l-4 border-[#121215] p-2 md:p-4 pb-8 md:pb-4 flex flex-col gap-2 md:gap-4 shrink-0 z-10 relative overflow-y-auto shadow-2xl">
                            
                            {/* Miracles Section */}
                            <div className="bg-[#1a1c2c] p-2 md:p-3 rounded border border-[#3e2723]">
                                <h3 className="text-[#ffcd75] text-xs md:text-sm mb-2 font-bold border-b border-[#3e2723] pb-1">ç¥è¹Ÿ</h3>
                                <div className="grid grid-cols-4 md:grid-cols-2 gap-2">
                                    <button onClick={() => castSpell('SUN')} className="bg-[#3e2723] hover:bg-[#5d4037] p-2 rounded flex flex-col items-center justify-center gap-1 transition-colors aspect-square md:aspect-auto"><Icons.Sun size={18} className="text-yellow-400"/><span className="text-[10px]">ç¥ˆæ™´</span></button>
                                    <button onClick={() => castSpell('RAIN')} className="bg-[#3e2723] hover:bg-[#5d4037] p-2 rounded flex flex-col items-center justify-center gap-1 transition-colors aspect-square md:aspect-auto"><Icons.CloudRain size={18} className="text-blue-400"/><span className="text-[10px]">ç¥ˆé›¨</span></button>
                                    <button onClick={() => castSpell('TECH')} className="bg-[#3e2723] hover:bg-[#5d4037] p-2 rounded flex flex-col items-center justify-center gap-1 transition-colors aspect-square md:aspect-auto"><Icons.Brain size={18} className="text-purple-400"/><span className="text-[10px]">æ™ºæ…§</span></button>
                                    <button onClick={handleTribeSaga} disabled={isWritingSaga || mana < 50} className={`bg-indigo-900 hover:bg-indigo-800 p-2 rounded flex flex-col items-center justify-center gap-1 transition-colors border border-indigo-500 aspect-square md:aspect-auto md:col-span-2 ${isWritingSaga ? 'opacity-50' : ''}`}><Icons.ScrollText size={18} className="text-indigo-300"/><span className="text-[10px] text-indigo-200">å²è©©</span></button>
                                </div>
                            </div>

                            {/* Inspector Section */}
                            <div className="flex-1 bg-[#1a1c2c] p-2 md:p-3 rounded border border-[#3e2723] relative flex flex-col min-h-[140px] md:min-h-[300px]">
                                <div className="flex justify-between items-center border-b border-[#3e2723] mb-2 pb-1"><h3 className="text-[#8b9bb4] text-xs md:text-sm font-bold">è§€å¯Ÿ</h3>{selectedObj && <button onClick={() => setSelectedId(null)} className="text-gray-500 hover:text-white"><Icons.X size={14}/></button>}</div>
                                {selectedObj ? (
                                    <div className="flex flex-col gap-1 md:gap-2 flex-1 animate-fade-in overflow-y-auto">
                                        {selectedObj.sign ? ( 
                                            <>
                                                <div className="flex items-center gap-2 md:gap-3">
                                                    <div className="w-8 h-8 md:w-10 md:h-10 border border-gray-600 bg-black relative overflow-hidden shrink-0"><div className="absolute top-2 left-2 w-6 h-6" style={{backgroundColor: selectedObj.hair, borderRadius: '50% 50% 0 0'}}></div><div className="absolute top-4 left-1 w-8 h-8" style={{backgroundColor: selectedObj.color, borderRadius: '50% 50% 0 0'}}></div></div>
                                                    <div><div className="font-bold text-[#ffccaa] text-sm md:text-base">{selectedObj.sign}åº§</div><div className="text-[10px] text-gray-500">{selectedObj.state}</div></div>
                                                </div>
                                                
                                                <div className="space-y-1 mt-1 text-xs">
                                                    <div className="flex justify-between"><span>HP</span><span>{Math.floor(selectedObj.hp)}</span></div>
                                                    <div className="h-1 bg-gray-700"><div className="h-full bg-red-500" style={{width: `${Math.max(0, selectedObj.hp)}%`}}></div></div>
                                                    
                                                    <div className="flex justify-between"><span>é£½é£Ÿ</span><span>{Math.floor(selectedObj.hunger)}</span></div>
                                                    <div className="h-1 bg-gray-700"><div className="h-full bg-orange-500" style={{width: `${Math.max(0, selectedObj.hunger)}%`}}></div></div>

                                                    <div className="flex justify-between text-gray-400 mt-1 border-t border-gray-800 pt-1">
                                                        <span>å·¥å…·</span>
                                                        <span>{[selectedObj.tools.axe?'æ–§':'', selectedObj.tools.pick?'é¬':''].filter(Boolean).join(',') || 'ç„¡'}</span>
                                                    </div>
                                                </div>

                                                <div className="mt-1 bg-[#111] p-1.5 text-[10px] md:text-xs text-[#a5d6a7] italic border border-gray-800 flex flex-col gap-1"><span>"{selectedObj.thought}"</span><button onClick={() => handleSoulSearch(selectedObj)} disabled={isSoulSearching || mana < 10} className="self-end flex items-center gap-1 bg-gray-800 hover:bg-gray-700 px-2 py-1 rounded text-purple-300 border border-purple-900"><Icons.MessageCircle size={10}/> å‚¾è½ (10)</button></div>
                                                
                                                <div className="mt-auto grid grid-cols-3 gap-1 pt-2 border-t border-[#3e2723]">
                                                    <button onClick={() => castSpell('FOOD')} className="bg-[#3e2723] hover:bg-[#5d4037] p-1.5 rounded flex flex-col items-center gap-0.5"><Icons.Utensils size={14} className="text-orange-400"/><span className="text-[10px]">è³œé£Ÿ</span></button>
                                                    <button onClick={() => castSpell('HEAL')} className="bg-[#3e2723] hover:bg-[#5d4037] p-1.5 rounded flex flex-col items-center gap-0.5"><Icons.Heart size={14} className="text-red-400"/><span className="text-[10px]">æ²»ç™’</span></button>
                                                    <button onClick={() => castSpell('BUFF')} className="bg-[#3e2723] hover:bg-[#5d4037] p-1.5 rounded flex flex-col items-center gap-0.5"><Icons.Shield size={14} className="text-blue-400"/><span className="text-[10px]">è³œç¦</span></button>
                                                </div>
                                            </>
                                        ) : (<><div className="font-bold text-[#ffccaa] text-sm md:text-lg">{selectedObj.type}</div><div className="text-[10px] md:text-xs text-gray-500">é‡ç”Ÿç”Ÿç‰©</div></>)}
                                    </div>
                                ) : (<div className="h-full flex flex-col items-center justify-center text-gray-600 text-xs gap-2 opacity-50"><Icons.HelpCircle size={24}/><div className="text-center">é¸æ“‡ç›®æ¨™</div></div>)}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>