<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÊòüËæ∞ÈÉ®ËêΩ: ÊñáÊòéÂ¥õËµ∑ (Tribe of Stars)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; user-select: none; }
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #4a4a4a; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }
        button { touch-action: manipulation; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .log-item { animation: fadeIn 0.3s ease-out forwards; }
        .build-cursor { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewport="0 0 24 24" fill="none" stroke="yellow" stroke-width="2"><rect x="2" y="2" width="20" height="20" /></svg>') 12 12, crosshair; }
        @keyframes floatUp { 
            0% { opacity: 0; transform: translateY(5px) scale(0.8); } 
            10% { opacity: 1; transform: translateY(0) scale(1); } 
            90% { opacity: 1; transform: translateY(-20px) scale(1); } 
            100% { opacity: 0; transform: translateY(-30px) scale(0.9); } 
        }
        .thought-bubble { animation: floatUp 4s ease-in-out forwards; pointer-events: none; text-shadow: 1px 1px 0 #000; white-space: nowrap; z-index: 50; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useLayoutEffect } = React;
        const { createRoot } = ReactDOM;

        // --- Icon Components ---
        const Icon = ({ char, className, size }) => (
            <span className={className} style={{ fontSize: size || 16, lineHeight: 1, display: 'inline-block' }}>{char}</span>
        );

        const Icons = {
            Sparkles: (p) => <Icon char="‚ú®" {...p}/>, Heart: (p) => <Icon char="‚ù§Ô∏è" {...p}/>, Utensils: (p) => <Icon char="üçñ" {...p}/>,
            Shield: (p) => <Icon char="üõ°Ô∏è" {...p}/>, CloudRain: (p) => <Icon char="üåßÔ∏è" {...p}/>, Snowflake: (p) => <Icon char="‚ùÑÔ∏è" {...p}/>,
            Sun: (p) => <Icon char="‚òÄÔ∏è" {...p}/>, Cloud: (p) => <Icon char="‚òÅÔ∏è" {...p}/>, Flame: (p) => <Icon char="üî•" {...p}/>,
            Mountain: (p) => <Icon char="‚õ∞Ô∏è" {...p}/>, Skull: (p) => <Icon char="üíÄ" {...p}/>, RefreshCw: (p) => <Icon char="üîÑ" {...p}/>,
            X: (p) => <Icon char="‚ùå" {...p}/>, Brain: (p) => <Icon char="üß†" {...p}/>, ScrollText: (p) => <Icon char="üìú" {...p}/>,
            MessageCircle: (p) => <Icon char="üí¨" {...p}/>, HelpCircle: (p) => <Icon char="‚ùì" {...p}/>, Users: (p) => <Icon char="üë•" {...p}/>,
            Hammer: (p) => <Icon char="üî®" {...p}/>, Zap: (p) => <Icon char="‚ö°" {...p}/>, Home: (p) => <Icon char="üè†" {...p}/>,
            Biohazard: (p) => <Icon char="‚ò£Ô∏è" {...p}/>, Baby: (p) => <Icon char="üë∂" {...p}/>, Sword: (p) => <Icon char="‚öîÔ∏è" {...p}/>,
            Crown: (p) => <Icon char="üëë" {...p}/>, Box: (p) => <Icon char="üì¶" {...p}/>, ChevronUp: (p) => <Icon char="‚ñ≤" {...p}/>,
            ChevronDown: (p) => <Icon char="‚ñº" {...p}/>, Target: (p) => <Icon char="üéØ" {...p}/>, Save: (p) => <Icon char="üíæ" {...p}/>,
            Key: (p) => <Icon char="üîë" {...p}/>
        };

        // --- Constants & Config ---
        const PIXEL_FONT = "'Courier New', Courier, monospace";
        const TILE_SIZE = 32;
        const SCALE = 1.5; 
        const MAP_WIDTH = 40; 
        const MAP_HEIGHT = 40;
        const DAY_TICKS = 800; 
        const MAX_POPULATION = 50;
        const AI_COOLDOWN_TICKS = 150; 
        
        const TOOL_COSTS = {
            AXE: 10,  
            PICK: 15, 
            SPEAR: 20 
        };

        const TECH_TREE = [
            { id: 'STONE_TOOLS', name: 'Áü≥Âô®ÊâìÁ£®', desc: 'Ëß£ÈéñË£Ω‰Ωú [ÊñßÈ†≠] Ëàá [Èé¨Â≠ê]', icon: 'ü™®' },
            { id: 'FIRE', name: 'ÁÅ´Á®Æ‰øùÂ≠ò', desc: 'Ëß£ÈéñÂª∫ÈÄ† [ÁáüÁÅ´] (Â§úÈñìÊ≤ªÁôÇ)', icon: 'üî•' },
            { id: 'ARCH', name: 'Âü∫Á§éÂª∫ÁØâ', desc: 'Ëß£ÈéñÂª∫ÈÄ† [Êú®ÁâÜ] (Èò≤Á¶¶)', icon: 'ü™µ' },
            { id: 'HUNTING', name: 'Áã©ÁçµÊäÄË°ì', desc: 'Ëß£ÈéñË£Ω‰Ωú [Èï∑Áüõ] (Êà∞È¨•)', icon: 'üó°Ô∏è' },
            { id: 'GATHERING', name: 'Êé°ÈõÜËæ®Ë≠ò', desc: 'ÁÅåÊú®Êé°ÈõÜÈ£üÁâ© +2', icon: 'ü´ê' },
            { id: 'BRONZE', name: 'ÈùíÈäÖÂÜ∂ÁÖâ', desc: 'Ëß£ÈéñÂª∫ÈÄ† [ÁÆ≠Â°î]', icon: 'üóº' },
            { id: 'MEDICINE', name: 'ËçâËó•Â≠∏', desc: 'ÁáüÁÅ´Ê≤ªÁôÇÊïàÊûú 3ÂÄç', icon: 'üåø' },
            { id: 'IRON', name: 'ÈãºÈêµÈçõÈÄ†', desc: '‰ºêÊú®ËàáÊé°Á§¶ÊïàÁéáÂ§ßÂπÖÊèêÂçá', icon: '‚öíÔ∏è' },
            { id: 'STRATEGY', name: 'Ëªç‰∫ãÈô£Ê≥ï', desc: 'Êóè‰∫∫Â∞çÊäóÈáéÁç∏ÊôÇÊõ¥ÂãáÊï¢', icon: 'üõ°Ô∏è' },
            { id: 'FARMING', name: 'Â§ßÂûãÁÅåÊ∫â', desc: 'Êé°ÈõÜÈ£üÁâ©ÊïàÁéáÂÜçÊèêÂçá', icon: 'üåæ' }
        ];

        const CIV_STAGES = [
            { id: 0, name: 'Á©¥Â±ÖÊôÇ‰ª£', icon: 'üï≥Ô∏è', minTech: 0, sprite: 'cave', desc: 'ÂéüÂßãÁöÑÂ§©ÁÑ∂Â≤©Ê¥ûÔºåËÉΩÂãâÂº∑ÈÅÆÈ¢®ÈÅøÈõ®„ÄÇ', stats: { def: 10, heal: 1, cap: 200 } },
            { id: 1, name: 'ÈÉ®ËêΩÊôÇ‰ª£', icon: '‚õ∫', minTech: 3, sprite: 'hut', desc: 'Áî®Êú®ÊùêËàáÁç∏ÁöÆÊê≠Âª∫ÁöÑËÅöËêΩÔºåË®≠ÊúâÁ∞°ÊòìÂÄâÂ∫´„ÄÇ', stats: { def: 30, heal: 2, cap: 500 } }, 
            { id: 2, name: 'ÂüéÈÇ¶ÊôÇ‰ª£', icon: 'üèòÔ∏è', minTech: 6, sprite: 'house', desc: 'Áü≥Êú®Ê∑∑ÂêàÁöÑÂ†ÖÂõ∫Âª∫ÁØâÔºåÊñáÊòéÁöÑÁÅ´Á®ÆÂú®Ê≠§ÁáÉÁáí„ÄÇ', stats: { def: 80, heal: 4, cap: 2000 } },
            { id: 3, name: 'Â∏ùÂúãÊôÇ‰ª£', icon: 'üè∞', minTech: 9, sprite: 'castle', desc: 'Â∑çÂ≥®ÁöÑÁü≥Á†åÂüéÂ†°ÔºåË±°ÂæµËëóËá≥È´òÁÑ°‰∏äÁöÑÊ¨äÂäõ„ÄÇ', stats: { def: 200, heal: 8, cap: 10000 } }
        ];

        const CREATURE_STATS = {
            RABBIT: { hp: 30, type: 'PASSIVE', dmg: 0, name: 'ÂÖîÂ≠ê', sprite: 'rabbit' },
            DEER: { hp: 50, type: 'PASSIVE', dmg: 0, name: 'Èπø', sprite: 'deer' },
            SHEEP: { hp: 40, type: 'PASSIVE', dmg: 0, name: 'Á∂øÁæä', sprite: 'sheep' },
            COW: { hp: 120, type: 'PASSIVE', dmg: 0, name: '‰π≥Áâõ', sprite: 'cow' },
            FOX: { hp: 60, type: 'HOSTILE', dmg: 5, name: 'ÁãêÁã∏', sprite: 'fox' },
            BOAR: { hp: 100, type: 'HOSTILE', dmg: 8, name: 'ÈáéË±¨', sprite: 'boar' },
            WOLF: { hp: 80, type: 'HOSTILE', dmg: 10, name: 'ÊÉ°Áãº', sprite: 'wolf' },
            BEAR: { hp: 200, type: 'HOSTILE', dmg: 20, name: 'Â∑®ÁÜä', sprite: 'bear' },
            DINOSAUR: { hp: 800, type: 'HOSTILE', dmg: 40, name: 'Êö¥Èæç', sprite: 'dinosaur' }
        };

        const BUILDINGS = {
            BONFIRE: { id: 'BONFIRE', name: 'ÁáüÁÅ´', cost: { wood: 20, stone: 0 }, desc: 'Â§úÈñìÊ≤ªÁôÇÂë®ÂúçÊóè‰∫∫', sprite: 'bonfire', hp: 50, reqTech: 'FIRE' },
            TOWER: { id: 'TOWER', name: 'ÁÆ≠Â°î', cost: { wood: 50, stone: 20 }, desc: 'Ëá™ÂãïÊîªÊìäÊïµ‰∫∫', sprite: 'tower', hp: 200, range: 6, dmg: 10, reqTech: 'BRONZE' },
            WALL: { id: 'WALL', name: 'Êú®ÁâÜ', cost: { wood: 10, stone: 0 }, desc: 'ÈòªÊìãÊïµ‰∫∫ÂâçÈÄ≤', sprite: 'wall', hp: 300, reqTech: 'ARCH' }
        };

        const PALETTE = {
            OUTLINE: '#1a1c2c', SKIN: '#ffccaa', SKIN_SHADOW: '#d48e7e',
            GRASS_BG: '#388e3c', GRASS_L: '#4caf50', GRASS_D: '#1b5e20',
            DIRT: '#5d4037', WATER: '#4a69bd',
            SAND: '#e6c98e', MOUNTAIN_BG: '#5d4037', MOUNTAIN_FG: '#8d6e63',
            CAVE_DARK: '#1a1a1a',
            WHEAT_1: '#a5d6a7', WHEAT_2: '#e6ee9c', WHEAT_3: '#fbc02d',
            STONE_L: '#b0bec5', STONE_M: '#78909c', STONE_D: '#546e7a',
            WOOD_L: '#8d6e63', WOOD_D: '#3e2723',
            LEAF_L: '#66bb6a', LEAF_D: '#2e7d32', LEAF_PINE: '#1b5e20',
            FLOWER_R: '#e57373', FLOWER_Y: '#fff176', MUSHROOM: '#f44336',
            FUR_WOLF: '#90a4ae', FUR_BEAR: '#4e342e', FUR_DEER: '#a1887f', FUR_RABBIT: '#fafafa',
            FUR_FOX: '#e67e22', FUR_SHEEP: '#f5f6fa', SKIN_PIG: '#d48e7e',
            DINO_GREEN: '#558b2f', DINO_EYE: '#ffeb3b', 
            WHITE: '#ffffff', GOLD: '#ffd700', RED: '#ff0000',
            TOOL_AXE: '#8d6e63', TOOL_HEAD: '#90a4ae', TOOL_SPEAR: '#d7ccc8', TOOL_BOW: '#8d6e63',
            SICK_SKIN: '#88aa88',
            HUT_ROOF: '#e6c98e', HOUSE_ROOF: '#a1887f', CASTLE_WALL: '#90a4ae',
            BONE_WHITE: '#e0e0e0', FIRE_1: '#ffeb3b', FIRE_2: '#ff5722',
            BERRY: '#e91e63'
        };

        const DISASTERS = {
            NONE: { name: 'ÁÑ°', color: null },
            METEOR: { name: 'üî• ÊòüÊÆû', color: 'rgba(255, 50, 0, 0.3)' },
            PLAGUE: { name: 'ü¶† ÁòüÁñ´', color: 'rgba(20, 100, 20, 0.4)' },
            DROUGHT: { name: '‚òÄ ‰πæÊó±', color: 'rgba(255, 140, 0, 0.4)' },
            FLOOD: { name: 'üåä Ê¥™Ê∞¥', color: 'rgba(0, 60, 200, 0.5)' },
            LOCUSTS: { name: 'ü¶ó ËùóÁÅΩ', color: 'rgba(100, 80, 20, 0.4)' },
            BLIZZARD: { name: '‚ùÑ ÂáúÂÜ¨', color: 'rgba(200, 240, 255, 0.6)' },
            QUAKE: { name: 'üåã Âú∞Èúá', color: 'rgba(80, 40, 40, 0.4)' },
            BEASTS: { name: 'üê∫ Áç∏ÊΩÆ', color: 'rgba(100, 0, 0, 0.3)' },
            DARKNESS: { name: 'üåë Ê∞∏Â§ú', color: 'rgba(0, 0, 0, 0.9)' },
            THUNDER: { name: '‚ö° Èõ∑ÁΩ∞', color: 'rgba(80, 80, 120, 0.4)' }
        };

        const WEATHER = {
            SUNNY: { id: 'SUNNY', name: 'Êô¥Â§©', color: 'rgba(255,255,0,0.1)' },
            RAIN: { id: 'RAIN', name: 'Èõ®Â§©', color: 'rgba(0,0,50,0.3)' },
            SNOW: { id: 'SNOW', name: 'ÈôçÈõ™', color: 'rgba(200,240,255,0.2)' }
        };

        const ZODIACS = [
            { sign: 'Áâ°Áæä', gender: 'M', color: '#c0392b', hair: '#2c3e50', trait: 'Â•ΩÈ¨•' },
            { sign: 'ÈáëÁâõ', gender: 'F', color: '#27ae60', hair: '#5d4037', trait: 'Âõ∫Âü∑' },
            { sign: 'ÈõôÂ≠ê', gender: 'M', color: '#f39c12', hair: '#e67e22', trait: 'ÂñÑËÆä' },
            { sign: 'Â∑®Ëüπ', gender: 'F', color: '#7f8c8d', hair: '#34495e', trait: 'È°ßÂÆ∂' },
            { sign: 'ÁçÖÂ≠ê', gender: 'M', color: '#e67e22', hair: '#f1c40f', trait: 'Èú∏Ê∞£' },
            { sign: 'ËôïÂ•≥', gender: 'F', color: '#16a085', hair: '#2ecc71', trait: 'Ë¨πÊÖé' },
            { sign: 'Â§©Áß§', gender: 'M', color: '#e84393', hair: '#fd79a8', trait: 'Áå∂Ë±´' },
            { sign: 'Â§©Ë†ç', gender: 'F', color: '#8e44ad', hair: '#2c3e50', trait: 'ÊïèÈä≥' },
            { sign: 'Â∞ÑÊâã', gender: 'M', color: '#2980b9', hair: '#3498db', trait: 'ÂÜíÈö™' },
            { sign: 'Êë©ÁæØ', gender: 'F', color: '#576574', hair: '#1e272e', trait: 'Â†ÖÂøç' },
            { sign: 'Ê∞¥Áì∂', gender: 'M', color: '#00d2d3', hair: '#00cec9', trait: 'Âè§ÊÄ™' },
            { sign: 'ÈõôÈ≠ö', gender: 'F', color: '#a29bfe', hair: '#6c5ce7', trait: 'Êµ™Êº´' }
        ];

        const PRE_CANNED_THOUGHTS = {
            IDLE: ["ÁôºÂëÜ‰∏≠...", "‰ªäÂ§©Â§©Ê∞£‰∏çÈåØ„ÄÇ", "ËÇöÂ≠êÊúâÈªûÈ§ì„ÄÇ", "Â•ΩÁÑ°ËÅäÂïä...", "Èõ≤ÁúãËµ∑‰æÜÂÉèÈõûËÖø„ÄÇ", "ÊÉ≥Áù°Ë¶∫‰∫Ü..."],
            WORK: ["ÂòøÂíª...ÂòøÂíª...", "ÁÇ∫‰∫ÜÈÉ®ËêΩÔºÅ", "ÈÄôÂ∑•‰ΩúÁúüÁ¥Ø‰∫∫„ÄÇ", "Â∏åÊúõËÉΩÊâæÂà∞Â•ΩÊù±Ë•ø„ÄÇ", "ÂÜçÊíê‰∏Ä‰∏ã„ÄÇ", "ÂãûÂãï‰ΩøÊàëÂø´Ê®Ç...ÂêßÔºü"],
            EAT: ["ÁúüÂ•ΩÂêÉÔºÅ", "ÁµÇÊñºÊúâÊù±Ë•øÂêÉ‰∫Ü„ÄÇ", "ÎÉ†ÎÉ†...", "Â∏åÊúõËÉΩÂêÉÈ£Ω„ÄÇ", "ÈÄôÂë≥ÈÅì‰∏çÈåØ„ÄÇ", "ÊÑüË¨ùÂ§ßËá™ÁÑ∂ÁöÑÈ•ãË¥à„ÄÇ"],
            SLEEP: ["Âëº...Âëº...", "Â•ΩÁùè...", "ÊôöÂÆâ...", "Zzz...", "ÊòéÂ§©ÂèàÊòØÊñ∞ÁöÑ‰∏ÄÂ§©„ÄÇ", "Âà•ÂêµÊàë..."],
            CHAT: ["ÁúüÁöÑÂÅáÁöÑÔºü", "ÂìàÂìàÔºåÂ§™Â•ΩÁ¨ë‰∫ÜÔºÅ", "‰Ω†ÊúÄËøëÈÇÑÂ•ΩÂóéÔºü", "ËÅΩË™™Êò®Â§©...", "ÈÇ£ÂÄã‰∫∫Â•ΩÂ•áÊÄ™„ÄÇ", "ÈÄôÂ§©Ê∞£ÁúüÁ≥ü„ÄÇ", "‰ªäÊôöÂêÉ‰ªÄÈ∫ºÔºü", "Â∞èÂøÉÈáéÁç∏ÔºÅ"],
            FIGHT: ["ÂéªÊ≠ªÂêßÔºÅ", "Âà•ÈÅé‰æÜÔºÅ", "ÁúãÊãõÔºÅ", "ÁÇ∫‰∫ÜÊ¶ÆËÄÄÔºÅ", "ÊàëË∑ü‰Ω†Êãº‰∫ÜÔºÅ", "Â•ΩÂèØÊÄïÔºÅ"],
            FLEE: ["ÊïëÂëΩÂïäÔºÅ", "Âø´Ë∑ëÔºÅ", "Êâì‰∏çÈÅéÂø´ÈÄÉÔºÅ", "Âà•ÊÆ∫ÊàëÔºÅ", "Êàë‰∏çÁé©‰∫ÜÔºÅ", "ËÖ≥Â∫ïÊäπÊ≤πÔºÅ"],
            PANIC: ["Êàë‰∏çÊÉ≥Ê≠ª...", "ÈÄôÊòØ‰ªÄÈ∫ºÈ¨ºÂú∞Êñπ...", "ÂóöÂóöÂóö...", "Ë™∞‰æÜÊïëÊïëÊàë...", "ËÖ¶Ë¢ãÂ•ΩÁóõ...", "‰∏çË¶ÅÈÅé‰æÜÔºÅ"],
            CRAFT: ["Ë£Ω‰ΩúÂ∑•ÂÖ∑‰∏≠...", "ÈÄôÂÄãÁ∂ÅÁ∑ä‰∏ÄÈªû...", "ÈúÄË¶Å‰∏ÄÊääÂ•ΩÊñßÈ†≠„ÄÇ", "Êï≤Êï≤ÊâìÊâì...", "Âø´ÂÅöÂ•Ω‰∫ÜÔºÅ"],
            INSANE: ["ÂòøÂòøÂòø...", "Ëü≤Â≠ê...ÁöÆËÜö‰∏ãÊúâËü≤Â≠ê...", "Â§©Á©∫Âú®ËûçÂåñ...", "Âà•ÈÅé‰æÜÔºÅ‰Ω†ÊòØÊÉ°È≠îÔºÅ", "ÊàëË¶ÅÈ£õ...", "ÂÆâÈùúÔºÅËÅ≤Èü≥Â§™Â§ß‰∫ÜÔºÅ"]
        };

        const LOG_TEMPLATES = {
            FIGHT_START: [
                "‚öîÔ∏è {name} ÈÅ≠ÈÅá {enemy}ÔºåÊà∞È¨•ÈñãÂßãÔºÅ", 
                "{name} ÁÇ∫‰∫Ü‰øùË°õÂÆ∂ÂúíÂ∞çÊäó {enemy}ÔºÅ", 
                "‚ö†Ô∏è {name} Ë¢´ {enemy} Ë•≤Êìä‰∫ÜÔºÅ"
            ],
            FLEE: ["üèÉ {name} È©öÊÖåÂ§±Êé™Âú∞ÈÄÉË∑ë‰∫ÜÔºÅ", "{name} Ë¶∫Âæó‰øùÂëΩË¶ÅÁ∑äÔºåËΩâË∫´Â∞±Ë∑ë„ÄÇ"],
            PANIC: ["üò± {name} Á≤æÁ•ûÂ¥©ÊΩ∞‰∫ÜÔºÅ", "{name} Âú®ÊÅêÊáº‰∏≠È°´Êäñ...", "{name} ÈñãÂßãËÉ°Ë®Ä‰∫ÇË™û„ÄÇ"],
            DEATH: ["üíÄ {name} ÂõûÊ≠∏‰∫ÜÊòüËæ∞...", "{name} ÂÄí‰∏ã‰∫ÜÔºåÈÉ®ËêΩÂ§±Âéª‰∫Ü‰∏Ä‰ΩçÊàêÂì°„ÄÇ"],
            OLD_AGE: ["üïØÔ∏è {name} Â£ΩÁµÇÊ≠£ÂØ¢ÔºåÂÆâË©≥Âú∞Èõ¢Èñã‰∫Ü„ÄÇ", "{name} Ëµ∞ÂÆå‰∫ÜÊº´Èï∑ÁöÑ‰∏ÄÁîü„ÄÇ"],
            BIRTH: ["üë∂ {name} ÁÇ∫ÈÉ®ËêΩÂ∏∂‰æÜ‰∫ÜÊñ∞ÁîüÂëΩÔºÅ", "ÈÉ®ËêΩË™ïÁîü‰∫Ü‰∏Ä‰ΩçÊñ∞ÊàêÂì° {name}ÔºÅ"],
            INSANITY: ["üåÄ {name} ÁêÜÊô∫Êñ∑Á∑öÔºåÈô∑ÂÖ•‰∫ÜÁòãÁãÇÔºÅ", "{name} ÁúºÁ•ûÊ∏ôÊï£ÔºåÈñãÂßãÊîªÊìäÂë®ÂúçÁöÑ‰∏ÄÂàá„ÄÇ"],
            ATTACK_FRIEND: ["üî™ {name} Âõ†ÁòãÁãÇË™§ÂÇ∑‰∫ÜÂêå‰º¥ÔºÅ", "{name} Èô∑ÂÖ•ÂπªË¶∫ÁôºËµ∑‰∫ÜÊîªÊìäÔºÅ"]
        };

        const getLog = (type, name, target = "", enemy = "") => {
            const templates = LOG_TEMPLATES[type] || ["{name} ÁôºÁîü‰∫Ü‰∫ã‰ª∂„ÄÇ"];
            const template = templates[Math.floor(Math.random() * templates.length)];
            return template.replace("{name}", name).replace("{target}", target).replace("{enemy}", enemy);
        };

        const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const noise = (x, y) => Math.sin(x/3.5) + Math.cos(y/4.5);
        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        const callGemini = async (prompt, userKey) => {
            if (!userKey) return null;
            try {
                const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${userKey}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || null;
            } catch (error) { console.error("AI Error:", error); return null; }
        };

        const SPRITE_MATRICES = {
            CHAR_M: ["........................",".......HHHHHH...........","......HSSSSSSH..........",".....HSSKSSKSSH.........",".....HSSSSSSSSH.........","......SSSSSSSS..........","....CCCSCCCCSCCC........","....CCCSCCCCSCCC........","....CCCCCCCCCCCC........","....KKKCCCCCCKKK........","....K.KCCCCCCK.K........","......KSSSSSSK..........","......KSSSSSSK..........","......KKK..KKK.........."],
            CHAR_F: ["........................","......HHHHHHHH..........",".....HSSSSSSSSH.........",".....HSSKSSKSSH.........",".....HSSSSSSSSH.........",".....SSSSSSSSSS.........","....CCCSCCCCSCCC........","...CCCCSCCCCSCCCC.......","...CCCCCCCCCCCCCC.......","...CCCCCCCCCCCCCC.......","....CCCCCCCCCCCC........",".....KSSSSSSssk.........",".....KSSSSSSssk.........",".....KKK....KKK........."],
            TREE_OAK: [".......LLLLLL.......",".....LLLLLLLLLL.....","....LLLLLLLLLLLL....","...LLLLLLLLLLLLLL...","...LLLLLLLLLLLLLL...","....LLLLLLLLLLLL....",".....LLLLLLLLLL.....",".......WWWWWW.......",".......WWWWWW.......",".......WWWWWW.......","......WWWWWWWW......"],
            TREE_PINE: ["..........L.........",".........LLL........","........LLLLL.......",".......LLLLLLL......",".........LLL........","........LLLLL.......",".......LLLLLLL......","......LLLLLLLLL.....",".....LLLLLLLLLLL....","........WWWWW.......",".......WWWWWWW......"],
            BUSH: ["....................","......LLLLLLL.......",".....LLLLLLLLL......","....LLLLLLLLLLL.....","....LLLLLLLLLLL.....",".....LLLLLLLLL......"],
            BERRY_BUSH: ["....................","......LLRLLRL.......",".....LLLRLLRLL......","....LLLLLLLLLLL.....","....LLLLLLLLLLL.....",".....LLLLLLLLL......"],
            FLOWER: [".........R..........","........RYR.........",".........R..........",".........G..........",".........G.........."],
            MUSHROOM: ["........RRR.........",".......RRRRR........",".......RWWWR........","........WWW.........","........WWW........."],
            ROCK: [".......KKKKKK.......",".....KKMMMMMMKK.....","....KMMLLLLLLMMK....","...KMLLLLLLLLLLMK...","...KMMMMMMMMMMMMK...","...KDDDDDDDDDDDDK...","....KKDDDDDDDDKK....","......KKKKKKKK......"],
            GOLD_ROCK: [".......KKKKKK.......",".....KKMMMMMMKK.....","....KMMYYYMMMKMK....","...KMYYYYYYYYYMK...","...KMMYYYYYYYYMK...","...KDDDDDDDDDDDDK...","....KKDDDDDDDDKK....","......KKKKKKKK......"],
            RABBIT: [".......KK...........","......KWWK..........",".....KWWWWK.........",".....KWWWWK.........","......KKKK.........."],
            WOLF: ["....................",".......K............","......KGK...........",".....KGGGK..........","....KGGGGGK...K.....","...KGGGGGGGGKKGK....","...KGGGGGGGGGGGK....","....KGGGGGGGGGK.....","....K.K.....K.K....."],
            BEAR: [".........KK...KK....","......KKKBBKKKBBK...",".....KBBBBBBBBBBBK..","....KBBBBBBBBBBBBBK.","...KBBBBBBBBBBBBBBBK","...KBBBBBBBBBBBBBBBK","...KBBBBBBBBBBBBBBBK","....KB.B.B.....B.B..","....KK.K.K.....K.K.."],
            DEER: ["...........K...K....","............K.K.....","..........KKKBKK....",".........KBBBBBBK...","........KBBBBBBBBK..",".......KBBBBBBBBBK..",".......K.B.....B....",".......K.K.....K...."],
            FOX: ["...........K........","..........KOK.......",".........KOOK.......","........KOOOK.......",".......KOOOOK...O...","......KOOOOOOKKOK...",".....KOOOOOOOOOK....","....KOOOOOOOOOK.....","....K.K......K.K...."],
            BOAR: ["....................",".........KKK........",".......KKKKK........","......KKDDDKK.......",".....KDDDDDDDK......","....KDDDDDDDDDK.....","...KDDDDDDDDDDDK....","...KDDDDDDDDDDDK....","....K.K......K.K...."],
            SHEEP: ["....................","........WWW.........",".......WWWWW........","......WWWWWWW.......",".....WWWWWWWWW......",".....WWWWWWWWW......","......WWWWWWW.......","......K.K.K.K......."],
            COW: ["....................",".........KK.........","......KKWWKK........",".....KWWWWWWK.......","....KWWWWWWWWK......","....KWBWWBWWK.......","....KWWWWWWWWK......","....KWWWWWWWWK......",".....K.K..K.K......."],
            WHEAT_GROW: ["................","....1......1....","...111....111...","....1......1....","................"],
            WHEAT_READY: ["....3......3....","...333....333...","...333....333...","....3......3....","....3......3...."],
            DINOSAUR: ["........................","................KKKKK...","...............KGGGGGK..","...............KGGYGGK..","...............KGGGGGK..",".......KKKK...KGGGGGK...",".....KKGGGGKKKGGGGGK....","....KGGGGGGGGGGGGGK.....","...KGGGGGGGGGGGGGK......","...KGGGGGGGGGGGGK.......","....KGGGGGGGGGGK........",".....KGGK..KGGK.........","......KK....KK.........."],
            SKULL: ["........................","........................",".........KKKK...........","........KWWWWK..........",".......KWBWWBWK.........",".......KWWWWWWK.........","........KKBKKBK.........",".........KKKKK..........",".......KK.....KK........","......K.........K.......","........................","........................"],
            CAVE: [".....KKKKKKKKK.....","...KKXXXXXXXXXKK...","..KXXXXXXXXXXXXXK..",".KXXXXXXXXXXXXXXXK.",".KXXXXXXXXXXXXXXXK.","KXXXXXXXXXXXXXXXXXK","KXXXXXXXXXXXXXXXXXK","KXXXXXX.....XXXXXXK","KXXXXXX.....XXXXXXK","KXXXXXX.....XXXXXXK"],
            HUT: [".........K.........",".......KRRK........","......KRRRRK.......",".....KRRRRRRK......","....KRRRRRRRRK.....","...KRRRRRRRRRRK....","..KWWWWWWWWWWWWK...","..KW..W....W..WK...","..KW..W....W..WK...","..KWWWW....WWWWK..."],
            HOUSE: ["...................","...KKKKKKKKKKKKK...","...KRRRRRRRRRRRK...","...KRRRRRRRRRRRK...","...KRRRRRRRRRRRK...","...KKKKKKKKKKKKK...","...KWWWWWWWWWWWK...","...KWWWWWWWWWWWK...","...KWW.WWWW.WWWK...","...KWW.WWWW.WWWK..."],
            CASTLE: [".KK...KK...KK...KK.",".KWK.KWK...KWK.KWK.",".KWWKWWK...KWWKWWK.",".KWWWWWKKKKKWWWWWK.",".KWWWWWWWWWWWWWWWK.",".KWWWWWWWWWWWWWWWK.",".KWWWWWWWWWWWWWWWK.",".KWWWWWW.WWWWWWWWK.",".KWWWWWW.WWWWWWWWK.",".KWWWWWW.WWWWWWWWK."],
            BONFIRE: [".........F..........","........FFF.........",".......FFFFF........",".........W..........","........W W........."],
            TOWER: [".......KKKKK........",".......KWWWK........",".......KWWWK........",".......KWWWK........","......KKWWWKK.......","......KWWWWWK.......","......KWWWWWK.......","......KWWWWWK.......","......KWWWWWK......."],
            WALL: ["....................","....................","....................","....................","...WWWWWWWWWWWWWW...","...WWWWWWWWWWWWWW...","...WWWWWWWWWWWWWW...","...WWWWWWWWWWWWWW..."],
            ARROW: [".........K..........",".........W..........",".........W..........",".........W..........","........FFF........."]
        };

        const renderMatrix = (ctx, matrix, colors, offsetX = 0, offsetY = 0) => {
            matrix.forEach((row, y) => {
                for (let x = 0; x < row.length; x++) {
                    const char = row[x];
                    if (char === '.') continue;
                    let fill = colors[char] || PALETTE.OUTLINE;
                    if (char === 'K') fill = PALETTE.OUTLINE;
                    ctx.fillStyle = fill;
                    ctx.fillRect(offsetX + x, offsetY + y, 1, 1);
                }
            });
        };

        const createSprites = () => {
            const cache = {};
            const createCanvas = (w, h) => { const c = document.createElement('canvas'); c.width = w; c.height = h; return { c, ctx: c.getContext('2d') }; };

            const { c: grassC, ctx: grassCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            grassCtx.fillStyle = PALETTE.GRASS_BG; grassCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            grassCtx.fillStyle = PALETTE.GRASS_L; for(let i=0; i<30; i++) grassCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            grassCtx.fillStyle = PALETTE.GRASS_D; for(let i=0; i<20; i++) grassCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.grass = grassC;

            const { c: dirtC, ctx: dirtCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            dirtCtx.fillStyle = PALETTE.DIRT; dirtCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            dirtCtx.fillStyle = PALETTE.WOOD_D; for(let i=0; i<40; i++) dirtCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.dirt = dirtC;

            const { c: sandC, ctx: sandCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            sandCtx.fillStyle = PALETTE.SAND; sandCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            sandCtx.fillStyle = '#d4b483'; for(let i=0; i<30; i++) sandCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.sand = sandC;

            const { c: mtC, ctx: mtCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            mtCtx.fillStyle = PALETTE.MOUNTAIN_BG; mtCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            mtCtx.fillStyle = PALETTE.MOUNTAIN_FG; for(let i=0; i<25; i++) { let rx = rand(0,30); let ry = rand(0,30); mtCtx.fillRect(rx, ry, 2, 2); }
            cache.mountain = mtC;

            const makeSprite = (name, mat, colors, wMult=1, hMult=1, ox=0, oy=0) => {
                const { c, ctx } = createCanvas(TILE_SIZE*wMult, TILE_SIZE*hMult);
                renderMatrix(ctx, mat, colors, ox, oy);
                cache[name] = c;
            };

            makeSprite('tree_oak', SPRITE_MATRICES.TREE_OAK, {'L': PALETTE.LEAF_D, 'W': PALETTE.WOOD_D}, 1, 2, 6, 10);
            makeSprite('tree_pine', SPRITE_MATRICES.TREE_PINE, {'L': PALETTE.LEAF_PINE, 'W': PALETTE.WOOD_D}, 1, 2, 6, 8);
            makeSprite('bush', SPRITE_MATRICES.BUSH, {'L': PALETTE.LEAF_L}, 1, 1, 4, 16);
            makeSprite('berry_bush', SPRITE_MATRICES.BERRY_BUSH, {'L': PALETTE.LEAF_L, 'R': PALETTE.BERRY}, 1, 1, 4, 16);
            makeSprite('flower', SPRITE_MATRICES.FLOWER, {'R': PALETTE.FLOWER_R, 'Y': PALETTE.FLOWER_Y, 'G': PALETTE.GRASS_L}, 1, 1, 10, 16);
            makeSprite('mushroom', SPRITE_MATRICES.MUSHROOM, {'R': PALETTE.MUSHROOM, 'W': PALETTE.WHITE}, 1, 1, 10, 16);
            makeSprite('rock', SPRITE_MATRICES.ROCK, {'K': PALETTE.OUTLINE, 'M': PALETTE.STONE_M, 'L': PALETTE.STONE_L, 'D': PALETTE.STONE_D}, 1, 1, 8, 16);
            makeSprite('gold_rock', SPRITE_MATRICES.GOLD_ROCK, {'K': PALETTE.OUTLINE, 'M': PALETTE.STONE_M, 'Y': PALETTE.GOLD, 'D': PALETTE.STONE_D}, 1, 1, 8, 16);
            makeSprite('rabbit', SPRITE_MATRICES.RABBIT, {'W': PALETTE.FUR_RABBIT}, 1, 1, 8, 16);
            makeSprite('wolf', SPRITE_MATRICES.WOLF, {'G': PALETTE.FUR_WOLF}, 1, 1, 4, 12);
            makeSprite('bear', SPRITE_MATRICES.BEAR, {'B': PALETTE.FUR_BEAR}, 1.5, 1.5, 4, 10);
            makeSprite('deer', SPRITE_MATRICES.DEER, {'B': PALETTE.FUR_DEER}, 1, 1.5, 4, 10);
            makeSprite('dinosaur', SPRITE_MATRICES.DINOSAUR, {'G': PALETTE.DINO_GREEN, 'Y': PALETTE.DINO_EYE}, 2, 2, 16, 16); 
            makeSprite('fox', SPRITE_MATRICES.FOX, {'O': PALETTE.FUR_FOX}, 1, 1, 4, 12); // New
            makeSprite('boar', SPRITE_MATRICES.BOAR, {'D': PALETTE.SKIN_PIG}, 1, 1, 4, 12); // New
            makeSprite('sheep', SPRITE_MATRICES.SHEEP, {'W': PALETTE.FUR_SHEEP}, 1, 1, 4, 12); // New
            makeSprite('cow', SPRITE_MATRICES.COW, {'W': PALETTE.WHITE, 'B': PALETTE.OUTLINE}, 1, 1, 4, 12); // New
            makeSprite('wheat_1', SPRITE_MATRICES.WHEAT_GROW, { '1': PALETTE.WHEAT_1 }, 1, 1, 8, 16);
            makeSprite('wheat_2', SPRITE_MATRICES.WHEAT_READY, { '3': PALETTE.WHEAT_3 }, 1, 1, 8, 16);
            makeSprite('skull', SPRITE_MATRICES.SKULL, { 'W': PALETTE.BONE_WHITE, 'B': PALETTE.OUTLINE }, 1, 1, 8, 10);
            makeSprite('cave', SPRITE_MATRICES.CAVE, { 'X': PALETTE.CAVE_DARK, 'K': PALETTE.MOUNTAIN_FG }, 2, 2, 16, 24);
            makeSprite('hut', SPRITE_MATRICES.HUT, { 'R': PALETTE.HUT_ROOF, 'W': PALETTE.WOOD_L }, 2, 2, 16, 24);
            makeSprite('house', SPRITE_MATRICES.HOUSE, { 'R': PALETTE.HOUSE_ROOF, 'W': PALETTE.STONE_L }, 2, 2, 16, 24);
            makeSprite('castle', SPRITE_MATRICES.CASTLE, { 'W': PALETTE.CASTLE_WALL }, 2, 2, 16, 24);
            makeSprite('bonfire', SPRITE_MATRICES.BONFIRE, { 'F': PALETTE.FIRE_2, 'W': PALETTE.WOOD_D }, 1, 1, 8, 10);
            makeSprite('tower', SPRITE_MATRICES.TOWER, { 'W': PALETTE.WOOD_L }, 1, 1, 8, 8);
            makeSprite('wall', SPRITE_MATRICES.WALL, { 'W': PALETTE.WOOD_D }, 1, 1, 0, 8);
            makeSprite('arrow', SPRITE_MATRICES.ARROW, { 'W': PALETTE.TOOL_SPEAR, 'F': PALETTE.RED }, 1, 1, 8, 8);

            return cache;
        };

        const generateMapData = () => {
            const newMap = [];
            const centerX = MAP_WIDTH / 2;
            const centerY = MAP_HEIGHT / 2;
            const noiseOffsetX = Math.random() * 1000;
            const noiseOffsetY = Math.random() * 1000;

            for(let y=0; y<MAP_HEIGHT; y++) {
                const row = [];
                for(let x=0; x<MAP_WIDTH; x++) {
                    const n = noise(x + noiseOffsetX, y + noiseOffsetY);
                    let type = 'GRASS';
                    let decoration = null;
                    
                    if (n > 0.8) type = 'WATER';
                    else if (n > 0.6) type = 'SAND'; 
                    else if (n < -0.6) type = 'MOUNTAIN_GROUND';
                    else if (n < 0.1) type = 'FOREST';
                    
                    const dist = Math.sqrt((x-centerX)**2 + (y-centerY)**2);
                    if (dist < 6) {
                        type = 'GRASS';
                        if (dist < 1.5) decoration = 'BASE';
                        else {
                            const r = Math.random();
                            if (r < 0.10) decoration = 'TREE_OAK';
                            else if (r < 0.40) decoration = 'BERRY_BUSH'; 
                            else if (r < 0.55) decoration = 'BUSH';       
                            else if (r < 0.60) decoration = 'ROCK';
                            else if (r < 0.65) decoration = 'FLOWER';
                        }
                    } else {
                        if (type === 'FOREST') {
                            const r = Math.random();
                            if (r > 0.5) decoration = 'TREE_OAK';
                            else if (r > 0.25) decoration = 'TREE_PINE';
                            else if (r > 0.15) decoration = 'BERRY_BUSH'; 
                            else if (r < 0.05) decoration = 'MUSHROOM';
                        } else if (type === 'GRASS') {
                            const rnd = Math.random();
                            if (rnd < 0.05) decoration = 'ROCK';
                            else if (rnd < 0.12) decoration = 'TREE_OAK'; 
                            else if (rnd < 0.18) decoration = 'BERRY_BUSH'; 
                            else if (rnd < 0.25) decoration = 'BUSH';
                            else if (rnd < 0.30) decoration = 'FLOWER';
                        } else if (type === 'MOUNTAIN_GROUND') {
                            const r = Math.random();
                            if (r < 0.15) decoration = 'ROCK';
                            else if (r < 0.18) decoration = 'GOLD_ROCK'; 
                        }
                    }
                    if (decoration === 'BASE' && (Math.abs(x - centerX) > 0.5 || Math.abs(y - centerY) > 0.5)) decoration = null;
                    if (Math.abs(x - centerX) < 0.5 && Math.abs(y - centerY) < 0.5) decoration = 'BASE';
                    row.push({ x, y, type, decoration });
                }
                newMap.push(row);
            }
            return newMap;
        };

        const generateSim = (id, x, y, gen = 1, age = 18) => {
            const z = ZODIACS[Math.floor(Math.random() * ZODIACS.length)];
            const traits = {
                bravery: Math.random(),   
                diligence: Math.random(), 
                social: Math.random(),    
                madness: Math.random() * 0.2 
            };
            return {
                id: id || `sim_${Date.now()}_${Math.random()}`, ...z,
                x: x || MAP_WIDTH/2 + rand(-1,1), y: y || MAP_HEIGHT/2 + rand(-1,1) + 2,
                hp: 100, hunger: 100, energy: 100, mood: 80, sanity: 100, 
                age: age, generation: gen, traits: traits,
                state: 'IDLE', targetX: null, targetY: null, actionTimer: 0, targetId: null,
                inventory: { wood:0, food:0, stone:0 },
                tools: { axe: false, pick: false, spear: false, bow: false },
                thought: 'ÈÄôÂÄã‰∏ñÁïåÂ•ΩÂ§ß...', 
                animFrame: rand(0,10), dir: 1, hidden: false, sick: false,
                buffTimer: 0, mateCooldown: 0,
                lastThoughtTime: 0,
                stateLock: 0 
            };
        };

        const generateCreaturesData = () => {
            const initCreatures = [];
            const types = Object.keys(CREATURE_STATS);
            
            for(let i=0; i<30; i++) { // Increased to 30
                const r = Math.random();
                let type = 'RABBIT';
                
                // Weighted Random Spawn
                if (r > 0.98) type = 'DINOSAUR';
                else if (r > 0.95) type = 'BEAR';
                else if (r > 0.90) type = 'WOLF';
                else if (r > 0.85) type = 'BOAR';
                else if (r > 0.80) type = 'FOX';
                else if (r > 0.65) type = 'DEER';
                else if (r > 0.50) type = 'COW';
                else if (r > 0.35) type = 'SHEEP';
                else type = 'RABBIT';
                
                initCreatures.push({
                    id: `c_${Date.now()}_${i}`, type,
                    x: rand(2, MAP_WIDTH-3), y: rand(2, MAP_HEIGHT-3),
                    hp: CREATURE_STATS[type].hp,
                    targetX: null, targetY: null,
                    state: 'WANDER', animFrame: rand(0,10), dir: 1
                });
            }
            return initCreatures;
        };

        const App = () => {
            const [sprites, setSprites] = useState(null);
            const [map, setMap] = useState([]);
            const [sims, setSims] = useState([]);
            const [creatures, setCreatures] = useState([]);
            const [buildings, setBuildings] = useState([]);
            const [projectiles, setProjectiles] = useState([]);
            const [particles, setParticles] = useState([]);
            const [tribe, setTribe] = useState({ wood: 0, stone: 0, food: 100, tech: 1, unlockedTechs: ['STONE_TOOLS'] });
            const [weather, setWeather] = useState(WEATHER.SUNNY);
            const [time, setTime] = useState(0);
            const [day, setDay] = useState(1);
            const [era, setEra] = useState(1);
            const [mana, setMana] = useState(999999);
            const [selectedId, setSelectedId] = useState(null);
            const [buildMode, setBuildMode] = useState(null);
            const [events, setEvents] = useState([{id: 0, text:'Êóè‰∫∫‰ª∞ÊúõÊòüÁ©∫ÔºåÊïÖ‰∫ãÈñãÂßã‰∫Ü...'}]); 
            const [isGameOver, setIsGameOver] = useState(false);
            const [disaster, setDisaster] = useState(DISASTERS.NONE);
            const [disasterTimer, setDisasterTimer] = useState(0);
            const [shake, setShake] = useState(0);
            const [isLogOpen, setIsLogOpen] = useState(true);
            const [flash, setFlash] = useState(0);
            const [userApiKey, setUserApiKey] = useState(""); 
            const [showApiKeyInput, setShowApiKeyInput] = useState(false);
            const [isSaving, setIsSaving] = useState(false); 
            
            // AI Logic Refs
            const aiTimerRef = useRef(AI_COOLDOWN_TICKS);
            
            // NEW: AI Decision Queue System
            const aiRequestQueue = useRef([]);
            const isAiProcessing = useRef(false);

            const canvasRef = useRef(null);
            const tickRef = useRef(0);
            const requestRef = useRef();
            const logEndRef = useRef(null);
            const savedGame = useRef(false);

            useEffect(() => {
                if (isLogOpen) logEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [events, isLogOpen]);

            useEffect(() => {
                const save = localStorage.getItem('TribeSave');
                if (save) {
                    try {
                        const d = JSON.parse(save);
                        setTribe(d.tribe); setSims(d.sims); setBuildings(d.buildings || []);
                        setEra(d.era); setDay(d.day); setMana(d.mana);
                        setMap(d.map || generateMapData()); 
                        // Regenerate creatures if old save lacks new types or just for freshness
                        setCreatures(generateCreaturesData()); 
                        addEvent('Â∑≤ËÆÄÂèñÈÉ®ËêΩÂ≠òÊ™î„ÄÇ');
                        savedGame.current = true;
                    } catch(e) { console.error("Save error", e); }
                }

                setSprites(createSprites());
                if (!savedGame.current) {
                    setMap(generateMapData());
                    setSims(Array(12).fill(0).map((_, i) => generateSim(`start_${i}`, null, null, 1, 18)));
                    setCreatures(generateCreaturesData());
                    addEvent('üí° Êóè‰∫∫Â§©ÁîüÊéåÊè°‰∫Ü [Áü≥Âô®ÊâìÁ£®] ÁöÑÊäÄË°ì„ÄÇ');
                }
            }, []);

            useEffect(() => {
                if (tickRef.current > 0 && tickRef.current % 1000 === 0 && sims.length > 0) {
                    const saveData = { tribe, sims, buildings, map, era, day, mana };
                    localStorage.setItem('TribeSave', JSON.stringify(saveData));
                    setIsSaving(true);
                    setTimeout(() => setIsSaving(false), 2000);
                }
            }, [tribe, sims, buildings, map, era, day, mana]);

            useEffect(() => {
                if (sims.length > 0 && sims.every(s => s.state === 'DEAD') && !isGameOver) {
                    setIsGameOver(true);
                }
            }, [sims, isGameOver]);

            // NEW: Awakening Effect
            useEffect(() => {
                if (userApiKey && userApiKey.length > 5) {
                    addEvent("üß†„ÄêÁ•ûËπü„ÄëÊòüËæ∞Ë≥¶‰∫à‰∫ÜÊóè‰∫∫Êô∫ÊÖßÔºå‰ªñÂÄëË¶∫ÈÜí‰∫ÜËá™ÊàëÊÑèË≠òÔºÅ");
                    setFlash(2.0); 
                    setSims(prev => prev.map(s => ({
                        ...s, 
                        sanity: 100, 
                        mood: 100,
                        thought: "ÊÄùÁ∑í...ËÆäÂæóÊ∏ÖÊô∞‰∫Ü...",
                        lastThoughtTime: Date.now() 
                    })));
                }
            }, [userApiKey]);

            const addEvent = (text) => {
                setEvents(prev => [...prev, { id: Date.now() + Math.random(), text }]);
            };

            const startNextEra = () => {
                localStorage.removeItem('TribeSave');
                window.location.reload();
            };

            // Helper to check tech
            const hasTech = (techId) => tribe.unlockedTechs.includes(techId);

            const handleBuild = (type) => {
                const b = BUILDINGS[type];
                if (b.reqTech && !hasTech(b.reqTech)) {
                    addEvent(`‚ùå Êú™Ëß£ÈéñÁßëÊäÄ: ${TECH_TREE.find(t=>t.id===b.reqTech).name}`);
                    return;
                }
                setBuildMode(type);
                addEvent(`Âª∫ÁØâÊ®°Âºè: Ë´ãÈªûÊìäÂú∞Èù¢Âª∫ÈÄ† ${b.name}`);
            };

            const castSpell = (type) => {
                if (type === 'DISASTER') {
                    if (mana < 100) { addEvent("Á•ûÂäõ‰∏çË∂≥ (ÈúÄË¶Å 100)"); return; }
                    setMana(m => m - 100);
                    const keys = Object.keys(DISASTERS).filter(k => k !== 'NONE');
                    const selectedDisaster = DISASTERS[keys[Math.floor(Math.random() * keys.length)]];
                    setDisaster(selectedDisaster); setDisasterTimer(600);
                    addEvent(`‚ö†Ô∏è Á•ûË´≠Ôºö${selectedDisaster.name} ÈôçËá®ÔºÅ`);
                    if (selectedDisaster.id === 'BEASTS') setCreatures(prev => [...prev, ...generateCreaturesData().slice(0,5)]);
                    return;
                }
                
                if (type === 'TECH') {
                    if (tribe.tech >= TECH_TREE.length) { addEvent("ÊñáÊòéÂ∑≤ÈÅîÂ∑îÂ≥∞"); return; }
                    if (mana < 50) { addEvent("Á•ûÂäõ‰∏çË∂≥ (ÈúÄË¶Å 50)"); return; }
                    setMana(m => m - 50);
                    const newTech = TECH_TREE[tribe.tech];
                    setTribe(t => ({...t, tech: t.tech + 1, unlockedTechs: [...t.unlockedTechs, newTech.id]}));
                    addEvent(`üí° ÁôºÊòé‰∫Ü [${newTech.name}] - ${newTech.desc}`);
                    setFlash(1); // Visual Flash
                    return;
                }
                
                // Unit Spells (FOOD, HEAL, BUFF)
                if (['FOOD', 'HEAL', 'BUFF'].includes(type)) {
                    if (!selectedId || selectedId === 'BASE_CENTER') {
                        addEvent("‚ùå Ë´ãÂÖàÈªûÊìäÈÅ∏Êìá‰∏ÄÂÄãÊóè‰∫∫");
                        return;
                    }
                    
                    // Check Mana Cost (30 for unit spells)
                    if (mana < 30) { addEvent("Á•ûÂäõ‰∏çË∂≥ (ÈúÄË¶Å 30)"); return; }

                    const targetSim = sims.find(s => s.id === selectedId);
                    if (!targetSim) {
                        addEvent("‚ùå ÁõÆÊ®ôÁÑ°Êïà");
                        return;
                    }

                    setMana(m => m - 30);
                    setSims(prev => prev.map(s => {
                        if (s.id !== selectedId) return s;
                        if (type === 'FOOD') return { ...s, hunger: 100, mood: Math.min(100, s.mood+20) };
                        if (type === 'HEAL') return { ...s, hp: 100, sick: false, mood: Math.min(100, s.mood+20) };
                        if (type === 'BUFF') return { ...s, energy: 100, mood: 100, buffTimer: 500 };
                        return s;
                    }));

                    // Visual Feedback
                    const emojis = { FOOD: 'üçñ', HEAL: 'üíö', BUFF: '‚ú®' };
                    const names = { FOOD: 'Ë≥úÈ£ü', HEAL: 'Ê≤ªÁôí', BUFF: 'Ë≥úÁ¶è' };
                    setParticles(p => [...p, { x: targetSim.x*TILE_SIZE, y: targetSim.y*TILE_SIZE - 20, life: 60, color: '#fff', text: emojis[type], isThought: true }]);
                    addEvent(`Â∞ç ${targetSim.sign} ÊñΩÂ±ï‰∫Ü ${names[type]}`);
                    return;
                }

                // Global Weather Spells
                if (mana < 20) { addEvent("Á•ûÂäõ‰∏çË∂≥ (ÈúÄË¶Å 20)"); return; }
                
                setMana(m => m - 20);
                if (type === 'SUN') { setWeather(WEATHER.SUNNY); setDisaster(DISASTERS.NONE); addEvent('Á•ûËπüÔºöÁ•àÊô¥'); setFlash(0.5); }
                else if (type === 'RAIN') { setWeather(WEATHER.RAIN); setDisaster(DISASTERS.NONE); addEvent('Á•ûËπüÔºöÁ•àÈõ®'); setFlash(0.5); }
            };

            const findNearestResource = (sim, types) => {
                let nearest = null;
                let minDist = 999;
                for(let y=2; y<MAP_HEIGHT-2; y++) {
                    for(let x=2; x<MAP_WIDTH-2; x++) {
                        const tile = map[y][x];
                        if (types.includes(tile.decoration)) {
                            const d = Math.sqrt((x-sim.x)**2 + (y-sim.y)**2);
                            if (d < minDist) {
                                minDist = d;
                                nearest = {x, y};
                            }
                        }
                    }
                }
                return nearest;
            };

            // --- AI Decision Logic ---
            const processAiQueue = async () => {
                if (isAiProcessing.current || aiRequestQueue.current.length === 0 || !userApiKey) return;
                isAiProcessing.current = true;
                const { simId, simState, tribeStats, surroundings } = aiRequestQueue.current.shift();
                try {
                    const traits = simState.traits;
                    let personality = "";
                    if (traits.bravery > 0.7) personality += "Fearless, aggressive. ";
                    else if (traits.bravery < 0.3) personality += "Cowardly, timid. ";
                    if (traits.diligence > 0.7) personality += "Workaholic, hardworking. ";
                    else if (traits.diligence < 0.3) personality += "Lazy, procrastinator. ";
                    if (traits.social > 0.7) personality += "Chatty, friendly. ";
                    if (traits.madness > 0.1) personality += "Crazy, hears voices. ";

                    const prompt = `Roleplay as a villager in a survival game who has recently gained SENTIENCE and DIVINE WISDOM.
                    You realize you are part of a greater plan. You are self-aware.
                    Personality: ${personality}
                    Stats: HP ${Math.floor(simState.hp)}, Hunger ${Math.floor(simState.hunger)}, Energy ${Math.floor(simState.energy)}, Sanity ${Math.floor(simState.sanity)}.
                    Inventory: ${simState.tools.axe ? 'Has Axe' : 'No Axe'}, ${simState.tools.pick ? 'Has Pick' : 'No Pick'}.
                    Tribe Resources: Wood ${Math.floor(tribeStats.wood)}, Stone ${Math.floor(tribeStats.stone)}, Food ${Math.floor(tribeStats.food)}.
                    Surroundings: Nearest Tree: ${surroundings.tree ? 'Yes' : 'No'}, Nearest Rock: ${surroundings.rock ? 'Yes' : 'No'}, Nearest Bush: ${surroundings.bush ? 'Yes' : 'No'}, Nearest Friend: ${surroundings.friend ? 'Yes' : 'No'}
                    Goal: AGGRESSIVELY gather resources (Wood/Stone) to build a mighty civilization.
                    Show your new intelligence in your thoughts.
                    Crafting Costs: Axe needs 10 Wood. Pick needs 15 Wood.
                    Available Actions: 
                    - EAT (if hungry & food > 0)
                    - SLEEP (if tired)
                    - GATHER (collect food/sticks from bush. DO THIS if you have no Axe/Pick or low food)
                    - CHOP (collect wood, NEEDS AXE & Tree)
                    - MINE (collect stone, NEEDS PICK & Rock)
                    - CRAFT_AXE (needs 10 wood, no axe. TOP PRIORITY if wood >= 10)
                    - CRAFT_PICK (needs 15 wood, no pick. TOP PRIORITY if wood >= 15)
                    - CHAT (if friend nearby, output dialogue in thought)
                    - IDLE (avoid this)
                    Decide ONE action. Return strictly JSON: { "action": "ACTION_NAME", "thought": "Short thought or dialogue in Traditional Chinese (max 15 chars)." }`;

                    const resultText = await callGemini(prompt, userApiKey);
                    if (!resultText) throw new Error("AI response was empty or failed.");
                    let decision = { action: 'IDLE', thought: '...' };
                    try {
                        let jsonStr = resultText;
                        const firstOpen = resultText.indexOf('{');
                        if (firstOpen !== -1) {
                            let depth = 0;
                            let lastClose = -1;
                            for (let i = firstOpen; i < resultText.length; i++) {
                                if (resultText[i] === '{') depth++;
                                else if (resultText[i] === '}') {
                                    depth--;
                                    if (depth === 0) {
                                        lastClose = i;
                                        break;
                                    }
                                }
                            }
                            if (lastClose !== -1) {
                                jsonStr = resultText.substring(firstOpen, lastClose + 1);
                            }
                        }
                        decision = JSON.parse(jsonStr);
                    } catch (e) { console.error("AI JSON Parse Error", e); }

                    setSims(prev => prev.map(s => {
                        if (s.id !== simId) return s;
                        let nextS = { ...s, state: 'IDLE', thought: decision.thought || s.thought, lastThoughtTime: Date.now(), stateLock: 0 };
                        const act = decision.action;
                        if (act === 'SLEEP') { nextS.state = 'SLEEP'; nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2; nextS.stateLock = 200; }
                        else if (act === 'EAT') { nextS.state = 'EAT'; nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2; nextS.stateLock = 100; }
                        else if (act === 'GATHER') { const target = findNearestResource(nextS, ['BERRY_BUSH', 'BUSH']); if(target) { nextS.state = 'GATHER'; nextS.targetX = target.x; nextS.targetY = target.y; nextS.stateLock = 150; } }
                        else if (act === 'CHOP') { const target = findNearestResource(nextS, ['TREE_OAK', 'TREE_PINE']); if(target) { nextS.state = 'CHOP'; nextS.targetX = target.x; nextS.targetY = target.y; nextS.stateLock = 150; } }
                        else if (act === 'MINE') { const target = findNearestResource(nextS, ['ROCK', 'GOLD_ROCK']); if(target) { nextS.state = 'MINE'; nextS.targetX = target.x; nextS.targetY = target.y; nextS.stateLock = 150; } }
                        else if (act === 'CRAFT_AXE') { nextS.state = 'CRAFT'; nextS.craftType = 'AXE'; nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2; nextS.stateLock = 100; }
                        else if (act === 'CRAFT_PICK') { nextS.state = 'CRAFT'; nextS.craftType = 'PICK'; nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2; nextS.stateLock = 100; }
                        else if (act === 'CHAT') { 
                            if (surroundings.friendId) { 
                                const friend = prev.find(f => f.id === surroundings.friendId); 
                                if(friend) { 
                                    nextS.state = 'APPROACH_FRIEND'; nextS.targetId = friend.id; nextS.targetX = friend.x; nextS.targetY = friend.y; nextS.stateLock = 60; 
                                } 
                            } 
                        }
                        else { nextS.stateLock = 30; }
                        setParticles(p => [...p, { x: nextS.x*TILE_SIZE, y: nextS.y*TILE_SIZE, life: 60, color: '#0ff', text: 'üí°', isThought: true }]);
                        return nextS;
                    }));
                } catch (error) {
                    setSims(prev => prev.map(s => s.id === simId ? { ...s, state: 'IDLE', stateLock: 0 } : s));
                } finally {
                    isAiProcessing.current = false;
                    setTimeout(processAiQueue, 200);
                }
            };

            useEffect(() => {
                const interval = setInterval(() => { processAiQueue(); }, 500);
                return () => clearInterval(interval);
            }, [userApiKey]);

            const triggerAiThought = async (sim, targetSim = null) => {
                if (!userApiKey) {
                    let type = sim.state;
                    if (['CHOP', 'GATHER', 'MINE'].includes(type)) type = 'WORK';
                    if (['SHOOT', 'DEFEND'].includes(type)) type = 'FIGHT';
                    if (['APPROACH_FRIEND'].includes(type)) type = 'IDLE';
                    if (type === 'CRAFT') type = 'CRAFT';
                    if (type === 'INSANE') type = 'INSANE';
                    const texts = PRE_CANNED_THOUGHTS[type] || PRE_CANNED_THOUGHTS['IDLE'];
                    const text = texts[Math.floor(Math.random() * texts.length)];
                    setSims(prev => prev.map(s => s.id === sim.id ? { ...s, thought: text, lastThoughtTime: Date.now() } : s));
                    setParticles(prev => [...prev, { x: sim.x*TILE_SIZE, y: sim.y*TILE_SIZE, life: 120, color: '#fff', text: text, isThought: true }]);
                    return;
                }
            };

            // Helper Definitions
            const isInBase = (sim) => Math.sqrt((sim.x - MAP_WIDTH/2)**2 + (sim.y - MAP_HEIGHT/2)**2) < 6;
            const currentStage = CIV_STAGES.slice().reverse().find(s => tribe.tech >= s.minTech) || CIV_STAGES[0];

            // Main Update Logic
            const update = useCallback(() => {
                if (isGameOver) return;
                const isNight = time > DAY_TICKS * 0.6 || disaster === DISASTERS.DARKNESS;
                
                if (disaster !== DISASTERS.NONE) {
                    setDisasterTimer(prev => {
                        if (prev <= 1) { setDisaster(DISASTERS.NONE); addEvent('Â§©ÁÅΩÂ∑≤ÈÄÄÂéª„ÄÇ'); return 0; }
                        return prev - 1;
                    });
                }
                if (flash > 0) setFlash(f => Math.max(0, f - 0.1));

                if (tickRef.current % 10 === 0 && disaster === DISASTERS.NONE && Math.random() < 0.005) {
                    const r = Math.random();
                    setWeather(r < 0.3 ? WEATHER.RAIN : (r < 0.4 ? WEATHER.SNOW : WEATHER.SUNNY)); 
                }
                
                // Spawn Beasts over time
                if (tickRef.current % 1000 === 0 && creatures.length < 20) {
                     const typeKeys = Object.keys(CREATURE_STATS);
                     const randomType = typeKeys[Math.floor(Math.random() * typeKeys.length)];
                     const newBeast = {
                        id: `c_respawn_${Date.now()}`, type: randomType,
                        x: rand(2, MAP_WIDTH-3), y: rand(2, MAP_HEIGHT-3),
                        hp: CREATURE_STATS[randomType].hp,
                        targetX: null, targetY: null,
                        state: 'WANDER', animFrame: rand(0,10), dir: 1
                    };
                    setCreatures(prev => [...prev, newBeast]);
                }

                if (disaster === DISASTERS.QUAKE) setShake(prev => (tickRef.current % 4 === 0 ? rand(-5, 5) : 0)); else setShake(0);
                
                if (aiTimerRef.current > 0) {
                    aiTimerRef.current--;
                } else {
                    const candidates = sims.filter(s => s.state !== 'DEAD' && s.state !== 'SLEEP' && s.state !== 'AI_THINKING');
                    if (candidates.length > 0) {
                         const chosenSim = candidates[Math.floor(Math.random() * candidates.length)];
                         if (!userApiKey || Math.random() < 0.2) triggerAiThought(chosenSim);
                         aiTimerRef.current = AI_COOLDOWN_TICKS + rand(0, 50);
                    }
                }

                if (tickRef.current % 20 === 0) {
                    buildings.forEach(b => {
                        if (b.type === 'BONFIRE' && isNight) {
                             setSims(prev => prev.map(s => {
                                 if (s.state !== 'DEAD' && Math.sqrt((s.x - b.x)**2 + (s.y - b.y)**2) < 4) {
                                     if(Math.random()<0.3) setParticles(p => [...p, {x:s.x*TILE_SIZE, y:s.y*TILE_SIZE, life:10, color:'#0f0', vy:-1}]);
                                     const healAmount = hasTech('MEDICINE') ? 3 : 1;
                                     return {...s, hp: Math.min(100, s.hp + healAmount), sanity: Math.min(100, s.sanity+2), mood: Math.min(100, s.mood+1)};
                                 }
                                 return s;
                             }));
                        } else if (b.type === 'TOWER') {
                            const target = creatures.find(c => CREATURE_STATS[c.type].type === 'HOSTILE' && c.hp > 0 && Math.sqrt((c.x-b.x)**2 + (c.y-b.y)**2) < BUILDINGS.TOWER.range);
                            if (target) {
                                setProjectiles(prev => [...prev, { x: b.x, y: b.y, vx: (target.x - b.x) * 0.1, vy: (target.y - b.y) * 0.1, life: 60, ownerId: b.id, dmg: BUILDINGS.TOWER.dmg, color: PALETTE.TOOL_SPEAR }]);
                            }
                        }
                    });
                }

                setProjectiles(prev => prev.map(p => {
                    const nx = p.x + p.vx; const ny = p.y + p.vy;
                    const hitCreature = creatures.find(c => Math.abs(c.x - nx) < 0.5 && Math.abs(c.y - ny) < 0.5 && c.hp > 0);
                    if (hitCreature) {
                        hitCreature.hp -= p.dmg;
                        setParticles(pts => [...pts, { x: nx*TILE_SIZE, y: ny*TILE_SIZE, life: 10, color: '#f00', text: `-${p.dmg}` }]);
                        return null; 
                    }
                    return { ...p, x: nx, y: ny, life: p.life - 1 };
                }).filter(p => p !== null && p.life > 0));

                setCreatures(prev => prev.filter(c => c.hp > 0 || c.animFrame++ < 100));
                
                setSims(prev => {
                    let newBabies = [];
                    let resourceUpdates = { wood: 0, food: 0, stone: 0 };
                    const updatedSims = prev.map(s => {
                        if (s.state === 'DEAD') return s;
                        if (s.state === 'AI_THINKING') {
                            if (Math.random() < 0.005) return { ...s, state: 'IDLE', stateLock: 0, thought: "ÊàëÊÉ≥‰∏çÈÄö..." };
                            return s;
                        }
                        let nextS = { ...s };
                        if (nextS.stateLock > 0) nextS.stateLock--; 
                        if (nextS.buffTimer > 0) nextS.buffTimer--;
                        if (nextS.mateCooldown > 0) nextS.mateCooldown--;

                        if (tickRef.current % 10 === 0) {
                             nextS.hunger -= 0.1; nextS.energy -= 0.04;
                             if (tickRef.current % DAY_TICKS === 0) {
                                 nextS.age += 1;
                                 if (nextS.age > 60 && Math.random() < 0.05) { nextS.state = 'DEAD'; addEvent(getLog('OLD_AGE', nextS.sign)); }
                             }
                             if(isNight && nextS.state !== 'SLEEP' && nextS.state !== 'IDLE') nextS.sanity -= 0.1;
                             if(nextS.hunger <= 0) { nextS.hp -= 0.5; nextS.sanity -= 0.5; }
                             if(nextS.hp <= 0 && nextS.state !== 'DEAD') { nextS.state = 'DEAD'; addEvent(getLog('DEATH', nextS.sign)); }
                             if(nextS.sanity < 20 && Math.random() < 0.01 && nextS.state !== 'PANIC' && nextS.state !== 'INSANE') { nextS.thought = "ËÅ≤Èü≥...ÊàëËÅΩÂà∞ËÅ≤Èü≥..."; nextS.state = 'PANIC'; addEvent(getLog('PANIC', nextS.sign)); }
                             if (nextS.sanity <= 0 && nextS.state !== 'INSANE' && nextS.state !== 'DEAD') { nextS.state = 'INSANE'; nextS.stateLock = 200; nextS.thought = "‰∏çË¶Å...‰∏çË¶ÅÈÅé‰æÜÔºÅ"; addEvent(getLog('INSANITY', nextS.sign)); }
                        }

                        const isEmergencyCheck = tickRef.current % 5 === 0;
                        const isStandardCheck = nextS.state === 'IDLE' || tickRef.current % 30 === 0;

                        if ((isStandardCheck && nextS.stateLock <= 0) || isEmergencyCheck) {
                            const nearbyFriends = prev.filter(f => f.id !== nextS.id && f.state !== 'DEAD' && Math.sqrt((f.x-nextS.x)**2 + (f.y-nextS.y)**2) < 15);
                            const fightingFriend = nearbyFriends.find(f => f.state === 'DEFEND' || f.state === 'SHOOT');
                            const workingFriend = nearbyFriends.find(f => f.state === 'CHOP' || f.state === 'GATHER' || f.state === 'MINE');
                            const nearbyEnemy = creatures.find(c => CREATURE_STATS[c.type].type === 'HOSTILE' && c.hp > 0 && Math.sqrt((c.x-nextS.x)**2 + (c.y-nextS.y)**2) < 8);
                            const isReflexSituation = nearbyEnemy || fightingFriend || (nextS.hunger < 5 && tribe.food > 0) || nextS.state === 'INSANE';

                            if (isReflexSituation) {
                                if (nextS.state === 'INSANE') {
                                    if (tickRef.current % 50 === 0) nextS.hp -= 1;
                                    if (nextS.sanity > 30) { nextS.state = 'IDLE'; nextS.stateLock = 0; nextS.thought = "ÂâõÂâõÁôºÁîü‰∫Ü‰ªÄÈ∫º..."; addEvent(`${nextS.sign} ÊÅ¢Âæ©‰∫ÜÁêÜÊô∫„ÄÇ`); } 
                                    else {
                                        const r = Math.random();
                                        if (r < 0.05) {
                                            const victim = nearbyFriends.find(v => Math.sqrt((v.x-nextS.x)**2 + (v.y-nextS.y)**2) < 3);
                                            if (victim) { setProjectiles(p => [...p, { x: nextS.x, y: nextS.y, vx: (victim.x - nextS.x) * 0.2, vy: (victim.y - nextS.y) * 0.2, life: 20, ownerId: nextS.id, dmg: 5, color: '#800080' }]); addEvent(getLog('ATTACK_FRIEND', nextS.sign)); nextS.stateLock = 30; }
                                        } else if (r < 0.2) { nextS.targetX = nextS.x + rand(-5, 5); nextS.targetY = nextS.y + rand(-5, 5); nextS.stateLock = 40; }
                                        else if (r < 0.22) triggerAiThought(nextS);
                                    }
                                } else if (fightingFriend && nextS.state !== 'FLEE' && nextS.state !== 'SLEEP') {
                                    if (nextS.state !== 'DEFEND' && nextS.state !== 'SHOOT') {
                                        // COOPERATION: Lower bravery threshold if friend is fighting
                                        if (nextS.tools.spear || nextS.tools.bow || nextS.traits.bravery > 0.2) { 
                                            nextS.state = nextS.tools.bow ? 'SHOOT' : 'DEFEND'; 
                                            nextS.targetId = fightingFriend.targetId; 
                                            nextS.stateLock = 60; 
                                            nextS.thought = "Êíê‰ΩèÔºÅÊàë‰æÜ‰∫ÜÔºÅ"; 
                                        }
                                        else { nextS.state = 'FLEE'; nextS.targetX = MAP_WIDTH/2 + rand(-5, 5); nextS.targetY = MAP_HEIGHT/2 + rand(-5, 5); nextS.stateLock = 40; addEvent(getLog('FLEE', nextS.sign)); }
                                    }
                                } else if (nearbyEnemy) {
                                    const enemyName = CREATURE_STATS[nearbyEnemy.type].name || 'ÈáéÁç∏';
                                    if (nextS.tools.bow || (nextS.traits.bravery > 0.6 && nextS.hp > 50)) { nextS.state = nextS.tools.bow ? 'SHOOT' : 'DEFEND'; nextS.targetId = nearbyEnemy.id; nextS.stateLock = 50; nextS.hidden = false; addEvent(getLog('FIGHT_START', nextS.sign, "", enemyName)); }
                                    else { nextS.state = 'FLEE'; nextS.targetX = MAP_WIDTH/2 + rand(-5, 5); nextS.targetY = MAP_HEIGHT/2 + rand(-5, 5); nextS.thought = "Âø´Ë∑ëÂïäÔºÅ"; nextS.stateLock = 30; nextS.hidden = false; addEvent(getLog('FLEE', nextS.sign)); }
                                } else if (nextS.hunger < 5 && tribe.food > 0) { nextS.state = 'EAT'; nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2; nextS.stateLock = 100; }
                            } else if (userApiKey && nextS.state !== 'AI_THINKING' && isStandardCheck) {
                                nextS.state = 'AI_THINKING'; nextS.stateLock = 999;
                                const context = { simId: nextS.id, simState: { ...nextS }, tribeStats: { ...tribe }, surroundings: { tree: findNearestResource(nextS, ['TREE_OAK', 'TREE_PINE']), rock: findNearestResource(nextS, ['ROCK', 'GOLD_ROCK']), bush: findNearestResource(nextS, ['BERRY_BUSH']), friend: nearbyFriends.length > 0, friendId: nearbyFriends[0]?.id } };
                                aiRequestQueue.current.push(context);
                            } else if (!userApiKey && nextS.stateLock <= 0 && isStandardCheck) {
                                let scores = { EAT: (100 - nextS.hunger) * 3, SLEEP: (100 - nextS.energy) * (isNight ? 3 : 0.5), WORK: (nextS.energy) * (nextS.traits.diligence + 0.5) * (tribe.wood < 1000 || tribe.food < 500 || tribe.stone < 500 ? 3 : 1) + (workingFriend ? 50 : 0), SOCIAL: nextS.traits.social * (150 - nextS.mood) + (nextS.sanity < 50 ? 50 : 0) };
                                if (scores.EAT > 200 && tribe.food > 0) { nextS.state = 'EAT'; nextS.targetX = MAP_WIDTH/2 + rand(-2, 2); nextS.targetY = MAP_HEIGHT/2 + rand(-2, 2); nextS.stateLock = 100; nextS.hidden = false; }
                                else if (scores.SLEEP > 150) { nextS.state = 'SLEEP'; nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2; nextS.stateLock = 200; }
                                else if (scores.SOCIAL > 100 && tribe.food > 300) { const friend = nearbyFriends[Math.floor(Math.random() * nearbyFriends.length)]; if (friend) { nextS.state = 'APPROACH_FRIEND'; nextS.targetId = friend.id; nextS.targetX = friend.x; nextS.targetY = friend.y; nextS.stateLock = 60; nextS.hidden = false; } else { nextS.state = 'IDLE'; nextS.hidden = false; } }
                                else if (scores.WORK > 20) {
                                    const hasAxe = nextS.tools.axe; const hasPick = nextS.tools.pick; const hasSpear = nextS.tools.spear;
                                    const canCraftTools = hasTech('STONE_TOOLS'); const canCraftSpear = hasTech('HUNTING');
                                    if (tribe.food < 200 || (!hasAxe && tribe.wood < 10)) { 
                                        const bush = findNearestResource(nextS, ['BERRY_BUSH', 'BUSH']); 
                                        if (bush) { nextS.state = 'GATHER'; nextS.targetX = bush.x; nextS.targetY = bush.y; nextS.stateLock = 150; nextS.thought = "Êé°ÈõÜÊ®πÊûù..."; nextS.hidden = false; } 
                                        else { nextS.state = 'IDLE'; nextS.hidden = false; } 
                                    }
                                    else if (!hasAxe && tribe.wood >= 10 && canCraftTools) { nextS.state = 'CRAFT'; nextS.craftType = 'AXE'; nextS.targetX = MAP_WIDTH/2 + rand(-1,1); nextS.targetY = MAP_HEIGHT/2 + rand(-1,1); nextS.stateLock = 100; nextS.thought = "Ë£Ω‰ΩúÊñßÈ†≠..."; nextS.hidden = false; }
                                    else if (!hasPick && tribe.wood >= TOOL_COSTS.PICK && canCraftTools && tribe.stone < 500) { nextS.state = 'CRAFT'; nextS.craftType = 'PICK'; nextS.targetX = MAP_WIDTH/2 + rand(-1,1); nextS.targetY = MAP_HEIGHT/2 + rand(-1,1); nextS.stateLock = 100; nextS.thought = "Ë£Ω‰ΩúÈé¨Â≠ê..."; nextS.hidden = false; }
                                    else if (!hasSpear && tribe.wood >= TOOL_COSTS.SPEAR && canCraftSpear && Math.random() < 0.3) { nextS.state = 'CRAFT'; nextS.craftType = 'SPEAR'; nextS.targetX = MAP_WIDTH/2 + rand(-1,1); nextS.targetY = MAP_HEIGHT/2 + rand(-1,1); nextS.stateLock = 100; nextS.thought = "Ë£Ω‰ΩúÈï∑Áüõ..."; nextS.hidden = false; }
                                    else if (tribe.stone < 1000 && hasPick) { let target = null; if (workingFriend && workingFriend.state === 'MINE') { const nearbyRock = findNearestResource(workingFriend, ['ROCK', 'GOLD_ROCK']); if(nearbyRock) target = nearbyRock; } if (!target) target = findNearestResource(nextS, ['ROCK', 'GOLD_ROCK']); if (target) { nextS.state = 'MINE'; nextS.targetX = target.x; nextS.targetY = target.y; nextS.stateLock = 150; nextS.hidden = false; } else { nextS.state = 'IDLE'; } }
                                    else if (tribe.wood < 2000 && hasAxe) { let target = null; if (workingFriend && workingFriend.state === 'CHOP') { const nearbyTree = findNearestResource(workingFriend, ['TREE_OAK', 'TREE_PINE']); if(nearbyTree) target = nearbyTree; } if (!target) target = findNearestResource(nextS, ['TREE_OAK', 'TREE_PINE']); if (target) { nextS.state = 'CHOP'; nextS.targetX = target.x; nextS.targetY = target.y; nextS.stateLock = 150; nextS.hidden = false; } else { nextS.state = 'IDLE'; } }
                                    else { const bush = findNearestResource(nextS, ['BERRY_BUSH', 'BUSH']); if (bush && tribe.food < 1000) { nextS.state = 'GATHER'; nextS.targetX = bush.x; nextS.targetY = bush.y; nextS.stateLock = 150; nextS.hidden = false; } else { nextS.state = 'IDLE'; nextS.targetX = nextS.x + rand(-3, 3); nextS.targetY = nextS.y + rand(-3, 3); nextS.hidden = false; } }
                                }
                            }
                        }
                        
                        if (nextS.state === 'EAT' && isInBase(nextS)) { if (tribe.food > 0) { setTribe(t => ({...t, food: t.food - 1})); nextS.hunger = 100; nextS.mood += 5; nextS.state = 'IDLE'; nextS.stateLock = 0; nextS.thought = "ÂêÉÈ£Ω‰∫ÜÔºåÊ¥ªËëóÁúüÂ•Ω„ÄÇ"; } else { nextS.thought = "Ê≤íÈ£üÁâ©‰∫Ü..."; nextS.state = 'IDLE'; nextS.stateLock = 0; } }
                        else if (nextS.state === 'SLEEP') { const dist = Math.sqrt((nextS.x - MAP_WIDTH/2)**2 + (nextS.y - MAP_HEIGHT/2)**2); if (dist < 1.5) { nextS.hidden = true; nextS.energy += 0.5; nextS.sanity += 0.1; if(nextS.energy >= 100 && !isNight) { nextS.state = 'IDLE'; nextS.stateLock = 0; nextS.hidden = false; nextS.x = MAP_WIDTH/2 + rand(-2, 2); nextS.y = MAP_HEIGHT/2 + rand(-1, 2) + 2; } } else { nextS.hidden = false; const speed = 0.06; const dx = MAP_WIDTH/2 - nextS.x; const dy = MAP_HEIGHT/2 - nextS.y; const d = Math.sqrt(dx*dx + dy*dy); if (d > 0) { nextS.x += (dx/d) * speed; nextS.y += (dy/d) * speed; } } }
                        else if (nextS.state === 'APPROACH_FRIEND') { 
                            const friend = prev.find(f => f.id === nextS.targetId); 
                            if (friend && friend.state !== 'DEAD') { 
                                const dist = Math.sqrt((nextS.x - friend.x)**2 + (nextS.y - friend.y)**2); 
                                if (dist < 1.5) { 
                                    let isRomance = false; 
                                    if (nextS.age >= 18 && friend.age >= 18 && nextS.gender !== friend.gender && nextS.mateCooldown <= 0 && prev.length < MAX_POPULATION) { 
                                        const chance = (nextS.mood > 80 && friend.mood > 80) ? 0.4 : 0.1; 
                                        if (Math.random() < chance) { 
                                            isRomance = true; 
                                            nextS.state = 'LOVE'; 
                                            nextS.stateLock = 150; 
                                            nextS.mateCooldown = 3000; 
                                            nextS.thought = "üíñ Â¢úÂÖ•ÊÑõÊ≤≥..."; 
                                            if (nextS.gender === 'F') { addEvent(`üíñ ${nextS.sign} Ëàá ${friend.sign} ‰∫íÁîüÊÉÖÊÑ´`); } 
                                        } 
                                    } 
                                    if (!isRomance) { 
                                        nextS.state = 'CHAT'; 
                                        nextS.stateLock = 100; 
                                        // CHAT Logic for Non-AI
                                        const chatLines = PRE_CANNED_THOUGHTS['CHAT'];
                                        nextS.thought = chatLines[Math.floor(Math.random() * chatLines.length)];
                                        
                                        if (tickRef.current % 20 === 0) { 
                                            const emojis = ['üí¨', 'üòÇ', '‚ù§Ô∏è', 'üëã', 'üòä']; 
                                            const emoji = emojis[Math.floor(Math.random() * emojis.length)]; 
                                            setParticles(p => [...p, { x: nextS.x*TILE_SIZE, y: nextS.y*TILE_SIZE - 10, life: 60, color: '#fff', text: emoji, isThought: true }]); 
                                        } 
                                        nextS.mood = Math.min(100, nextS.mood + 0.5); 
                                        nextS.sanity = Math.min(100, nextS.sanity + 0.5); 
                                    } 
                                } else { 
                                    nextS.targetX = friend.x + (Math.sin(tickRef.current) * 0.5); 
                                    nextS.targetY = friend.y + (Math.cos(tickRef.current) * 0.5); 
                                } 
                            } else { nextS.state = 'IDLE'; nextS.stateLock = 0; } 
                        }
                        else if (nextS.state === 'LOVE') { if (tickRef.current % 15 === 0) { setParticles(p => [...p, { x: nextS.x*TILE_SIZE, y: nextS.y*TILE_SIZE - 15, life: 50, color: '#ff69b4', text: '‚ù§Ô∏è', isThought: true }]); nextS.mood = Math.min(100, nextS.mood + 1); nextS.sanity = Math.min(100, nextS.sanity + 1); } if (nextS.stateLock <= 0) { if (nextS.gender === 'F' && prev.length < MAX_POPULATION) { const baby = generateSim(null, nextS.x, nextS.y, nextS.generation + 1, 0); baby.traits.bravery = Math.min(1, Math.max(0, nextS.traits.bravery + (Math.random()*0.2 - 0.1))); newBabies.push(baby); addEvent(getLog('BIRTH', baby.sign)); setParticles(p => [...p, { x: nextS.x*TILE_SIZE, y: nextS.y*TILE_SIZE, life: 100, color: '#fff', text: 'üë∂', isThought: true }]); } nextS.state = 'IDLE'; } }
                        else if (nextS.state === 'CHAT') { if (tickRef.current % 20 === 0) { nextS.mood = Math.min(100, nextS.mood + 0.5); nextS.sanity = Math.min(100, nextS.sanity + 0.5); } if (nextS.stateLock <= 0) nextS.state = 'IDLE'; }
                        else if (nextS.state === 'SHOOT' || nextS.state === 'DEFEND') { const target = creatures.find(c => c.id === nextS.targetId && c.hp > 0); if (target) { const dist = Math.sqrt((nextS.x-target.x)**2 + (nextS.y-target.y)**2); const range = nextS.state === 'SHOOT' ? 4 : 1.2; if (dist > range) { const speed = 0.08; nextS.x += Math.sign(target.x - nextS.x) * speed; nextS.y += Math.sign(target.y - nextS.y) * speed; } else if (nextS.state === 'SHOOT' && dist < 3) { nextS.x -= Math.sign(target.x - nextS.x) * 0.05; nextS.y -= Math.sign(target.y - nextS.y) * 0.05; } if (tickRef.current % 30 === 0) { if (nextS.state === 'SHOOT') { setProjectiles(p => [...p, { x: nextS.x, y: nextS.y, vx: (target.x - nextS.x) * 0.15, vy: (target.y - nextS.y) * 0.15, life: 50, ownerId: nextS.id, dmg: 15, color: PALETTE.TOOL_SPEAR }]); } else { target.hp -= 10; setParticles(p => [...p, { x:target.x*TILE_SIZE, y:target.y*TILE_SIZE, life:10, color:'#f00', text:'üí•'}]); } } } else { nextS.state = 'IDLE'; nextS.stateLock = 0; } }

                        if (nextS.targetX !== null && !['SLEEP','EAT_ACTION','CHAT','SHOOT','DEFEND','CRAFT'].includes(nextS.state)) {
                             const dx = nextS.targetX - nextS.x; const dy = nextS.targetY - nextS.y;
                             if (Math.abs(dx) < 0.2 && Math.abs(dy) < 0.2) { 
                                 if(['CHOP','GATHER','MINE'].includes(nextS.state)) {
                                     const ironBonus = hasTech('IRON') ? 10 : 0; const gatherBonus = hasTech('GATHERING') ? 2 : 0; const farmBonus = hasTech('FARMING') ? 3 : 0;
                                     
                                     // Use timeout to break out of reducer for state update
                                     const woodGain = nextS.state==='CHOP' ? 20 + ironBonus : (nextS.state==='GATHER' ? 3 : 0);
                                     const foodGain = nextS.state==='GATHER' ? 8 + gatherBonus + farmBonus : 0;
                                     const stoneGain = nextS.state==='MINE' ? 10 + ironBonus : 0;
                                     
                                     resourceUpdates.wood += woodGain;
                                     resourceUpdates.food += foodGain;
                                     resourceUpdates.stone += stoneGain;
                                     
                                     // Add particle for feedback
                                     setParticles(p => [...p, { x: nextS.x*TILE_SIZE, y: nextS.y*TILE_SIZE-10, life: 40, color: '#fff', text: `+${woodGain||foodGain||stoneGain}` }]);
                                     
                                     nextS.energy -= 10; nextS.targetX = null; nextS.state = 'IDLE'; nextS.stateLock = 0; 
                                 } else { nextS.targetX = null; }
                             } else { const speed = (nextS.state === 'DEFEND' || nextS.state === 'SHOOT') ? 0.08 : 0.06; nextS.x += Math.sign(dx) * speed; nextS.y += Math.sign(dy) * speed; }
                        }
                        
                        if (nextS.state === 'CRAFT') { if (nextS.targetX !== null) { const dx = nextS.targetX - nextS.x; const dy = nextS.targetY - nextS.y; if (Math.abs(dx) < 0.2 && Math.abs(dy) < 0.2) { if (nextS.stateLock <= 0) { if (nextS.craftType === 'AXE' && tribe.wood >= TOOL_COSTS.AXE) { setTribe(t => ({...t, wood: t.wood - TOOL_COSTS.AXE})); nextS.tools.axe = true; addEvent(`${nextS.sign} Ë£Ω‰Ωú‰∫ÜÊñßÈ†≠`); } else if (nextS.craftType === 'PICK' && tribe.wood >= TOOL_COSTS.PICK) { setTribe(t => ({...t, wood: t.wood - TOOL_COSTS.PICK})); nextS.tools.pick = true; addEvent(`${nextS.sign} Ë£Ω‰Ωú‰∫ÜÈé¨Â≠ê`); } else if (nextS.craftType === 'SPEAR' && tribe.wood >= TOOL_COSTS.SPEAR) { setTribe(t => ({...t, wood: t.wood - TOOL_COSTS.SPEAR})); nextS.tools.spear = true; addEvent(`${nextS.sign} Ë£Ω‰Ωú‰∫ÜÈï∑Áüõ`); } nextS.state = 'IDLE'; nextS.craftType = null; } } else { const speed = 0.06; nextS.x += Math.sign(dx) * speed; nextS.y += Math.sign(dy) * speed; } } }

                        prev.forEach(other => { if (other.id !== nextS.id && other.state !== 'DEAD') { const dist = Math.sqrt((nextS.x - other.x)**2 + (nextS.y - other.y)**2); if (dist < 0.6) { const pushX = nextS.x - other.x; const pushY = nextS.y - other.y; const force = 0.03; if (pushX !== 0 || pushY !== 0) { nextS.x += (pushX / dist) * force; nextS.y += (pushY / dist) * force; } else { nextS.x += (Math.random() - 0.5) * force; nextS.y += (Math.random() - 0.5) * force; } } } });
                        nextS.x = clamp(nextS.x, 2, MAP_WIDTH-3); nextS.y = clamp(nextS.y, 2, MAP_HEIGHT-3);
                        return nextS;
                    });
                    
                    // Apply collected resource updates
                    if (resourceUpdates.wood > 0 || resourceUpdates.food > 0 || resourceUpdates.stone > 0) {
                        setTimeout(() => {
                            setTribe(t => ({
                                ...t,
                                wood: t.wood + resourceUpdates.wood,
                                food: t.food + resourceUpdates.food,
                                stone: t.stone + resourceUpdates.stone
                            }));
                        }, 0);
                    }
                    
                    return [...updatedSims, ...newBabies];
                });

                setCreatures(prev => prev.map(c => {
                    if (c.hp <= 0) return null;
                    let nextC = { ...c };
                    const stats = CREATURE_STATS[c.type];
                    const target = sims.find(s => s.state !== 'DEAD' && !s.hidden && Math.sqrt((s.x-c.x)**2+(s.y-c.y)**2) < 5);
                    if (target && stats.type === 'HOSTILE') { const dx = target.x - c.x; const dy = target.y - c.y; nextC.x += Math.sign(dx) * 0.04; nextC.y += Math.sign(dy) * 0.04; if (Math.sqrt(dx*dx+dy*dy) < 1 && tickRef.current % 20 === 0) { target.hp -= stats.dmg; target.sanity -= 5; setParticles(p => [...p, { x:target.x*TILE_SIZE, y:target.y*TILE_SIZE, life:10, color:'#f00', text:'üí•'}]); } } 
                    else if (Math.random() < 0.02) { nextC.x += rand(-1,1); nextC.y += rand(-1,1); }
                    nextC.x = clamp(nextC.x, 2, MAP_WIDTH-3); nextC.y = clamp(nextC.y, 2, MAP_HEIGHT-3);
                    return nextC;
                }).filter(Boolean));

                setParticles(prev => prev.map(p => ({...p, x: p.x + (p.vx||0), y: p.y + (p.vy||0), life: p.life-1})).filter(p => p.life > 0));
            }, [isGameOver, time, disaster, buildings, projectiles, sims, creatures, tribe, map]); 

            const drawSim = (ctx, s) => {
                if (s.state === 'DEAD') { const px = Math.floor(s.x * TILE_SIZE); const py = Math.floor(s.y * TILE_SIZE); ctx.drawImage(sprites.skull, px + 4, py + 10); return; }
                const px = Math.floor(s.x * TILE_SIZE); const py = Math.floor(s.y * TILE_SIZE);
                const bounce = (s.state !== 'IDLE') ? Math.sin(s.animFrame) * 2 : 0;
                const matrix = s.gender === 'M' ? SPRITE_MATRICES.CHAR_M : SPRITE_MATRICES.CHAR_F;
                ctx.save();
                if (s.age < 16) { const scale = 0.7; ctx.translate(px + TILE_SIZE/2, py + TILE_SIZE/2); ctx.scale(scale, scale); ctx.translate(-(px + TILE_SIZE/2), -(py + TILE_SIZE/2)); }
                renderMatrix(ctx, matrix, { 'H': s.hair, 'S': PALETTE.SKIN, 's': PALETTE.SKIN_SHADOW, 'C': s.color, 'K': PALETTE.OUTLINE }, px + 4, py + 4 + bounce);
                if (s.tools.bow) { ctx.fillStyle = '#8d6e63'; ctx.save(); ctx.translate(px+16, py+16); ctx.rotate(s.state==='SHOOT'?Math.random()*0.5:0); ctx.fillRect(-8, 0, 16, 2); ctx.fillRect(-8, -8, 2, 16); ctx.restore(); }
                else if (s.tools.spear) { ctx.fillStyle = PALETTE.TOOL_SPEAR; ctx.fillRect(px+24, py+4+bounce, 2, 16); }
                ctx.restore();
                let actionIcon = '';
                if (s.state === 'EAT') actionIcon = 'üçñ'; else if (s.state === 'SLEEP') actionIcon = 'üí§'; else if (s.state === 'CHOP') actionIcon = 'ü™ì'; else if (s.state === 'MINE') actionIcon = '‚õèÔ∏è'; else if (s.state === 'GATHER') actionIcon = 'üçé'; else if (s.state === 'CHAT') actionIcon = 'üí¨'; else if (s.state === 'LOVE') actionIcon = 'üíñ'; else if (s.state === 'FLEE') actionIcon = 'üèÉ'; else if (s.state === 'PANIC') actionIcon = 'üò±'; else if (s.state === 'INSANE') actionIcon = 'üåÄ'; else if (s.state === 'CRAFT') actionIcon = 'üî®'; else if (s.state === 'AI_THINKING') actionIcon = 'üí≠'; else if (s.state === 'DEFEND' || s.state === 'SHOOT') actionIcon = '‚öîÔ∏è';
                if (actionIcon) { ctx.font = '10px sans-serif'; ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.fillText(actionIcon, px + TILE_SIZE/2, py - 5); }
            };

            const drawCreature = (ctx, c) => {
                const px = Math.floor(c.x * TILE_SIZE); const py = Math.floor(c.y * TILE_SIZE);
                let matrix = SPRITE_MATRICES[c.type] || SPRITE_MATRICES.RABBIT;
                let colors = {'W': PALETTE.FUR_RABBIT, 'G': PALETTE.FUR_WOLF, 'B': PALETTE.FUR_BEAR, 'K': PALETTE.OUTLINE, 'Y': PALETTE.DINO_EYE, 'O': PALETTE.FUR_FOX, 'D': PALETTE.SKIN_PIG};
                if (c.type === 'DINOSAUR') colors.G = PALETTE.DINO_GREEN; if (c.type === 'SHEEP') colors.W = PALETTE.FUR_SHEEP; if (c.type === 'COW') { colors.W = PALETTE.WHITE; colors.B = PALETTE.OUTLINE; }
                ctx.save(); 
                if (c.dir < 0) { const width = c.type === 'DINOSAUR' ? TILE_SIZE * 2 : TILE_SIZE; ctx.translate(px + width, 0); ctx.scale(-1, 1); ctx.translate(-px, 0); }
                renderMatrix(ctx, matrix, colors, px, py);
                const maxHp = CREATURE_STATS[c.type].hp;
                if (c.hp < maxHp) { const barWidth = c.type === 'DINOSAUR' ? 64 : 32; ctx.fillStyle='red'; ctx.fillRect(px, py-4, barWidth, 3); ctx.fillStyle='#0f0'; ctx.fillRect(px, py-4, barWidth * (c.hp / maxHp), 3); }
                ctx.restore();
            };

            const draw = useCallback(() => {
                const canvas = canvasRef.current; if (!canvas || !sprites) return;
                const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
                ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save(); ctx.scale(SCALE, SCALE);
                if (shake > 0) ctx.translate(shake, shake);

                map.forEach(row => row.forEach(tile => {
                    const px = tile.x * TILE_SIZE; const py = tile.y * TILE_SIZE;
                    if (tile.type === 'SAND') ctx.drawImage(sprites.sand, px, py);
                    else if (tile.type === 'MOUNTAIN_GROUND') ctx.drawImage(sprites.mountain, px, py);
                    else if (tile.type === 'WATER') { ctx.fillStyle = PALETTE.WATER; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
                    else if (tile.type === 'DIRT') ctx.drawImage(sprites.dirt, px, py);
                    else ctx.drawImage(sprites.grass, px, py);
                }));

                buildings.forEach(b => {
                    const px = b.x * TILE_SIZE; const py = b.y * TILE_SIZE;
                    const sprite = sprites[BUILDINGS[b.type].sprite];
                    if(sprite) ctx.drawImage(sprite, px, py - 8);
                });

                const objects = [];
                map.forEach(row => row.forEach(tile => { if (tile.decoration) objects.push({ y: tile.y, type: 'DECO', subtype: tile.decoration, x: tile.x }); }));
                sims.forEach(sim => { if(!sim.hidden) objects.push({ y: sim.y, type: 'SIM', data: sim }) });
                creatures.forEach(c => objects.push({ y: c.y, type: 'CREATURE', data: c }));
                objects.sort((a, b) => a.y - b.y);

                objects.forEach(obj => {
                    const px = obj.x * TILE_SIZE; const py = obj.y * TILE_SIZE;
                    if (obj.type === 'DECO') {
                        if (obj.subtype === 'BASE') ctx.drawImage(sprites[currentStage.sprite], px - 16, py - 24);
                        else if (obj.subtype === 'TREE_OAK') ctx.drawImage(sprites.tree_oak, px, py - TILE_SIZE);
                        else if (obj.subtype === 'TREE_PINE') ctx.drawImage(sprites.tree_pine, px, py - TILE_SIZE);
                        else if (obj.subtype === 'ROCK') ctx.drawImage(sprites.rock, px, py);
                        else if (obj.subtype === 'GOLD_ROCK') ctx.drawImage(sprites.gold_rock, px, py);
                        else if (obj.subtype === 'BUSH') ctx.drawImage(sprites.bush, px, py);
                        else if (obj.subtype === 'BERRY_BUSH') ctx.drawImage(sprites.berry_bush, px, py);
                        else if (obj.subtype === 'FLOWER') ctx.drawImage(sprites.flower, px, py);
                        else if (obj.subtype === 'MUSHROOM') ctx.drawImage(sprites.mushroom, px, py);
                    } else if (obj.type === 'SIM') drawSim(ctx, obj.data);
                    else if (obj.type === 'CREATURE') drawCreature(ctx, obj.data);
                });

                projectiles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.beginPath(); ctx.arc(p.x * TILE_SIZE, p.y * TILE_SIZE, 3, 0, Math.PI*2); ctx.fill();
                });

                if (selectedId && selectedId !== 'BASE_CENTER') {
                    const target = [...sims, ...creatures, ...buildings].find(i => i.id === selectedId);
                    if (target && !target.hidden) {
                        const px = target.x * TILE_SIZE; const py = target.y * TILE_SIZE;
                        ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1.5; ctx.setLineDash([4, 2]);
                        ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE); 
                        ctx.setLineDash([]);
                    }
                }

                particles.forEach(p => {
                    if (p.isThought) {
                         ctx.save(); 
                         ctx.font = '10px sans-serif';
                         ctx.textAlign = 'center';
                         ctx.textBaseline = 'middle';
                         const textMetrics = ctx.measureText(p.text);
                         const w = textMetrics.width;
                         const h = 14;
                         const padding = 6;
                         const bx = p.x - w/2 - padding;
                         const by = p.y - 20; 
                         ctx.beginPath();
                         if (ctx.roundRect) ctx.roundRect(bx, by, w + padding*2, h, 4); else ctx.rect(bx, by, w + padding*2, h);
                         ctx.fillStyle = 'rgba(0,0,0,0.75)';
                         ctx.fill();
                         ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                         ctx.lineWidth = 1;
                         ctx.stroke();
                         ctx.fillStyle = 'white';
                         ctx.fillText(p.text, p.x, by + h/2);
                         ctx.restore(); 
                    } else if (p.text) { 
                        ctx.save();
                        ctx.font = '12px serif'; 
                        ctx.textAlign = 'center';
                        ctx.fillStyle = p.color; 
                        ctx.fillText(p.text, p.x, p.y); 
                        ctx.restore();
                    } else { 
                        ctx.fillStyle = p.color; 
                        ctx.fillRect(p.x, p.y, 2, 2); 
                    }
                });

                if (disaster.color) { ctx.fillStyle = disaster.color; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); }
                if (weather.color) { ctx.fillStyle = weather.color; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); }

                if (weather.id === 'RAIN' || weather.id === 'SNOW') {
                    ctx.save();
                    ctx.strokeStyle = weather.id === 'RAIN' ? 'rgba(150,150,255,0.4)' : 'rgba(255,255,255,0.6)';
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    ctx.lineWidth = 1;
                    const timeOffset = Date.now() / 10;
                    for(let i=0; i<100; i++) {
                        const rx = ((i * 135724 + timeOffset * 2) % (MAP_WIDTH * TILE_SIZE));
                        const ry = ((i * 9283 + timeOffset * (weather.id==='RAIN'?5:2)) % (MAP_HEIGHT * TILE_SIZE));
                        ctx.beginPath();
                        if (weather.id === 'RAIN') { ctx.moveTo(rx, ry); ctx.lineTo(rx - 2, ry + 10); ctx.stroke(); } 
                        else { ctx.fillRect(rx, ry, 2, 2); }
                    }
                    ctx.restore();
                }

                if (time > DAY_TICKS * 0.6 || disaster.id === 'DARKNESS') { 
                    const alpha = disaster.id === 'DARKNESS' ? 0.9 : 0.5;
                    ctx.fillStyle = `rgba(10, 10, 30, ${alpha})`; 
                    ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); 
                }

                if (flash > 0) { ctx.fillStyle = `rgba(255, 255, 200, ${flash * 0.3})`; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); }
                ctx.restore();
            }, [map, sprites, sims, creatures, buildings, projectiles, particles, time, selectedId, tribe, disaster, shake, currentStage, buildMode, flash, weather]);

            useEffect(() => {
                const loop = () => {
                    tickRef.current++;
                    if (tickRef.current % 5 === 0) { setTime(t => (t + 1) % DAY_TICKS); if (time === 0) setDay(d => d+1); update(); }
                    draw(); requestRef.current = requestAnimationFrame(loop);
                };
                requestRef.current = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(requestRef.current);
            }, [draw, update]);

            const handleSimClick = (simId) => {
                setSelectedId(simId);
                if (simId === 'BASE_CENTER') return;
                const sim = sims.find(s => s.id === simId);
                const cooldown = userApiKey ? 10000 : 1000;
                if (sim && Date.now() - (sim.lastThoughtTime || 0) > cooldown) {
                    triggerAiThought(sim);
                }
            };

            const handleCanvasClick = useCallback((e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / SCALE / TILE_SIZE);
                const y = Math.floor((e.clientY - rect.top) / SCALE / TILE_SIZE);
                
                if (buildMode) {
                    const cost = BUILDINGS[buildMode].cost;
                    if (tribe.wood >= cost.wood && tribe.stone >= cost.stone) {
                        setBuildings(prev => [...prev, { id: Date.now(), type: buildMode, x, y, hp: BUILDINGS[buildMode].hp }]);
                        setTribe(t => ({...t, wood: t.wood - cost.wood, stone: t.stone - cost.stone}));
                        addEvent(`Âª∫ÈÄ†‰∫Ü ${BUILDINGS[buildMode].name}`);
                        setBuildMode(null);
                    } else {
                        addEvent(`Ë≥áÊ∫ê‰∏çË∂≥ÔºÅÈúÄ Êú®${cost.wood} Áü≥${cost.stone}`);
                        setBuildMode(null);
                    }
                    return;
                }

                const clickX = (e.clientX - rect.left) / SCALE / TILE_SIZE;
                const clickY = (e.clientY - rect.top) / SCALE / TILE_SIZE;
                let closest = null; let minDist = 2.5;
                
                const targets = [
                    ...sims.filter(s => !s.hidden).map(s => ({...s, type: 'SIM'})), 
                    ...creatures.map(c => ({...c, type: 'CREATURE'})),
                    ...buildings.map(b => ({...b, type: 'BUILDING'}))
                ];

                targets.forEach(obj => { 
                    const d = Math.sqrt((obj.x+0.5-clickX)**2 + (obj.y+0.5-clickY)**2); 
                    if(d<minDist){ closest=obj; minDist=d; } 
                });
                
                if (closest) {
                    if (closest.type === 'BUILDING') {
                         setSelectedId(closest.id);
                    } else {
                         handleSimClick(closest.id);
                    }
                } else if (Math.sqrt((clickX-MAP_WIDTH/2)**2+(clickY-MAP_HEIGHT/2)**2) < 2.5) {
                    setSelectedId('BASE_CENTER');
                } else {
                    setSelectedId(null);
                }
            }, [sims, creatures, buildMode, tribe, userApiKey, buildings]);

            const selectedObj = [...sims, ...creatures, ...buildings].find(s => s.id === selectedId);
            const isBuilding = selectedObj && selectedObj.type && BUILDINGS[selectedObj.type];
            const isCreature = selectedObj && selectedObj.type && CREATURE_STATS[selectedObj.type];
            const isSim = selectedObj && selectedObj.sign;

            return (
                <div className={`flex flex-col h-[100dvh] bg-[#1a1c2c] text-[#c2c3c7] relative ${buildMode ? 'build-cursor' : ''}`} style={{ fontFamily: PIXEL_FONT }}>
                    {/* Top Bar */}
                    <div className="bg-[#292b3c] p-2 border-b-4 border-[#121215] flex justify-between items-center shadow-lg shrink-0 z-20">
                        <div className="flex gap-4 items-center">
                            <div className="text-[#ffcd75] font-bold flex items-center gap-2" title="Á•ûÂäõ (Mana)"><Icons.Sparkles size={16}/> {Math.floor(mana)}</div>
                            
                            {/* Resources Panel (New) */}
                            <div className="flex gap-3 text-xs font-mono bg-black/30 px-3 py-1 rounded border border-gray-700">
                                <div className="text-[#8d6e63] flex items-center gap-1" title="Êú®Êùê">ü™µ {Math.floor(tribe.wood)}</div>
                                <div className="text-gray-400 flex items-center gap-1" title="Áü≥Êùê">ü™® {Math.floor(tribe.stone)}</div>
                                <div className="text-orange-400 flex items-center gap-1" title="È£üÁâ©">üçñ {Math.floor(tribe.food)}</div>
                            </div>

                            <div className="bg-black/40 px-3 py-1 rounded text-sm flex items-center gap-2 hidden md:flex">
                                <span className="text-2xl">{currentStage.icon}</span>
                                <div><div className="text-[10px] text-gray-400">Day {day}</div><div className="text-white font-bold">{currentStage.name}</div></div>
                            </div>
                        </div>
                        <div className="flex gap-3 items-center">
                            <button onClick={() => setShowApiKeyInput(!showApiKeyInput)} className="text-xs bg-purple-900/50 hover:bg-purple-800 text-purple-200 px-2 py-1 rounded border border-purple-500 flex items-center gap-1">
                                <Icons.Key size={12}/> {userApiKey ? 'AI Â∑≤ÈÄ£Áµê' : 'ÈÄ£Áµê AI'}
                            </button>
                            <span className="text-xs font-bold text-[#8b9bb4] flex items-center gap-1"><Icons.Users size={12}/> {sims.filter(s=>s.state!=='DEAD').length}/{MAX_POPULATION}</span>
                        </div>
                    </div>
                    
                    {/* NEW: Save Effect Overlay */}
                    {isSaving && (
                        <div className="absolute top-14 right-4 z-40 pointer-events-none flex items-center justify-end animate-bounce transition-opacity duration-500">
                            <div className="bg-green-900/90 text-green-100 border border-green-500 px-3 py-1 rounded-full text-xs flex items-center gap-2 shadow-lg backdrop-blur-sm">
                                <Icons.Save size={14} className="animate-pulse"/> 
                                <span>Á≥ªÁµ±Â≠òÊ™î‰∏≠...</span>
                            </div>
                        </div>
                    )}

                    {/* API Key Modal */}
                    {showApiKeyInput && (
                        <div className="absolute top-14 right-4 z-50 bg-[#292b3c] p-4 rounded shadow-xl border border-gray-600 w-64">
                            <h3 className="text-white text-sm mb-2 font-bold">ÈÄ£Áµê Google Gemini AI</h3>
                            <p className="text-[10px] text-gray-400 mb-2">Ëº∏ÂÖ• API Key ‰ª•ÂïüÁî®Êóè‰∫∫Áç®Á´ãÊÄùÊÉ≥Ëàá AI Ë°åÁÇ∫Ê±∫Á≠ñ„ÄÇ</p>
                            <input 
                                type="password" 
                                value={userApiKey} 
                                onChange={(e) => setUserApiKey(e.target.value)} 
                                placeholder="Paste API Key here..."
                                className="w-full bg-black text-white text-xs p-2 rounded border border-gray-700 mb-2"
                            />
                            <button onClick={() => setShowApiKeyInput(false)} className="w-full bg-green-700 text-white text-xs py-1 rounded">Á¢∫Ë™ç</button>
                        </div>
                    )}

                    {/* Main Game Area */}
                    <div className="flex-1 flex flex-col md:flex-row overflow-hidden relative">
                        {isGameOver && (
                            <div className="absolute inset-0 z-[60] bg-black/90 flex flex-col items-center justify-center animate-in fade-in zoom-in">
                                <h1 className="text-4xl text-red-500 font-bold mb-8">ÊñáÊòéÊÆûËêΩ</h1>
                                <button onClick={startNextEra} className="bg-red-900 px-8 py-4 rounded border-2 border-red-500 text-white flex items-center gap-2 hover:bg-red-800"><Icons.RefreshCw/> ÈáçÂïüÊñáÊòé</button>
                            </div>
                        )}
                        
                        <div className="relative flex-1 bg-black overflow-hidden flex">
                            {/* MOVED: Overlays are now inside the canvas area to prevent blocking sidebar */}
                            {buildMode && (
                                <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-yellow-900/80 text-yellow-200 px-4 py-2 rounded z-50 border border-yellow-500 animate-pulse pointer-events-none">
                                    Âª∫ÈÄ†Ê®°ÂºèÔºöË´ãÈªûÊìäÂú∞ÂúñÁ©∫Âú∞
                                </div>
                            )}

                            <div className="w-full h-full overflow-auto flex items-center justify-center p-4 bg-[#0d0d10]">
                                <canvas ref={canvasRef} width={MAP_WIDTH * TILE_SIZE * SCALE} height={MAP_HEIGHT * TILE_SIZE * SCALE} onClick={handleCanvasClick} className="border-4 border-[#3e2723] shadow-2xl cursor-crosshair" style={{ imageRendering: 'pixelated' }} />
                            </div>
                            
                            {/* Log */}
                            <div className={`absolute bottom-4 left-4 w-72 flex flex-col gap-1 z-30 transition-all duration-300 ${isLogOpen ? 'max-h-64' : 'max-h-10'}`}>
                                <div className="flex justify-between items-center bg-[#292b3c] p-1 rounded-t border-t border-l border-r border-[#5d4037] cursor-pointer shadow-lg" onClick={() => setIsLogOpen(!isLogOpen)}>
                                    <span className="text-xs text-[#ffcd75] font-bold px-2">üìú Ê≠∑Âè≤Á¥ÄÈåÑ</span>
                                    <button className="text-gray-400 hover:text-white px-2">
                                        {isLogOpen ? <Icons.ChevronDown size={14}/> : <Icons.ChevronUp size={14}/>}
                                    </button>
                                </div>
                                {isLogOpen && <div className="bg-black/80 p-2 overflow-y-auto h-48 rounded-b border-b border-l border-r border-[#5d4037] scrollbar-thin pointer-events-auto touch-pan-y shadow-xl">
                                     {events.map((ev) => <div key={ev.id} className="log-item text-white px-2 py-1 text-xs border-b border-gray-800 last:border-0">{ev.text}</div>)}
                                     <div ref={logEndRef} />
                                </div>}
                            </div>
                        </div>

                        {/* Sidebar - Added overflow-y-auto to fix blocked content */}
                        <div className="w-full h-[45vh] md:w-72 md:h-full bg-[#292b3c] border-t-4 md:border-t-0 md:border-l-4 border-[#121215] p-2 md:p-3 flex flex-col gap-2 md:gap-3 shadow-2xl z-20 shrink-0 overflow-y-auto">
                            {(!selectedId || selectedId === 'BASE_CENTER') ? (
                                <>
                                    {/* NEW: Base Status Panel - Enhanced */}
                                    <div className="bg-[#1a1c2c] p-3 rounded border border-[#3e2723] shadow-md shrink-0">
                                        <div className="flex items-center gap-3 mb-3 border-b border-[#3e2723] pb-2">
                                            <div className="text-3xl bg-black/40 p-2 rounded border border-gray-700">{currentStage.icon}</div>
                                            <div className="flex-1">
                                                <h3 className="text-[#ffcd75] text-base font-bold leading-tight">ÈÉ®ËêΩÂ§ßÊú¨Ááü</h3>
                                                <div className="text-xs text-gray-400">{currentStage.name}</div>
                                            </div>
                                        </div>
                                        
                                        <div className="space-y-3 text-xs">
                                            {/* Population Bar */}
                                            <div>
                                                <div className="flex justify-between mb-1 text-gray-300">
                                                    <span>üë• ‰∫∫Âè£ÂÆπÈáè</span>
                                                    <span>{sims.filter(s=>s.state!=='DEAD').length} / {currentStage.stats.cap}</span>
                                                </div>
                                                <div className="h-1.5 bg-gray-800 rounded-full overflow-hidden">
                                                    <div 
                                                        className="h-full bg-gradient-to-r from-blue-600 to-blue-400 rounded-full transition-all duration-500" 
                                                        style={{width: `${Math.min(100, (sims.filter(s=>s.state!=='DEAD').length / currentStage.stats.cap) * 100)}%`}}
                                                    ></div>
                                                </div>
                                            </div>

                                            {/* Stats Grid */}
                                            <div className="grid grid-cols-3 gap-2">
                                                <div className="bg-[#121215] p-1.5 rounded text-center border border-gray-800">
                                                    <div className="text-[10px] text-gray-500 mb-0.5">Èò≤Á¶¶</div>
                                                    <div className="text-white font-mono text-sm">üõ°Ô∏è{currentStage.stats.def}</div>
                                                </div>
                                                <div className="bg-[#121215] p-1.5 rounded text-center border border-gray-800">
                                                    <div className="text-[10px] text-gray-500 mb-0.5">ÊÅ¢Âæ©</div>
                                                    <div className="text-white font-mono text-sm">üíö+{currentStage.stats.heal}</div>
                                                </div>
                                                <div className="bg-[#121215] p-1.5 rounded text-center border border-gray-800">
                                                    <div className="text-[10px] text-gray-500 mb-0.5">Âª∫ÁØâ</div>
                                                    <div className="text-white font-mono text-sm">üè†{buildings.length}</div>
                                                </div>
                                            </div>
                                            
                                            <div className="text-[10px] text-gray-500 italic bg-black/20 p-2 rounded border border-gray-800/50">
                                                "{currentStage.desc}"
                                            </div>
                                        </div>
                                    </div>

                                    {/* Build Menu */}
                                    <div className="bg-[#1a1c2c] p-2 rounded border border-[#3e2723] shrink-0">
                                        <h3 className="text-[#ffcd75] text-sm mb-2 font-bold border-b border-[#3e2723] pb-1 flex justify-between items-center">
                                            <span>üî® Âü∫Âú∞Âª∫Ë®≠</span>
                                            <span className="text-[10px] text-gray-500">ÈªûÊìäÂª∫ÈÄ†</span>
                                        </h3>
                                        <div className="space-y-2 max-h-32 overflow-y-auto pr-1 scrollbar-thin">
                                            {Object.keys(BUILDINGS).map(key => {
                                                const b = BUILDINGS[key];
                                                const hasReq = !b.reqTech || hasTech(b.reqTech);
                                                const canBuild = hasReq && tribe.wood >= b.cost.wood && tribe.stone >= b.cost.stone;
                                                return (
                                                    <button key={key} onClick={() => handleBuild(key)} disabled={!canBuild && hasReq} className={`w-full text-left p-2 rounded border text-xs flex justify-between items-center group transition-all ${canBuild ? 'bg-[#2d2a26] border-[#5d4037] hover:bg-[#3e2723] hover:border-yellow-600' : 'bg-gray-900 border-gray-800 opacity-50 cursor-not-allowed'}`}>
                                                        <div>
                                                            <div className={`font-bold ${canBuild ? 'text-gray-200 group-hover:text-yellow-200' : 'text-gray-600'}`}>
                                                                {b.name}
                                                            </div>
                                                            <div className="text-[10px] text-gray-500">
                                                                {!hasReq ? `üîí ÈúÄË¶Å [${TECH_TREE.find(t=>t.id===b.reqTech).name}]` : b.desc}
                                                            </div>
                                                        </div>
                                                        <div className="text-right text-[10px]">
                                                            <div className={tribe.wood >= b.cost.wood ? "text-[#8d6e63]" : "text-red-500"}>ü™µ {b.cost.wood}</div>
                                                            <div className={tribe.stone >= b.cost.stone ? "text-gray-400" : "text-red-500"}>ü™® {b.cost.stone}</div>
                                                        </div>
                                                    </button>
                                                )
                                            })}
                                        </div>
                                    </div>
                                    
                                    <div className="bg-[#1a1c2c] p-2 rounded border border-[#3e2723] flex-1 flex flex-col min-h-[120px] shrink-0">
                                        <h3 className="text-[#8b9bb4] text-sm mb-2 font-bold border-b border-[#3e2723] pb-1">‚ö° Á•ûË´≠</h3>
                                        <div className="grid grid-cols-4 gap-2 mt-auto">
                                            <button onClick={() => castSpell('SUN')} className="btn bg-[#2d2a26] hover:bg-[#3e2723] border border-[#5d4037] p-2 rounded flex flex-col items-center justify-center gap-1 transition-colors" title="Á•àÁ¶±Êô¥Â§© (Ê∂àËÄó 20)">
                                                <Icons.Sun className="text-yellow-400" size={18}/>
                                                <span className="text-[9px] text-gray-400">Á•àÊô¥</span>
                                            </button>
                                            <button onClick={() => castSpell('RAIN')} className="btn bg-[#2d2a26] hover:bg-[#3e2723] border border-[#5d4037] p-2 rounded flex flex-col items-center justify-center gap-1 transition-colors" title="Á•àÁ¶±Èõ®Â§© (Ê∂àËÄó 20)">
                                                <Icons.CloudRain className="text-blue-400" size={18}/>
                                                <span className="text-[9px] text-gray-400">Á•àÈõ®</span>
                                            </button>
                                            
                                            {/* Tech Button with Next Tech Preview */}
                                            <button onClick={() => castSpell('TECH')} disabled={tribe.tech>=TECH_TREE.length} className="btn bg-[#2d2a26] hover:bg-[#3e2723] border border-[#5d4037] p-2 rounded relative group flex flex-col items-center justify-center gap-1 transition-colors disabled:opacity-50">
                                                <Icons.Brain className="text-purple-400" size={18}/>
                                                <span className="text-[9px] text-gray-400">ÂïüÁôº</span>
                                                <div className="absolute bottom-full left-1/2 -translate-x-1/2 bg-black/90 text-white text-[10px] px-2 py-1 rounded opacity-0 group-hover:opacity-100 whitespace-nowrap border border-gray-700 z-50 pointer-events-none mb-1">
                                                    {tribe.tech < TECH_TREE.length ? (
                                                        <>
                                                            <div className="font-bold text-yellow-300 mb-0.5">Á†îÁôº: {TECH_TREE[tribe.tech].icon} {TECH_TREE[tribe.tech].name}</div>
                                                            <div className="text-gray-300">{TECH_TREE[tribe.tech].desc}</div>
                                                            <div className="text-purple-300 mt-0.5">Ê∂àËÄó: 50 MP</div>
                                                        </>
                                                    ) : "ÁßëÊäÄÂ∑≤ÈÅîÂ∑îÂ≥∞"}
                                                </div>
                                            </button>

                                            <button onClick={() => castSpell('DISASTER')} disabled={mana < 100} className="bg-[#2d1a1a] hover:bg-[#3e1a1a] border border-red-900/50 p-2 rounded flex flex-col items-center justify-center gap-1 transition-colors disabled:opacity-30" title="Èôç‰∏ãÁÅΩÈõ£ (Ê∂àËÄó 100)">
                                                <Icons.Biohazard className="text-red-500" size={18}/>
                                                <span className="text-[9px] text-red-400">Â§©ÁΩ∞</span>
                                            </button>
                                        </div>
                                    </div>
                                </>
                            ) : selectedObj ? (
                                <div className="bg-[#1a1c2c] p-3 rounded border border-[#3e2723] flex-1 shrink-0">
                                    <div className="flex justify-between items-start mb-2">
                                        <h3 className="text-[#ffcd75] text-lg font-bold">
                                            {isBuilding ? BUILDINGS[selectedObj.type].name : 
                                             isCreature ? CREATURE_STATS[selectedObj.type].name :
                                             (selectedObj.sign || selectedObj.name || "Êú™Áü•ÁõÆÊ®ô")}
                                        </h3>
                                        <button onClick={() => setSelectedId(null)}><Icons.X size={14}/></button>
                                    </div>
                                    {isBuilding ? (
                                        <div className="space-y-2 text-xs text-gray-300">
                                            <div><span className="text-gray-500">È°ûÂûãÔºö</span> {BUILDINGS[selectedObj.type].desc}</div>
                                            <div><div className="flex justify-between text-[10px]"><span>HP</span><span>{Math.floor(selectedObj.hp)}</span></div><div className="h-1 bg-gray-700"><div className="h-full bg-green-500" style={{width:`${(selectedObj.hp / BUILDINGS[selectedObj.type].hp) * 100}%`}}></div></div></div>
                                        </div>
                                    ) : isSim ? (
                                        <>
                                        <div className="text-xs text-gray-400 mb-2 flex items-center justify-between">
                                            <span className="flex items-center gap-1">
                                                {selectedObj.state} | 
                                                {selectedObj.gender === 'M' ? <span className="text-blue-400 font-bold text-sm" title="Áî∑ÊÄß">‚ôÇ</span> : <span className="text-pink-400 font-bold text-sm" title="Â•≥ÊÄß">‚ôÄ</span>} 
                                                {selectedObj.age}Ê≠≤ | Gen{selectedObj.generation}
                                            </span>
                                            {userApiKey && <span className="text-[10px] text-green-400 border border-green-600 px-1 rounded">AI ÈÄ£Áµê‰∏≠</span>}
                                        </div>
                                        {/* TOOLS DISPLAY */}
                                        <div className="flex gap-2 mt-2 mb-2">
                                            {selectedObj.tools.axe && <span className="bg-gray-700 p-1 rounded text-xs cursor-help" title="ÊñßÈ†≠">ü™ì</span>}
                                            {selectedObj.tools.pick && <span className="bg-gray-700 p-1 rounded text-xs cursor-help" title="Èé¨Â≠ê">‚õèÔ∏è</span>}
                                            {selectedObj.tools.spear && <span className="bg-gray-700 p-1 rounded text-xs cursor-help" title="Èï∑Áüõ">‚öîÔ∏è</span>}
                                            {!selectedObj.tools.axe && !selectedObj.tools.pick && !selectedObj.tools.spear && <span className="text-gray-600 text-[10px]">ÁÑ°Ë£ùÂÇô</span>}
                                        </div>
                                        
                                        <div className="text-xs text-yellow-200 italic mb-4 p-2 bg-black/40 rounded border border-gray-700">
                                            "{selectedObj.thought}"
                                        </div>
                                        <div className="space-y-2">
                                            <div><div className="flex justify-between text-[10px]"><span>HP</span><span>{Math.floor(selectedObj.hp)}</span></div><div className="h-1 bg-gray-700"><div className="h-full bg-red-500" style={{width:`${selectedObj.hp}%`}}></div></div></div>
                                            <div><div className="flex justify-between text-[10px]"><span>Hunger</span><span>{Math.floor(selectedObj.hunger)}</span></div><div className="h-1 bg-gray-700"><div className="h-full bg-orange-500" style={{width:`${selectedObj.hunger}%`}}></div></div></div>
                                            <div><div className="flex justify-between text-[10px]"><span>Sanity</span><span>{Math.floor(selectedObj.sanity)}</span></div><div className="h-1 bg-gray-700"><div className="h-full bg-purple-500" style={{width:`${selectedObj.sanity}%`}}></div></div></div>
                                            <div><div className="flex justify-between text-[10px]"><span>Energy</span><span>{Math.floor(selectedObj.energy)}</span></div><div className="h-1 bg-gray-700"><div className="h-full bg-blue-500" style={{width:`${selectedObj.energy}%`}}></div></div></div>
                                        </div>
                                        <div className="mt-4 grid grid-cols-3 gap-2">
                                            <button onClick={() => castSpell('FOOD')} className="bg-[#3e2723] p-2 rounded text-[10px] text-center"><Icons.Utensils className="block mx-auto mb-1"/>Ë≥úÈ£ü</button>
                                            <button onClick={() => castSpell('HEAL')} className="bg-[#3e2723] p-2 rounded text-[10px] text-center"><Icons.Heart className="block mx-auto mb-1"/>Ê≤ªÁôí</button>
                                            <button onClick={() => castSpell('BUFF')} className="bg-[#3e2723] p-2 rounded text-[10px] text-center"><Icons.Shield className="block mx-auto mb-1"/>Ë≥úÁ¶è</button>
                                        </div>
                                        </>
                                    ) : isCreature ? (
                                        // CREATURE STATS DISPLAY
                                        <div className="space-y-2 text-xs text-gray-300">
                                            <div><span className="text-gray-500">È°ûÂûãÔºö</span> {CREATURE_STATS[selectedObj.type].type === 'HOSTILE' ? 'ÊïµÂ∞çÁîüÁâ©' : '‰∏≠Á´ã/Ë¢´ÂãïÁîüÁâ©'}</div>
                                            <div><div className="flex justify-between text-[10px]"><span>HP</span><span>{Math.floor(selectedObj.hp)} / {CREATURE_STATS[selectedObj.type].hp}</span></div><div className="h-1 bg-gray-700"><div className="h-full bg-red-500" style={{width:`${Math.min(100, (selectedObj.hp / CREATURE_STATS[selectedObj.type].hp) * 100)}%`}}></div></div></div>
                                        </div>
                                    ) : null}
                                </div>
                            ) : (
                                <div className="flex-1 flex items-center justify-center text-gray-500 text-xs">
                                    ÈªûÊìäÂü∫Âú∞ÊàñÂñÆ‰ΩçÊü•ÁúãË©≥ÊÉÖ
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };
        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>