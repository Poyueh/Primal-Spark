<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÊòüËæ∞ÈÉ®ËêΩ: ÊñáÊòéÂ¥õËµ∑ (Tribe of Stars)</title>
    
    <!-- 1. ËºâÂÖ• Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. ËºâÂÖ• React Ëàá ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- 3. ËºâÂÖ• Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        /* Ëá™ÂÆöÁæ©Êç≤Ëª∏Ê®£Âºè */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #4a4a4a; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }

        button { touch-action: manipulation; }
        
        /* Log Ë¶ñÁ™óÁöÑÊ∑°ÂÖ•ÂãïÁï´ */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .log-item { animation: fadeIn 0.3s ease-out forwards; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useLayoutEffect } = React;
        const { createRoot } = ReactDOM;

        // --- Icon Components ---
        const Icon = ({ char, className, size }) => (
            <span className={className} style={{ fontSize: size || 16, lineHeight: 1, display: 'inline-block' }}>{char}</span>
        );

        const Icons = {
            Sparkles: (p) => <Icon char="‚ú®" {...p}/>,
            Heart: (p) => <Icon char="‚ù§Ô∏è" {...p}/>,
            Utensils: (p) => <Icon char="üçñ" {...p}/>,
            Shield: (p) => <Icon char="üõ°Ô∏è" {...p}/>,
            CloudRain: (p) => <Icon char="üåßÔ∏è" {...p}/>,
            Snowflake: (p) => <Icon char="‚ùÑÔ∏è" {...p}/>,
            Sun: (p) => <Icon char="‚òÄÔ∏è" {...p}/>,
            Cloud: (p) => <Icon char="‚òÅÔ∏è" {...p}/>,
            Flame: (p) => <Icon char="üî•" {...p}/>,
            Mountain: (p) => <Icon char="‚õ∞Ô∏è" {...p}/>,
            Skull: (p) => <Icon char="üíÄ" {...p}/>,
            RefreshCw: (p) => <Icon char="üîÑ" {...p}/>,
            X: (p) => <Icon char="‚ùå" {...p}/>,
            Brain: (p) => <Icon char="üß†" {...p}/>,
            ScrollText: (p) => <Icon char="üìú" {...p}/>,
            MessageCircle: (p) => <Icon char="üí¨" {...p}/>,
            HelpCircle: (p) => <Icon char="‚ùì" {...p}/>,
            Users: (p) => <Icon char="üë•" {...p}/>,
            Hammer: (p) => <Icon char="üî®" {...p}/>,
            Zap: (p) => <Icon char="‚ö°" {...p}/>,
            Home: (p) => <Icon char="üè†" {...p}/>,
            Biohazard: (p) => <Icon char="‚ò£Ô∏è" {...p}/>,
            Baby: (p) => <Icon char="üë∂" {...p}/>,
            Sword: (p) => <Icon char="‚öîÔ∏è" {...p}/>,
            Crown: (p) => <Icon char="üëë" {...p}/>,
            Box: (p) => <Icon char="üì¶" {...p}/>,
            ChevronUp: (p) => <Icon char="‚ñ≤" {...p}/>,
            ChevronDown: (p) => <Icon char="‚ñº" {...p}/>
        };

        const apiKey = ""; 

        // --- Constants & Config ---
        const PIXEL_FONT = "'Courier New', Courier, monospace";
        const TILE_SIZE = 32;
        const SCALE = 1.5; // Slightly zoom out for larger map
        const MAP_WIDTH = 40; // Requirement 6: Larger Map
        const MAP_HEIGHT = 40;
        const DAY_TICKS = 800; 
        const MAX_POPULATION = 50;

        // Requirement 1: 10+ Wisdoms (Tech Tree)
        const TECH_TREE = [
            // Era 1: Cave
            "ÁÅ´Á®Æ‰øùÂ≠ò", "Áü≥Âô®ÊâìÁ£®", "Ë™ûË®ÄÊ∫ùÈÄö", "Áç∏ÁöÆÁ∏´Ë£Ω", "Êé°ÈõÜËæ®Ë≠ò",
            // Era 2: Tribe
            "Á∞°ÊòìËæ≤Ê•≠", "Èô∂Âô®Ë£Ω‰Ωú", "ÂºìÁÆ≠Áã©Áçµ", "ËçâËó•Â≠∏", "Âü∫Á§éÂª∫ÁØâ",
            // Era 3: City
            "ÈùíÈäÖÂÜ∂ÁÖâ", "ÊñáÂ≠óË®òÈåÑ", "Ê≥ïÂæãÂà∂ÂÆö", "Ë≤®Âπ£‰∫§Êòì", "ËªäËº™ÈÅãËº∏",
            // Era 4: Nation
            "ÈãºÈêµÈçõÈÄ†", "Âì≤Â≠∏ÊÄùËÄÉ", "Ëªç‰∫ãÈô£Ê≥ï", "Â§ßÂûãÁÅåÊ∫â", "Ëà™Êµ∑ÊäÄË°ì"
        ];

        // Requirement 5: Civilization Stages (Enhanced with Descriptions)
        const CIV_STAGES = [
            { id: 0, name: 'Á©¥Â±ÖÊôÇ‰ª£', icon: 'üï≥Ô∏è', minTech: 0, sprite: 'cave', desc: 'ÂéüÂßãÁöÑÂ§©ÁÑ∂Â≤©Ê¥ûÔºåËÉΩÂãâÂº∑ÈÅÆÈ¢®ÈÅøÈõ®„ÄÇ', stats: { def: 10, heal: 1, cap: 200 } },
            { id: 1, name: 'ÈÉ®ËêΩÊôÇ‰ª£', icon: '‚õ∫', minTech: 5, sprite: 'hut', desc: 'Áî®Êú®ÊùêËàáÁç∏ÁöÆÊê≠Âª∫ÁöÑËÅöËêΩÔºåË®≠ÊúâÁ∞°ÊòìÂÄâÂ∫´„ÄÇ', stats: { def: 30, heal: 2, cap: 500 } },
            { id: 2, name: 'ÂüéÈÇ¶ÊôÇ‰ª£', icon: 'üèòÔ∏è', minTech: 10, sprite: 'house', desc: 'Áü≥Êú®Ê∑∑ÂêàÁöÑÂ†ÖÂõ∫Âª∫ÁØâÔºåÊñáÊòéÁöÑÁÅ´Á®ÆÂú®Ê≠§ÁáÉÁáí„ÄÇ', stats: { def: 80, heal: 4, cap: 2000 } },
            { id: 3, name: 'Â∏ùÂúãÊôÇ‰ª£', icon: 'üè∞', minTech: 15, sprite: 'castle', desc: 'Â∑çÂ≥®ÁöÑÁü≥Á†åÂüéÂ†°ÔºåË±°ÂæµËëóËá≥È´òÁÑ°‰∏äÁöÑÊ¨äÂäõ„ÄÇ', stats: { def: 200, heal: 8, cap: 10000 } }
        ];

        const PALETTE = {
            OUTLINE: '#1a1c2c', SKIN: '#ffccaa', SKIN_SHADOW: '#d48e7e',
            GRASS_BG: '#388e3c', GRASS_L: '#4caf50', GRASS_D: '#1b5e20',
            DIRT: '#5d4037', WATER: '#4a69bd',
            SAND: '#e6c98e', MOUNTAIN_BG: '#5d4037', MOUNTAIN_FG: '#8d6e63',
            CAVE_DARK: '#1a1a1a',
            WHEAT_1: '#a5d6a7', WHEAT_2: '#e6ee9c', WHEAT_3: '#fbc02d',
            STONE_L: '#b0bec5', STONE_M: '#78909c', STONE_D: '#546e7a',
            WOOD_L: '#8d6e63', WOOD_D: '#3e2723',
            LEAF_L: '#66bb6a', LEAF_D: '#2e7d32', LEAF_PINE: '#1b5e20',
            FLOWER_R: '#e57373', FLOWER_Y: '#fff176', MUSHROOM: '#f44336',
            FUR_WOLF: '#90a4ae', FUR_BEAR: '#4e342e', FUR_DEER: '#a1887f', FUR_RABBIT: '#fafafa',
            DINO_GREEN: '#558b2f', DINO_EYE: '#ffeb3b', 
            WHITE: '#ffffff', GOLD: '#ffd700', RED: '#ff0000',
            TOOL_AXE: '#8d6e63', TOOL_HEAD: '#90a4ae', TOOL_SPEAR: '#d7ccc8',
            SICK_SKIN: '#88aa88',
            HUT_ROOF: '#e6c98e', HOUSE_ROOF: '#a1887f', CASTLE_WALL: '#90a4ae',
            BONE_WHITE: '#e0e0e0'
        };

        const DISASTERS = {
            NONE: { name: 'ÁÑ°', color: null },
            METEOR: { name: 'üî• ÊòüÊÆû', color: 'rgba(255, 50, 0, 0.3)' },
            PLAGUE: { name: 'ü¶† ÁòüÁñ´', color: 'rgba(20, 100, 20, 0.4)' },
            DROUGHT: { name: '‚òÄ ‰πæÊó±', color: 'rgba(255, 140, 0, 0.4)' },
            FLOOD: { name: 'üåä Ê¥™Ê∞¥', color: 'rgba(0, 60, 200, 0.5)' },
            LOCUSTS: { name: 'ü¶ó ËùóÁÅΩ', color: 'rgba(100, 80, 20, 0.4)' },
            BLIZZARD: { name: '‚ùÑ ÂáúÂÜ¨', color: 'rgba(200, 240, 255, 0.6)' },
            QUAKE: { name: 'üåã Âú∞Èúá', color: 'rgba(80, 40, 40, 0.4)' },
            BEASTS: { name: 'üê∫ Áç∏ÊΩÆ', color: 'rgba(100, 0, 0, 0.3)' },
            DARKNESS: { name: 'üåë Ê∞∏Â§ú', color: 'rgba(0, 0, 0, 0.9)' },
            THUNDER: { name: '‚ö° Èõ∑ÁΩ∞', color: 'rgba(80, 80, 120, 0.4)' }
        };

        const WEATHER = {
            SUNNY: { id: 'SUNNY', name: 'Êô¥Â§©', color: 'rgba(255,255,0,0.1)' },
            RAIN: { id: 'RAIN', name: 'Èõ®Â§©', color: 'rgba(0,0,50,0.3)' },
            SNOW: { id: 'SNOW', name: 'ÈôçÈõ™', color: 'rgba(200,240,255,0.2)' }
        };

        const ZODIACS = [
            { sign: 'Áâ°Áæä', gender: 'M', color: '#c0392b', hair: '#2c3e50', trait: 'Â•ΩÈ¨•' },
            { sign: 'ÈáëÁâõ', gender: 'F', color: '#27ae60', hair: '#5d4037', trait: 'Âõ∫Âü∑' },
            { sign: 'ÈõôÂ≠ê', gender: 'M', color: '#f39c12', hair: '#e67e22', trait: 'ÂñÑËÆä' },
            { sign: 'Â∑®Ëüπ', gender: 'F', color: '#7f8c8d', hair: '#34495e', trait: 'È°ßÂÆ∂' },
            { sign: 'ÁçÖÂ≠ê', gender: 'M', color: '#e67e22', hair: '#f1c40f', trait: 'Èú∏Ê∞£' },
            { sign: 'ËôïÂ•≥', gender: 'F', color: '#16a085', hair: '#2ecc71', trait: 'Ë¨πÊÖé' },
            { sign: 'Â§©Áß§', gender: 'M', color: '#e84393', hair: '#fd79a8', trait: 'Áå∂Ë±´' },
            { sign: 'Â§©Ë†ç', gender: 'F', color: '#8e44ad', hair: '#2c3e50', trait: 'ÊïèÈä≥' },
            { sign: 'Â∞ÑÊâã', gender: 'M', color: '#2980b9', hair: '#3498db', trait: 'ÂÜíÈö™' },
            { sign: 'Êë©ÁæØ', gender: 'F', color: '#576574', hair: '#1e272e', trait: 'Â†ÖÂøç' },
            { sign: 'Ê∞¥Áì∂', gender: 'M', color: '#00d2d3', hair: '#00cec9', trait: 'Âè§ÊÄ™' },
            { sign: 'ÈõôÈ≠ö', gender: 'F', color: '#a29bfe', hair: '#6c5ce7', trait: 'Êµ™Êº´' }
        ];

        // --- Utils ---
        const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const noise = (x, y) => Math.sin(x/3.5) + Math.cos(y/4.5);
        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        const callGemini = async (prompt, type) => {
            if (!apiKey) { 
                await new Promise(r => setTimeout(r, 800));
                return type === 'SAGA' ? "ÈÉ®ËêΩÁöÑÁØùÁÅ´ÁÖß‰∫Æ‰∫ÜÊñ∞ÊôÇ‰ª£ÁöÑÈÅìË∑Ø„ÄÇ" : "Ê≤àÊÄù‰∏≠...";
            }
            try {
                const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || null;
            } catch (error) { return null; }
        };

        // --- Graphics ---
        const SPRITE_MATRICES = {
            CHAR_M: ["........................",".......HHHHHH...........","......HSSSSSSH..........",".....HSSKSSKSSH.........",".....HSSSSSSSSH.........","......SSSSSSSS..........","....CCCSCCCCSCCC........","....CCCSCCCCSCCC........","....CCCCCCCCCCCC........","....KKKCCCCCCKKK........","....K.KCCCCCCK.K........","......KSSSSSSK..........","......KSSSSSSK..........","......KKK..KKK.........."],
            CHAR_F: ["........................","......HHHHHHHH..........",".....HSSSSSSSSH.........",".....HSSKSSKSSH.........",".....HSSSSSSSSH.........",".....SSSSSSSSSS.........","....CCCSCCCCSCCC........","...CCCCSCCCCSCCCC.......","...CCCCCCCCCCCCCC.......","...CCCCCCCCCCCCCC.......","....CCCCCCCCCCCC........",".....KSSSSSSssk.........",".....KSSSSSSssk.........",".....KKK....KKK........."],
            TREE_OAK: [".......LLLLLL.......",".....LLLLLLLLLL.....","....LLLLLLLLLLLL....","...LLLLLLLLLLLLLL...","...LLLLLLLLLLLLLL...","....LLLLLLLLLLLL....",".....LLLLLLLLLL.....",".......WWWWWW.......",".......WWWWWW.......",".......WWWWWW.......","......WWWWWWWW......"],
            TREE_PINE: ["..........L.........",".........LLL........","........LLLLL.......",".......LLLLLLL......",".........LLL........","........LLLLL.......",".......LLLLLLL......","......LLLLLLLLL.....",".....LLLLLLLLLLL....","........WWWWW.......",".......WWWWWWW......"],
            BUSH: ["....................","......LLLLLLL.......",".....LLLLLLLLL......","....LLLLLLLLLLL.....","....LLLLLLLLLLL.....",".....LLLLLLLLL......"],
            FLOWER: [".........R..........","........RYR.........",".........R..........",".........G..........",".........G.........."],
            MUSHROOM: ["........RRR.........",".......RRRRR........",".......RWWWR........","........WWW.........","........WWW........."],
            ROCK: [".......KKKKKK.......",".....KKMMMMMMKK.....","....KMMLLLLLLMMK....","...KMLLLLLLLLLLMK...","...KMMMMMMMMMMMMK...","...KDDDDDDDDDDDDK...","....KKDDDDDDDDKK....","......KKKKKKKK......"],
            RABBIT: [".......KK...........","......KWWK..........",".....KWWWWK.........",".....KWWWWK.........","......KKKK.........."],
            WOLF: ["....................",".......K............","......KGK...........",".....KGGGK..........","....KGGGGGK...K.....","...KGGGGGGGGKKGK....","...KGGGGGGGGGGGK....","....KGGGGGGGGGK.....","....K.K.....K.K....."],
            BEAR: [".........KK...KK....","......KKKBBKKKBBK...",".....KBBBBBBBBBBBK..","....KBBBBBBBBBBBBBK.","...KBBBBBBBBBBBBBBBK","...KBBBBBBBBBBBBBBBK","...KBBBBBBBBBBBBBBBK","....KB.B.B.....B.B..","....KK.K.K.....K.K.."],
            DEER: ["...........K...K....","............K.K.....","..........KKKBKK....",".........KBBBBBBK...","........KBBBBBBBBK..",".......KBBBBBBBBBK..",".......K.B.....B....",".......K.K.....K...."],
            WHEAT_GROW: ["................","....1......1....","...111....111...","....1......1....","................"],
            WHEAT_READY: ["....3......3....","...333....333...","...333....333...","....3......3....","....3......3...."],
            // RE-DESIGNED GIANT T-REX (Centered & Bigger)
            DINOSAUR: [
                "...........KKKKKKKK.....",
                "..........KGGGGGGGGK....",
                ".........KGGGGGGGGGGK...",
                ".........KGGGYGGGGGGK...", // Head
                ".........KGGGGGGGGGGK...",
                ".........KGGGGGGGGGK....",
                "........KGGGGGGGGGK.....",
                ".......KGGGGGGGGGGK.....",
                ".....KKGGGGGGGGGGGKK....", // Body
                "...KKGGGGGGGGGGGGGGGKK..",
                "..KGGGGGGGGGGGGGGGGGGGK.",
                ".KGGGGGGGGGGGGGGGGGGGGGK",
                ".KGGGGKGGGGGGGGG KGGGGGK",
                ".KKKK..KGGGGGGK...KGGGGK", // Legs
                ".......KGGGGGGK...KGGGGK",
                "........KK..KK.....KK.KK"
            ],
            SKULL: ["........................","........................",".........KKKK...........","........KWWWWK..........",".......KWBWWBWK.........",".......KWWWWWWK.........","........KKBKKBK.........",".........KKKKK..........",".......KK.....KK........","......K.........K.......","........................","........................"],
            CAVE: [".....KKKKKKKKK.....","...KKXXXXXXXXXKK...","..KXXXXXXXXXXXXXK..",".KXXXXXXXXXXXXXXXK.",".KXXXXXXXXXXXXXXXK.","KXXXXXXXXXXXXXXXXXK","KXXXXXXXXXXXXXXXXXK","KXXXXXX.....XXXXXXK","KXXXXXX.....XXXXXXK","KXXXXXX.....XXXXXXK"],
            HUT: [".........K.........",".......KRRK........","......KRRRRK.......",".....KRRRRRRK......","....KRRRRRRRRK.....","...KRRRRRRRRRRK....","..KWWWWWWWWWWWWK...","..KW..W....W..WK...","..KW..W....W..WK...","..KWWWW....WWWWK..."],
            HOUSE: ["...................","...KKKKKKKKKKKKK...","...KRRRRRRRRRRRK...","...KRRRRRRRRRRRK...","...KRRRRRRRRRRRK...","...KKKKKKKKKKKKK...","...KWWWWWWWWWWWK...","...KWWWWWWWWWWWK...","...KWW.WWWW.WWWK...","...KWW.WWWW.WWWK..."],
            CASTLE: [".KK...KK...KK...KK.",".KWK.KWK...KWK.KWK.",".KWWKWWK...KWWKWWK.",".KWWWWWKKKKKWWWWWK.",".KWWWWWWWWWWWWWWWK.",".KWWWWWWWWWWWWWWWK.",".KWWWWWWWWWWWWWWWK.",".KWWWWWW.WWWWWWWWK.",".KWWWWWW.WWWWWWWWK.",".KWWWWWW.WWWWWWWWK."]
        };

        const renderMatrix = (ctx, matrix, colors, offsetX = 0, offsetY = 0) => {
            matrix.forEach((row, y) => {
                for (let x = 0; x < row.length; x++) {
                    const char = row[x];
                    if (char === '.') continue;
                    let fill = colors[char] || PALETTE.OUTLINE;
                    if (char === 'K') fill = PALETTE.OUTLINE;
                    ctx.fillStyle = fill;
                    ctx.fillRect(offsetX + x, offsetY + y, 1, 1);
                }
            });
        };

        const createSprites = () => {
            const cache = {};
            const createCanvas = (w, h) => { const c = document.createElement('canvas'); c.width = w; c.height = h; return { c, ctx: c.getContext('2d') }; };

            const { c: grassC, ctx: grassCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            grassCtx.fillStyle = PALETTE.GRASS_BG; grassCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            grassCtx.fillStyle = PALETTE.GRASS_L; for(let i=0; i<30; i++) grassCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            grassCtx.fillStyle = PALETTE.GRASS_D; for(let i=0; i<20; i++) grassCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.grass = grassC;

            const { c: dirtC, ctx: dirtCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            dirtCtx.fillStyle = PALETTE.DIRT; dirtCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            dirtCtx.fillStyle = PALETTE.WOOD_D; for(let i=0; i<40; i++) dirtCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.dirt = dirtC;

            const { c: sandC, ctx: sandCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            sandCtx.fillStyle = PALETTE.SAND; sandCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            sandCtx.fillStyle = '#d4b483'; for(let i=0; i<30; i++) sandCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.sand = sandC;

            const { c: mtC, ctx: mtCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            mtCtx.fillStyle = PALETTE.MOUNTAIN_BG; mtCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            mtCtx.fillStyle = PALETTE.MOUNTAIN_FG; for(let i=0; i<25; i++) { let rx = rand(0,30); let ry = rand(0,30); mtCtx.fillRect(rx, ry, 2, 2); }
            cache.mountain = mtC;

            const makeSprite = (name, mat, colors, wMult=1, hMult=1, ox=0, oy=0) => {
                const { c, ctx } = createCanvas(TILE_SIZE*wMult, TILE_SIZE*hMult);
                renderMatrix(ctx, mat, colors, ox, oy);
                cache[name] = c;
            };

            makeSprite('tree_oak', SPRITE_MATRICES.TREE_OAK, {'L': PALETTE.LEAF_D, 'W': PALETTE.WOOD_D}, 1, 2, 6, 10);
            makeSprite('tree_pine', SPRITE_MATRICES.TREE_PINE, {'L': PALETTE.LEAF_PINE, 'W': PALETTE.WOOD_D}, 1, 2, 6, 8);
            makeSprite('bush', SPRITE_MATRICES.BUSH, {'L': PALETTE.LEAF_L}, 1, 1, 4, 16);
            makeSprite('flower', SPRITE_MATRICES.FLOWER, {'R': PALETTE.FLOWER_R, 'Y': PALETTE.FLOWER_Y, 'G': PALETTE.GRASS_L}, 1, 1, 10, 16);
            makeSprite('mushroom', SPRITE_MATRICES.MUSHROOM, {'R': PALETTE.MUSHROOM, 'W': PALETTE.WHITE}, 1, 1, 10, 16);
            makeSprite('rock', SPRITE_MATRICES.ROCK, {'K': PALETTE.OUTLINE, 'M': PALETTE.STONE_M, 'L': PALETTE.STONE_L, 'D': PALETTE.STONE_D}, 1, 1, 8, 16);
            makeSprite('rabbit', SPRITE_MATRICES.RABBIT, {'W': PALETTE.FUR_RABBIT}, 1, 1, 8, 16);
            makeSprite('wolf', SPRITE_MATRICES.WOLF, {'G': PALETTE.FUR_WOLF}, 1, 1, 4, 12);
            makeSprite('bear', SPRITE_MATRICES.BEAR, {'B': PALETTE.FUR_BEAR}, 1.5, 1.5, 4, 10);
            makeSprite('deer', SPRITE_MATRICES.DEER, {'B': PALETTE.FUR_DEER}, 1, 1.5, 4, 10);
            makeSprite('dinosaur', SPRITE_MATRICES.DINOSAUR, {'G': PALETTE.DINO_GREEN, 'Y': PALETTE.DINO_EYE}, 2, 2, 16, 16); 
            makeSprite('wheat_1', SPRITE_MATRICES.WHEAT_GROW, { '1': PALETTE.WHEAT_1 }, 1, 1, 8, 16);
            makeSprite('wheat_2', SPRITE_MATRICES.WHEAT_READY, { '3': PALETTE.WHEAT_3 }, 1, 1, 8, 16);
            makeSprite('skull', SPRITE_MATRICES.SKULL, { 'W': PALETTE.BONE_WHITE, 'B': PALETTE.OUTLINE }, 1, 1, 8, 10);
            makeSprite('cave', SPRITE_MATRICES.CAVE, { 'X': PALETTE.CAVE_DARK, 'K': PALETTE.MOUNTAIN_FG }, 2, 2, 16, 24);
            makeSprite('hut', SPRITE_MATRICES.HUT, { 'R': PALETTE.HUT_ROOF, 'W': PALETTE.WOOD_L }, 2, 2, 16, 24);
            makeSprite('house', SPRITE_MATRICES.HOUSE, { 'R': PALETTE.HOUSE_ROOF, 'W': PALETTE.STONE_L }, 2, 2, 16, 24);
            makeSprite('castle', SPRITE_MATRICES.CASTLE, { 'W': PALETTE.CASTLE_WALL }, 2, 2, 16, 24);

            return cache;
        };

        const generateMapData = () => {
            const newMap = [];
            const centerX = MAP_WIDTH / 2;
            const centerY = MAP_HEIGHT / 2;

            for(let y=0; y<MAP_HEIGHT; y++) {
                const row = [];
                for(let x=0; x<MAP_WIDTH; x++) {
                    const n = noise(x + Math.random()*10, y + Math.random()*10);
                    let type = 'GRASS';
                    let decoration = null;
                    
                    if (n > 0.8) type = 'WATER';
                    else if (n > 0.6) type = 'SAND'; 
                    else if (n < -0.6) type = 'MOUNTAIN_GROUND';
                    else if (n < -0.3) type = 'FOREST';
                    
                    const dist = Math.sqrt((x-centerX)**2 + (y-centerY)**2);
                    if (dist < 5) {
                        type = 'MOUNTAIN_GROUND';
                        if (dist < 1.5) decoration = 'BASE'; // Replaces CAVE
                        else if (Math.random() < 0.1) decoration = 'ROCK';
                    } else {
                        if (type === 'FOREST') {
                            if (Math.random() > 0.6) decoration = 'TREE_OAK';
                            else decoration = 'TREE_PINE';
                            if (Math.random() < 0.1) decoration = 'MUSHROOM';
                        } else if (type === 'GRASS') {
                            const rnd = Math.random();
                            if (rnd < 0.05) decoration = 'ROCK';
                            else if (rnd < 0.1) decoration = 'BUSH';
                            else if (rnd < 0.15) decoration = 'FLOWER';
                        } else if (type === 'MOUNTAIN_GROUND') {
                            if (Math.random() < 0.15) decoration = 'ROCK';
                        }
                    }
                    
                    if (decoration === 'BASE' && (Math.abs(x - centerX) > 0.5 || Math.abs(y - centerY) > 0.5)) decoration = null;
                    if (Math.abs(x - centerX) < 0.5 && Math.abs(y - centerY) < 0.5) decoration = 'BASE';

                    row.push({ x, y, type, decoration });
                }
                newMap.push(row);
            }
            return newMap;
        };

        const generateSim = (id, x, y, gen = 1) => {
            const z = ZODIACS[Math.floor(Math.random() * ZODIACS.length)];
            return {
                id: id || `sim_${Date.now()}_${Math.random()}`, ...z,
                x: x || MAP_WIDTH/2 + rand(-1,1), y: y || MAP_HEIGHT/2 + rand(-1,1) + 2,
                hp: 100, hunger: 100, energy: 100, mood: 80, age: 18, generation: gen,
                state: 'IDLE', targetX: null, targetY: null, actionTimer: 0, targetId: null,
                inventory: { wood:0, food:0, stone:0 },
                tools: { axe: false, pick: false, spear: false },
                thought: 'ÂèàÊòØÊñ∞ÁöÑ‰∏ÄÂ§©...',
                animFrame: rand(0,10), dir: 1, hidden: false, sick: false,
                buffTimer: 0, // Requirement 3: Clear Blessing
                mateCooldown: 0
            };
        };

        const generateCreaturesData = () => {
            const initCreatures = [];
            for(let i=0; i<12; i++) {
                const r = Math.random();
                let type = 'RABBIT';
                if (r > 0.95) type = 'DINOSAUR'; // 5% chance for Dino
                else if (r > 0.9) type = 'BEAR';
                else if (r > 0.7) type = 'WOLF';
                else if (r > 0.4) type = 'DEER';
                
                initCreatures.push({
                    id: `c_${Date.now()}_${i}`, type,
                    x: rand(1, MAP_WIDTH-2), y: rand(1, MAP_HEIGHT-2),
                    hp: type==='DINOSAUR'?800 : (type==='BEAR'?200 : (type==='WOLF'?80 : 30)),
                    targetX: null, targetY: null,
                    state: 'WANDER', animFrame: rand(0,10), dir: 1
                });
            }
            return initCreatures;
        };

        const App = () => {
            const [sprites, setSprites] = useState(null);
            const [map, setMap] = useState([]);
            const [sims, setSims] = useState([]);
            const [creatures, setCreatures] = useState([]);
            const [farms, setFarms] = useState([]);
            const [particles, setParticles] = useState([]);
            const [tribe, setTribe] = useState({ wood: 0, stone: 0, food: 100, tech: 0, unlockedTechs: [] });
            const [weather, setWeather] = useState(WEATHER.SUNNY);
            const [time, setTime] = useState(0);
            const [day, setDay] = useState(1);
            const [era, setEra] = useState(1);
            const [mana, setMana] = useState(999999);
            const [selectedId, setSelectedId] = useState(null);
            const [events, setEvents] = useState([{id: 0, text:'Êóè‰∫∫‰ª∞ÊúõÊòüÁ©∫ÔºåÊïÖ‰∫ãÈñãÂßã‰∫Ü...'}]); 
            const [isGameOver, setIsGameOver] = useState(false);
            const [isSoulSearching, setIsSoulSearching] = useState(false);
            const [isWritingSaga, setIsWritingSaga] = useState(false);
            const [disaster, setDisaster] = useState(DISASTERS.NONE);
            const [disasterTimer, setDisasterTimer] = useState(0);
            const [shake, setShake] = useState(0);
            // New State for Log Toggle
            const [isLogOpen, setIsLogOpen] = useState(true);
            const [flash, setFlash] = useState(0);

            const canvasRef = useRef(null);
            const tickRef = useRef(0);
            const requestRef = useRef();
            const logEndRef = useRef(null);
            const actionQueue = useRef([]); // Queue for Map modifications

            // Scroll to bottom when events change 
            useEffect(() => {
                if (isLogOpen) {
                    logEndRef.current?.scrollIntoView({ behavior: "smooth" });
                }
            }, [events, isLogOpen]);

            useEffect(() => {
                setSprites(createSprites());
                setMap(generateMapData());
                setSims(Array(12).fill(0).map((_, i) => generateSim(`start_${i}`, null, null, 1)));
                setCreatures(generateCreaturesData());
            }, []);

            // Check for Game Over (Restored)
            useEffect(() => {
                if (sims.length > 0 && sims.every(s => s.state === 'DEAD') && !isGameOver) {
                    setIsGameOver(true);
                }
            }, [sims, isGameOver]);

            const addEvent = (text) => {
                setEvents(prev => [...prev, { id: Date.now() + Math.random(), text }]);
            };

            const startNextEra = () => {
                setEra(e => e + 1); setDay(1); setTime(0); setMana(999999);
                setMap(generateMapData()); 
                setSims(Array(12).fill(0).map((_, i) => generateSim(`era${era+1}_${i}`, null, null, era+1)));
                setCreatures(generateCreaturesData());
                setFarms([]); setTribe(prev => ({ ...prev, food: 100, wood: 0, stone: 0 }));
                setIsGameOver(false); setDisaster(DISASTERS.NONE);
                addEvent(`=== Á¨¨ ${era + 1} Á¥ÄÂÖÉÈñãÂïü ===`);
            };

            const handleSoulSearch = async (sim) => {
                if (mana < 10) return;
                setIsSoulSearching(true); setMana(prev => prev - 10);
                const thought = await callGemini(null, 'SOUL'); 
                if (thought) {
                    setSims(prev => prev.map(s => s.id === sim.id ? { ...s, thought: thought.trim() } : s));
                    addEvent(`${sim.sign} ÁöÑÈùàÈ≠ÇÁôºÂá∫‰∫Ü‰ΩéË™û...`);
                }
                setIsSoulSearching(false);
            };

            const handleTribeSaga = async () => {
                if (mana < 50) return;
                setIsWritingSaga(true); setMana(prev => prev - 50);
                const prompt = `Write a cryptic, mythic, single-sentence log entry (max 20 words) for a primitive tribe in Traditional Chinese. Context: Era ${era}, Tech Lv ${tribe.tech}, Pop ${sims.length}, Food ${Math.floor(tribe.food)}, Weather ${weather.name}, Disaster ${disaster.name}.`;
                const saga = await callGemini(prompt, 'SAGA');
                if (saga) addEvent(`üìú Âè≤Ë©©: ${saga.trim()}`);
                else { addEvent(`‚ùå Âè≤Ë©©Êí∞ÂØ´Â§±Êïó`); setMana(prev => prev + 50); }
                setIsWritingSaga(false);
            };

            const castSpell = (type) => {
                if (type === 'DISASTER') {
                    if (mana < 100) return;
                    setMana(m => m - 100);
                    const keys = Object.keys(DISASTERS).filter(k => k !== 'NONE');
                    const pickKey = keys[Math.floor(Math.random() * keys.length)];
                    const selectedDisaster = DISASTERS[pickKey];
                    setDisaster(selectedDisaster);
                    setDisasterTimer(600);
                    addEvent(`‚ö†Ô∏è Á•ûË´≠Ôºö${selectedDisaster.name} ÈôçËá®ÔºÅ`);
                    if (pickKey === 'LOCUSTS') setTribe(t => ({...t, food: 0}));
                    if (pickKey === 'BEASTS') setCreatures(prev => [...prev, ...generateCreaturesData().slice(0,5)]);
                    return;
                }

                if (mana < 20) return;
                if (['FOOD', 'HEAL', 'BUFF'].includes(type) && selectedId && selectedId !== 'BASE_CENTER') {
                    setSims(prev => prev.map(s => {
                        if (s.id !== selectedId) return s;
                        if (type === 'FOOD') { setMana(m => m - 30); addEvent(`Ë≥ú‰∫à ${s.sign} È£üÁâ©`); return { ...s, hunger: 100, mood: Math.min(100, s.mood+10) }; }
                        else if (type === 'HEAL') { setMana(m => m - 30); addEvent(`${s.sign} ÂÇ∑Âè£ÁôíÂêà`); return { ...s, hp: 100, sick: false, mood: Math.min(100, s.mood+10) }; }
                        else if (type === 'BUFF') { 
                            setMana(m => m - 30); 
                            addEvent(`${s.sign} Áç≤ÂæóÁ•ûÂäõ`); 
                            return { ...s, energy: 100, mood: 100, buffTimer: 500, thought: 'ÂäõÈáèÊπßÁèæÔºÅ' }; 
                        }
                        return s;
                    }));
                    return;
                }
                
                if (type === 'TECH') {
                    if (tribe.tech >= TECH_TREE.length) { addEvent("ÊñáÊòéÂ∑≤ÈÅîÂ∑îÂ≥∞"); return; }
                    setMana(m => m - 50);
                    const newTech = TECH_TREE[tribe.tech];
                    setTribe(t => ({...t, tech: t.tech + 1, unlockedTechs: [...t.unlockedTechs, newTech]}));
                    addEvent(`üí° ÁôºÊòé‰∫Ü [${newTech}] (Lv.${tribe.tech + 1})`);
                    return;
                }

                setMana(m => m - 20);
                if (type === 'SUN') { setWeather(WEATHER.SUNNY); setDisaster(DISASTERS.NONE); addEvent('Á•ûËπüÔºöÁ•àÊô¥'); }
                else if (type === 'RAIN') { setWeather(WEATHER.RAIN); setDisaster(DISASTERS.NONE); addEvent('Á•ûËπüÔºöÁ•àÈõ®'); }
            };

            const update = useCallback(() => {
                if (isGameOver) return;
                const isNight = time > DAY_TICKS * 0.6 || disaster === DISASTERS.DARKNESS;
                
                if (disaster !== DISASTERS.NONE) {
                    setDisasterTimer(prev => {
                        if (prev <= 1) { setDisaster(DISASTERS.NONE); addEvent('Â§©ÁÅΩÂ∑≤ÈÄÄÂéª„ÄÇ'); return 0; }
                        return prev - 1;
                    });
                }
                
                if (flash > 0) setFlash(f => Math.max(0, f - 0.1));

                if (tickRef.current % 10 === 0 && disaster === DISASTERS.NONE && Math.random() < 0.005) {
                    const r = Math.random();
                    let nextW = r < 0.3 ? WEATHER.RAIN : (r < 0.4 ? WEATHER.SNOW : WEATHER.SUNNY);
                    setWeather(nextW); 
                }

                if (disaster === DISASTERS.QUAKE) setShake(prev => (tickRef.current % 4 === 0 ? rand(-5, 5) : 0)); else setShake(0);
                
                if (tickRef.current % 50 === 0 && disaster === DISASTERS.NONE && weather !== WEATHER.SNOW) {
                    const gx = rand(1, MAP_WIDTH-2);
                    const gy = rand(1, MAP_HEIGHT-2);
                    actionQueue.current.push({type: 'GROW', x: gx, y: gy});
                }

                if (disaster === DISASTERS.METEOR && tickRef.current % 5 === 0) {
                     setParticles(prev => [...prev, { x: rand(0, MAP_WIDTH * TILE_SIZE), y: -50, speed: rand(12,20), life: 50, color: '#ff4500', type: 'METEOR', vx: -2, vy: rand(12,20) }]);
                }
                if (disaster === DISASTERS.THUNDER && Math.random() < 0.03) {
                    setFlash(1.0); 
                    const lx = rand(1, MAP_WIDTH-2);
                    const ly = rand(1, MAP_HEIGHT-2);
                    actionQueue.current.push({type: 'DESTROY', x: lx, y: ly}); 
                    setParticles(prev => [...prev, { x: lx*TILE_SIZE, y: ly*TILE_SIZE, life: 10, color: '#fff', type: 'FLASH', vx:0, vy:0 }]);
                }
                if (disaster === DISASTERS.PLAGUE && tickRef.current % 10 === 0) {
                    setParticles(prev => [...prev, { x: rand(0, MAP_WIDTH * TILE_SIZE), y: rand(0, MAP_HEIGHT * TILE_SIZE), life: 100, color: '#4caf50', type: 'SPORE', vx: rand(-0.5, 0.5), vy: rand(-0.5, 0.5) }]);
                }

                setParticles(prev => prev.map(p => {
                    let np = { ...p, x: p.x + (p.vx||0), y: p.y + (p.vy||0), life: p.life - 1 };
                    if (p.type === 'METEOR' && (np.life <= 0 || np.y > MAP_HEIGHT * TILE_SIZE)) {
                         const mx = Math.floor(p.x / TILE_SIZE);
                         const my = Math.floor(p.y / TILE_SIZE);
                         if (mx > 0 && mx < MAP_WIDTH && my > 0 && my < MAP_HEIGHT) {
                             actionQueue.current.push({type: 'DESTROY', x: mx, y: my});
                         }
                    }
                    if (disaster === DISASTERS.BLIZZARD && p.type === 'SNOW') { np.x -= 2; }
                    return np;
                }).filter(p => p.life > 0));

                setFarms(prev => prev.map(f => {
                    if ([DISASTERS.DROUGHT, DISASTERS.FLOOD, DISASTERS.LOCUSTS].includes(disaster)) return { ...f, stage: 0 };
                    return { ...f, stage: Math.min(100, f.stage + 0.1) };
                }));

                let bossTargetId = null;
                sims.forEach(s => {
                    if (s.state === 'DEFEND' || s.state === 'HUNT') {
                        const target = creatures.find(c => c.id === s.targetId && c.type === 'DINOSAUR');
                        if (target) bossTargetId = target.id;
                    }
                });

                setCreatures(prev => prev.map(c => {
                    if (c.hp <= 0) return null;
                    let nextC = { ...c };
                    
                    sims.forEach(s => {
                        if ((s.state === 'DEFEND' || s.state === 'HUNT' || s.state === 'FIGHTING') && s.targetId === nextC.id && Math.sqrt((s.x-nextC.x)**2 + (s.y-nextC.y)**2) < 2) {
                             if (tickRef.current % 20 === 0) {
                                 const dmg = s.tools.spear ? 30 : (s.tools.axe ? 20 : (s.tools.pick ? 15 : 8));
                                 nextC.hp -= dmg;
                                 setParticles(p => [...p, { x: nextC.x*TILE_SIZE, y: nextC.y*TILE_SIZE, life: 20, color: '#f00', vy: -2, text: `-${dmg}` }]);
                                 if (nextC.hp <= 0) {
                                     const reward = nextC.type === 'DINOSAUR' ? 200 : (nextC.type === 'BEAR' ? 80 : 30);
                                     setTribe(t => ({...t, food: t.food + reward}));
                                     addEvent(`${s.sign} Ë®é‰ºê‰∫Ü ${nextC.type} (+${reward}È£üÁâ©)`);
                                 }
                             }
                        }
                    });

                    if (nextC.hp <= 0) return null;

                    if (['WOLF', 'BEAR', 'DINOSAUR'].includes(nextC.type)) {
                        let targetSim = null;
                        let minDist = nextC.type === 'DINOSAUR' ? 12 : 6; 
                        sims.forEach(s => { if (s.state !== 'DEAD' && !s.hidden) { const d = Math.sqrt((s.x - nextC.x)**2 + (s.y - nextC.y)**2); if (d < minDist) { minDist = d; targetSim = s; } } });
                        
                        if (targetSim) {
                             const dx = targetSim.x - nextC.x; const dy = targetSim.y - nextC.y;
                             const speed = nextC.type === 'DINOSAUR' ? 0.03 : 0.04; 
                             nextC.x += Math.sign(dx) * speed; nextC.y += Math.sign(dy) * speed;
                             nextC.dir = Math.sign(dx);
                             if (minDist < 1 && tickRef.current % 30 === 0) {
                                 setParticles(p => [...p, { x: targetSim.x*TILE_SIZE, y: targetSim.y*TILE_SIZE, life: 20, color: '#ff0000', vy: -2, text: 'üí•' }]);
                             }
                        } else {
                             if (Math.random() < 0.02) { nextC.targetX = rand(1, MAP_WIDTH-2); nextC.targetY = rand(1, MAP_HEIGHT-2); }
                             if (nextC.targetX) {
                                const dx = nextC.targetX - nextC.x; const dy = nextC.targetY - nextC.y;
                                if(Math.abs(dx)<0.1 && Math.abs(dy)<0.1) nextC.targetX=null;
                                else { nextC.x+=Math.sign(dx)*0.02; nextC.y+=Math.sign(dy)*0.02; nextC.dir=Math.sign(dx); }
                             }
                        }
                    } else {
                         if (Math.random() < 0.05) { nextC.targetX = rand(1, MAP_WIDTH-2); nextC.targetY = rand(1, MAP_HEIGHT-2); }
                         if (nextC.targetX) {
                            const dx = nextC.targetX - nextC.x; const dy = nextC.targetY - nextC.y;
                            if (Math.abs(dx)<0.1 && Math.abs(dy)<0.1) nextC.targetX=null;
                            else { nextC.x += Math.sign(dx)*0.04; nextC.y += Math.sign(dy)*0.04; nextC.dir=Math.sign(dx); nextC.animFrame++; }
                        }
                    }
                    nextC.x = clamp(nextC.x, 0, MAP_WIDTH-1); nextC.y = clamp(nextC.y, 0, MAP_HEIGHT-1);
                    return nextC;
                }).filter(Boolean));

                setSims(prev => {
                    let newBabies = [];
                    const updatedSims = prev.map(s => {
                        if (s.state === 'DEAD') return s;
                        let nextS = { ...s };

                        if (nextS.buffTimer > 0) nextS.buffTimer--;
                        if (nextS.mateCooldown > 0) nextS.mateCooldown--;

                        creatures.forEach(c => {
                            if (['WOLF', 'BEAR', 'DINOSAUR'].includes(c.type) && c.hp > 0) {
                                const dist = Math.sqrt((c.x - nextS.x)**2 + (c.y - nextS.y)**2);
                                if (dist < 1) {
                                    if (tickRef.current % 30 === 0) {
                                        const dmg = c.type === 'DINOSAUR' ? 40 : (c.type === 'BEAR' ? 15 : 8);
                                        nextS.hp -= dmg;
                                        if (nextS.hp <= 0) { nextS.state = 'DEAD'; nextS.hidden = false; addEvent(`‚ò†Ô∏è ${nextS.sign} Ë¢´ ${c.type} ÂêûÂô¨‰∫ÜÔºÅ`); }
                                    }
                                }
                            }
                        });
                        
                        if (nextS.state === 'DEAD') return nextS;

                        if (tickRef.current % 10 === 0) {
                            nextS.hunger -= 0.2; nextS.energy -= 0.1;
                            if (nextS.hunger > 80 && nextS.energy > 80) nextS.mood = Math.min(100, nextS.mood + 1);
                            if (nextS.hunger < 30 || nextS.energy < 30 || nextS.sick) nextS.mood = Math.max(0, nextS.mood - 1);
                            if (nextS.hunger <= 0 || nextS.hp <= 0) { nextS.state = 'DEAD'; nextS.hidden = false; addEvent(`${nextS.sign} ÈÄùÂéª‰∫Ü...`); return nextS; }
                        }
                        
                        prev.forEach(attacker => {
                            if (attacker.id !== nextS.id && attacker.state === 'FIGHTING' && attacker.targetId === nextS.id && attacker.state !== 'DEAD') {
                                const dist = Math.sqrt((attacker.x - nextS.x)**2 + (attacker.y - nextS.y)**2);
                                if (dist < 1.5) {
                                    if (tickRef.current % 20 === 0) { 
                                        let dmg = 5; 
                                        if (attacker.tools.spear) dmg = 15; else if (attacker.tools.axe) dmg = 10; else if (attacker.tools.pick) dmg = 8;
                                        if (attacker.trait === 'Â•ΩÈ¨•') dmg += 3;
                                        nextS.hp -= dmg;
                                        nextS.mood -= 10; 
                                        if (nextS.state !== 'FIGHTING' && nextS.state !== 'FLEE') {
                                            if (nextS.hp > 30) { nextS.state = 'FIGHTING'; nextS.targetId = attacker.id; } 
                                            else { nextS.state = 'FLEE'; nextS.targetX = rand(1, MAP_WIDTH-2); nextS.targetY = rand(1, MAP_HEIGHT-2); }
                                        }
                                        setParticles(p => [...p, { x: nextS.x*TILE_SIZE, y: nextS.y*TILE_SIZE, life: 20, color: '#ff0000', vy: -2, text: `-${dmg}` }]);
                                        if (nextS.hp <= 0) { addEvent(`‚ò†Ô∏è ${attacker.sign} ÊÆ∫ÂÆ≥‰∫Ü ${nextS.sign}ÔºÅ`); nextS.state = 'DEAD'; nextS.hidden = false; }
                                    }
                                }
                            }
                        });
                        if (nextS.state === 'DEAD') return nextS;

                        if (nextS.mood < 20 && !nextS.hidden && nextS.state !== 'FIGHTING' && nextS.state !== 'FLEE') {
                            const victim = prev.find(v => v.id !== nextS.id && !v.hidden && v.state !== 'DEAD' && Math.sqrt((v.x-nextS.x)**2+(v.y-nextS.y)**2) < 3);
                            if (victim) {
                                nextS.state = 'FIGHTING'; nextS.targetId = victim.id; nextS.thought = 'Áúã‰Ω†‰∏çÈ†ÜÁúºÔºÅ';
                                setParticles(p => [...p, { x: nextS.x*TILE_SIZE, y: nextS.y*TILE_SIZE, life: 30, color: '#f00', vy: -1, text: 'üí¢' }]);
                            }
                        }

                        if (nextS.mood > 80 && tribe.food > 50 && prev.length + newBabies.length < MAX_POPULATION && nextS.age > 16 && nextS.mateCooldown <= 0 && !nextS.hidden) {
                            const partner = prev.find(p => p.id !== nextS.id && !p.hidden && p.age > 16 && p.gender !== nextS.gender && Math.sqrt((p.x-nextS.x)**2+(p.y-nextS.y)**2) < 1.5);
                            if (partner && Math.random() < 0.005) {
                                nextS.mateCooldown = 1000;
                                const baby = generateSim(null, nextS.x, nextS.y, Math.max(nextS.generation, partner.generation) + 1);
                                baby.age = 0; baby.thought = "ÂìáÂìáÔºÅ";
                                newBabies.push(baby);
                                setParticles(p => [...p, { x: nextS.x*TILE_SIZE, y: nextS.y*TILE_SIZE, life: 60, color: '#ff69b4', vy: -1, text: '‚ù§Ô∏è' }]);
                                addEvent(`‚ù§Ô∏è ${nextS.sign} Ëàá ${partner.sign} Ë™ïÁîü‰∫ÜÊñ∞ÁîüÂëΩ (Gen ${baby.generation})`);
                            }
                        }

                        if (nextS.state === 'FIGHTING') {
                            const target = prev.find(t => t.id === nextS.targetId);
                            if (target && target.state !== 'DEAD' && !target.hidden) {
                                nextS.targetX = target.x; nextS.targetY = target.y;
                            } else { nextS.state = 'IDLE'; nextS.thought = 'ÂìºÔºå‰∏çÂ†™‰∏ÄÊìä„ÄÇ'; }
                        }
                        
                        const distToTarget = nextS.targetX !== null ? Math.sqrt((nextS.x - nextS.targetX)**2 + (nextS.y - nextS.targetY)**2) : 0;
                        const inBase = isInBase(nextS);

                        if (nextS.state === 'IDLE') {
                            if (!nextS.hidden) {
                                if (bossTargetId && (nextS.tools.spear || nextS.tools.axe) && nextS.hp > 40) {
                                    nextS.state = 'DEFEND'; nextS.targetId = bossTargetId; nextS.thought = 'ÂêàÂäõË®é‰ºêÔºÅ';
                                } else {
                                    const nearestEnemy = creatures.find(c => ['WOLF','BEAR','DINOSAUR'].includes(c.type) && c.hp > 0 && Math.sqrt((c.x-nextS.x)**2 + (c.y-nextS.y)**2) < 6);
                                    if (nearestEnemy) {
                                        const brave = nextS.trait === 'Â•ΩÈ¨•' || nextS.mood < 40;
                                        const hasWeapon = nextS.tools.spear || nextS.tools.axe || nextS.tools.pick;
                                        const isScary = nearestEnemy.type === 'DINOSAUR' && (!hasWeapon || nextS.hp < 60);

                                        if (!isScary && nextS.hp > 30 && (hasWeapon || brave)) {
                                            nextS.state = 'DEFEND'; nextS.targetId = nearestEnemy.id; nextS.thought = hasWeapon ? 'ÂèóÊ≠ªÂêßÔºÅ' : 'Ë∑ü‰Ω†Êãº‰∫ÜÔºÅ';
                                        } else {
                                            nextS.state = 'FLEE'; nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2; nextS.thought = 'Âø´Ë∑ëÂïäÔºÅ';
                                        }
                                    }
                                }
                            }

                            if (nextS.state === 'IDLE') {
                                if (!nextS.tools.spear && tribe.wood >= 10 && tribe.stone >= 5) {
                                    nextS.state = 'CRAFT_SPEAR'; nextS.actionTimer = 100; nextS.thought = 'Ë£Ω‰ΩúÈï∑Áüõ...';
                                } else if (!nextS.tools.axe && tribe.wood >= 10 && tribe.stone >= 5) {
                                    nextS.state = 'CRAFT_AXE'; nextS.actionTimer = 100; nextS.thought = 'Ë£Ω‰ΩúÊñßÈ†≠...';
                                } else if (!nextS.tools.pick && tribe.wood >= 10 && tribe.stone >= 5) {
                                    nextS.state = 'CRAFT_PICK'; nextS.actionTimer = 100; nextS.thought = 'Ë£Ω‰ΩúÈé¨Â≠ê...';
                                } else if (nextS.hunger < 50) {
                                    if (tribe.food > 0 && inBase) {
                                        setTribe(t => ({...t, food: Math.max(0, t.food-10)}));
                                        nextS.hunger = 100; nextS.thought = 'ÂêÉÈ£Ω‰∫ÜÔºÅ';
                                    } else {
                                        let potentialPrey = null;
                                        potentialPrey = creatures.find(c => ['RABBIT', 'DEER'].includes(c.type) && c.hp > 0 && Math.sqrt((c.x-nextS.x)**2 + (c.y-nextS.y)**2) < 15);
                                        if (!potentialPrey && (nextS.tools.spear || nextS.tools.axe)) {
                                            potentialPrey = creatures.find(c => ['WOLF', 'BEAR'].includes(c.type) && c.hp > 0 && Math.sqrt((c.x-nextS.x)**2 + (c.y-nextS.y)**2) < 10);
                                        }

                                        if (potentialPrey) {
                                            nextS.state = 'HUNT'; nextS.targetId = potentialPrey.id; nextS.thought = 'ÁôºÁèæÁçµÁâ©ÔºÅ';
                                        } else {
                                            const harvestable = farms.find(f => f.stage >= 100);
                                            if (harvestable && tribe.tech >= 1) {
                                                nextS.state = 'FARMING'; nextS.targetX = harvestable.x; nextS.targetY = harvestable.y;
                                            } else {
                                                if (Math.random() < 0.5) {
                                                    nextS.state = 'GATHER'; nextS.targetX = rand(1,MAP_WIDTH-2); nextS.targetY = rand(1,MAP_HEIGHT-2); nextS.thought='ÂæíÊâãÊé°ÈõÜ...';
                                                } else {
                                                    nextS.targetX = nextS.x + rand(-2,2); nextS.targetY = nextS.y + rand(-2,2); 
                                                }
                                            }
                                        }
                                    }
                                } else if (nextS.energy < 20 || (isNight && !inBase)) {
                                    nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2;
                                    if (inBase) { nextS.state = 'SLEEP'; nextS.hidden = true; nextS.thought = 'ÈÄ≤Ê¥û‰ºëÊÅØ...'; }
                                } else {
                                    if (nextS.hidden) { nextS.hidden = false; nextS.y += 1; }
                                    if (Math.random() < 0.02) {
                                         const task = Math.random();
                                         if (task < 0.3 && nextS.tools.axe) { nextS.state = 'CHOP'; nextS.targetX = rand(1,MAP_WIDTH-2); nextS.targetY=rand(1,MAP_HEIGHT-2); nextS.thought='Âéª‰ºêÊú®'; }
                                         else if (task < 0.6 && nextS.tools.pick) { nextS.state = 'MINE'; nextS.targetX = rand(1,MAP_WIDTH-2); nextS.targetY=rand(1,MAP_HEIGHT-2); nextS.thought='ÂéªÊé°Á§¶'; }
                                         else { 
                                             if (Math.random() < 0.5) { nextS.state = 'GATHER'; nextS.targetX = rand(1,MAP_WIDTH-2); nextS.targetY = rand(1,MAP_HEIGHT-2); nextS.thought='ÂæíÊâãÊé°ÈõÜ...'; } 
                                             else { nextS.targetX = nextS.x + rand(-2,2); nextS.targetY = nextS.y + rand(-2,2); }
                                         }
                                    }
                                }
                            }
                        } 
                        else if (['CRAFT_AXE','CRAFT_PICK','CRAFT_SPEAR'].includes(nextS.state)) {
                            nextS.actionTimer--;
                            if (nextS.actionTimer <= 0) {
                                if (nextS.state === 'CRAFT_AXE') { nextS.tools.axe = true; setTribe(t => ({...t, wood: Math.max(0, t.wood-10), stone: Math.max(0, t.stone-5)})); }
                                else if (nextS.state === 'CRAFT_PICK') { nextS.tools.pick = true; setTribe(t => ({...t, wood: Math.max(0, t.wood-10), stone: Math.max(0, t.stone-5)})); }
                                else if (nextS.state === 'CRAFT_SPEAR') { nextS.tools.spear = true; setTribe(t => ({...t, wood: Math.max(0, t.wood-10), stone: Math.max(0, t.stone-5)})); }
                                nextS.state = 'IDLE'; nextS.thought = 'Â∑•ÂÖ∑ÂÆåÊàê‰∫Ü';
                            }
                        }
                        else if (['CHOP','MINE','GATHER'].includes(nextS.state)) {
                            if(nextS.actionTimer > 0) nextS.actionTimer--;
                            else if (distToTarget < 1.0) {
                                if (nextS.state === 'CHOP') { 
                                    setTribe(t=>({...t, wood:t.wood+20})); nextS.state='IDLE'; nextS.thought='Êú®È†≠ÂÖ•Êâã'; 
                                    // 2. Map Interaction: Remove Tree
                                    actionQueue.current.push({type: 'REMOVE_DECO', x: Math.round(nextS.targetX), y: Math.round(nextS.targetY)});
                                }
                                else if (nextS.state === 'MINE') { 
                                    setTribe(t=>({...t, stone:t.stone+10})); nextS.state='IDLE'; nextS.thought='Áü≥È†≠ÂÖ•Êâã'; 
                                    // 2. Map Interaction: Remove Rock
                                    actionQueue.current.push({type: 'REMOVE_DECO', x: Math.round(nextS.targetX), y: Math.round(nextS.targetY)});
                                }
                                else if (nextS.state === 'GATHER') { 
                                    const r = Math.random();
                                    if (r < 0.6) { setTribe(t=>({...t, food:t.food+10})); nextS.thought='ÊâæÂà∞È£üÁâ©'; }
                                    else if (r < 0.8) { setTribe(t=>({...t, wood:t.wood+5})); nextS.thought='ÊíøÂà∞Ê®πÊûù'; }
                                    else { setTribe(t=>({...t, stone:t.stone+3})); nextS.thought='ÊíøÂà∞Áü≥Â°ä'; }
                                    nextS.state='IDLE'; 
                                }
                            }
                        } else if (nextS.state === 'SLEEP') {
                            if(nextS.energy>=100){ nextS.state='IDLE'; nextS.hidden=false; nextS.y+=1; }
                        } else if (nextS.state === 'DEFEND' || nextS.state === 'HUNT') {
                            const enemy = creatures.find(c => c.id === nextS.targetId && c.hp > 0);
                            if (enemy) {
                                nextS.targetX = enemy.x; nextS.targetY = enemy.y;
                            } else { nextS.state = 'IDLE'; nextS.thought = 'ÁõÆÊ®ôÂ∑≤ÂÄí‰∏ã'; }
                        } else if (nextS.state === 'FLEE') {
                             const distToCave = Math.sqrt((nextS.x - MAP_WIDTH/2)**2 + (nextS.y - MAP_HEIGHT/2)**2);
                             if (distToCave < 1.5) { nextS.hidden = true; nextS.state = 'HIDING'; nextS.thought = 'Âëº...Ë∫≤Ëµ∑‰æÜ„ÄÇ'; nextS.targetX = null; }
                        }

                        if (nextS.targetX !== null) {
                             nextS.targetX = clamp(nextS.targetX, 1, MAP_WIDTH-2);
                             nextS.targetY = clamp(nextS.targetY, 1, MAP_HEIGHT-2);
                             const dx = nextS.targetX - nextS.x; const dy = nextS.targetY - nextS.y;
                             if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) { nextS.targetX = null; }
                             else {
                                 let spd = nextS.buffTimer > 0 ? 0.08 : 0.05;
                                 if (nextS.state === 'FLEE') spd = 0.08;
                                 else if (nextS.state === 'HUNT') spd = 0.07; 
                                 nextS.x += Math.sign(dx) * spd; nextS.y += Math.sign(dy) * spd;
                                 nextS.dir = Math.sign(dx); nextS.animFrame++;
                             }
                        }
                        
                        nextS.x = clamp(nextS.x, 1, MAP_WIDTH-2);
                        nextS.y = clamp(nextS.y, 1, MAP_HEIGHT-2);

                        return nextS;
                    });
                    return [...updatedSims, ...newBabies];
                });
                
                // Process Map Actions
                if (actionQueue.current.length > 0) {
                    setMap(prevMap => {
                        const newMap = prevMap.map(row => [...row]);
                        let changed = false;
                        actionQueue.current.forEach(action => {
                            if (action.y >= 0 && action.y < MAP_HEIGHT && action.x >= 0 && action.x < MAP_WIDTH) {
                                if (action.type === 'REMOVE_DECO') {
                                    if (newMap[action.y][action.x].decoration) {
                                        newMap[action.y][action.x].decoration = null;
                                        changed = true;
                                    }
                                } else if (action.type === 'DESTROY') {
                                    if (newMap[action.y][action.x].decoration) {
                                        newMap[action.y][action.x].decoration = null;
                                        changed = true;
                                    }
                                    if (newMap[action.y][action.x].type === 'FOREST') {
                                        newMap[action.y][action.x].type = 'DIRT'; // Burn ground
                                        changed = true;
                                    }
                                } else if (action.type === 'GROW') {
                                    const tile = newMap[action.y][action.x];
                                    if (!tile.decoration && (tile.type === 'GRASS' || tile.type === 'FOREST')) {
                                        const r = Math.random();
                                        if (r < 0.1) tile.decoration = 'TREE_OAK';
                                        else if (r < 0.2) tile.decoration = 'TREE_PINE';
                                        else if (r < 0.3) tile.decoration = 'BUSH';
                                        else if (r < 0.4) tile.decoration = 'FLOWER';
                                        changed = true;
                                    }
                                }
                            }
                        });
                        actionQueue.current = []; // Clear queue
                        return changed ? newMap : prevMap;
                    });
                }

            }, [time, weather, farms, tribe, isGameOver, map, creatures, disaster, sims, flash]);

            const isInBase = (sim) => Math.sqrt((sim.x - MAP_WIDTH/2)**2 + (sim.y - MAP_HEIGHT/2)**2) < 6;

            const currentStage = CIV_STAGES.slice().reverse().find(s => tribe.tech >= s.minTech) || CIV_STAGES[0];

            const draw = useCallback(() => {
                const canvas = canvasRef.current; if (!canvas || !sprites) return;
                const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
                ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save(); ctx.scale(SCALE, SCALE);
                if (shake > 0) ctx.translate(shake, shake);

                map.forEach(row => row.forEach(tile => {
                    const px = tile.x * TILE_SIZE; const py = tile.y * TILE_SIZE;
                    if (tile.type === 'SAND') ctx.drawImage(sprites.sand, px, py);
                    else if (tile.type === 'MOUNTAIN_GROUND') ctx.drawImage(sprites.mountain, px, py);
                    else if (tile.type === 'WATER') { ctx.fillStyle = PALETTE.WATER; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
                    else if (tile.type === 'DIRT') ctx.drawImage(sprites.dirt, px, py);
                    else ctx.drawImage(sprites.grass, px, py);
                }));

                const objects = [];
                map.forEach(row => row.forEach(tile => { if (tile.decoration) objects.push({ y: tile.y, type: 'DECO', subtype: tile.decoration, x: tile.x }); }));
                sims.forEach(sim => { if(!sim.hidden) objects.push({ y: sim.y, type: 'SIM', data: sim }) });
                creatures.forEach(c => objects.push({ y: c.y, type: 'CREATURE', data: c }));
                objects.sort((a, b) => a.y - b.y);

                objects.forEach(obj => {
                    const px = obj.x * TILE_SIZE; const py = obj.y * TILE_SIZE;
                    if (obj.type === 'DECO') {
                        if (obj.subtype === 'BASE') ctx.drawImage(sprites[currentStage.sprite], px - 16, py - 24);
                        else if (obj.subtype === 'TREE_OAK') ctx.drawImage(sprites.tree_oak, px, py - TILE_SIZE);
                        else if (obj.subtype === 'TREE_PINE') ctx.drawImage(sprites.tree_pine, px, py - TILE_SIZE);
                        else if (obj.subtype === 'ROCK') ctx.drawImage(sprites.rock, px, py);
                        else if (obj.subtype === 'BUSH') ctx.drawImage(sprites.bush, px, py);
                        else if (obj.subtype === 'FLOWER') ctx.drawImage(sprites.flower, px, py);
                        else if (obj.subtype === 'MUSHROOM') ctx.drawImage(sprites.mushroom, px, py);
                    } else if (obj.type === 'SIM') drawSim(ctx, obj.data);
                    else if (obj.type === 'CREATURE') drawCreature(ctx, obj.data);
                });

                if (selectedId) {
                    if (selectedId === 'BASE_CENTER') {
                        const cx = (MAP_WIDTH / 2) * TILE_SIZE;
                        const cy = (MAP_HEIGHT / 2) * TILE_SIZE;
                        ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 3;
                        ctx.beginPath(); ctx.arc(cx + 16, cy + 16, 40, 0, Math.PI*2); ctx.stroke();
                    } else {
                        const target = [...sims, ...creatures].find(i => i.id === selectedId);
                        if (target && !target.hidden) {
                            const px = target.x * TILE_SIZE; const py = target.y * TILE_SIZE;
                            ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1.5; ctx.setLineDash([4, 2]);
                            
                            // DYNAMIC SELECTION BOX
                            let w = TILE_SIZE;
                            let h = TILE_SIZE;
                            let ox = 0;
                            let oy = 0;

                            if (target.type === 'DINOSAUR') {
                                w = 48; // Wider
                                h = 48; // Taller
                                ox = 10; // Shift right to cover body
                                oy = -10; // Shift up if needed
                            } else if (target.type === 'BEAR') {
                                w = 40;
                            }

                            ctx.strokeRect(px + ox, py + oy, w, h); 
                            ctx.setLineDash([]);
                        }
                    }
                }

                particles.forEach(p => {
                    if (p.text) {
                        ctx.font = '12px serif'; 
                        ctx.fillText(p.text, p.x, p.y);
                    } else {
                        ctx.fillStyle = p.color || '#fff';
                        const w = p.type === 'METEOR' ? 4 : (p.type === 'FLASH' ? 32 : 2);
                        const h = p.type === 'METEOR' ? 4 : (p.type === 'FLASH' ? 32 : 2);
                        if (p.type === 'METEOR') { 
                            ctx.fillStyle = '#ff8800'; 
                            ctx.fillRect(p.x + 2, p.y - 4, 2, 4); 
                            ctx.fillStyle = '#ff4500'; 
                        }
                        else if (p.type === 'SPORE') {
                             ctx.fillStyle = '#4caf50';
                             ctx.fillRect(p.x, p.y, 2, 2);
                        }
                        else ctx.fillRect(p.x, p.y, w, h);
                    }
                });

                if (disaster !== DISASTERS.NONE && disaster.color) {
                     const pulse = 0.8 + Math.sin(tickRef.current / 20) * 0.2;
                     let baseColor = disaster.color;
                     if (disaster === DISASTERS.DARKNESS) {
                         ctx.fillStyle = baseColor;
                     } else {
                         let parts = baseColor.match(/[\d.]+/g);
                         if (parts && parts.length === 4) {
                             ctx.fillStyle = `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${parseFloat(parts[3]) * pulse})`;
                         } else {
                             ctx.fillStyle = baseColor; 
                         }
                     }
                     ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); 
                }
                else if (time > DAY_TICKS * 0.6) { 
                    ctx.fillStyle = 'rgba(10, 10, 30, 0.5)'; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); 
                }
                
                if (flash > 0) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${flash})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height); // Full screen
                }

                ctx.restore();
            }, [map, sprites, sims, creatures, weather, particles, farms, time, selectedId, tribe, disaster, shake, currentStage, flash]);

            const drawSim = (ctx, s) => {
                if (s.state === 'DEAD') { 
                    const px = Math.floor(s.x * TILE_SIZE); const py = Math.floor(s.y * TILE_SIZE);
                    ctx.drawImage(sprites.skull, px + 4, py + 10); 
                    return; 
                }
                const px = Math.floor(s.x * TILE_SIZE); const py = Math.floor(s.y * TILE_SIZE);
                const bounce = (s.state !== 'IDLE') ? Math.sin(s.animFrame) * 2 : 0;
                
                if (s.buffTimer > 0) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 + Math.sin(tickRef.current/5)*0.3})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(px+16, py+16, 12, 0, Math.PI*2); ctx.stroke();
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.2)'; ctx.fill();
                    ctx.restore();
                }

                const matrix = s.gender === 'M' ? SPRITE_MATRICES.CHAR_M : SPRITE_MATRICES.CHAR_F;
                const skinColor = s.sick ? PALETTE.SICK_SKIN : PALETTE.SKIN;
                renderMatrix(ctx, matrix, { 'H': s.hair, 'S': skinColor, 's': PALETTE.SKIN_SHADOW, 'C': s.color, 'K': PALETTE.OUTLINE }, px + 4, py + 4 + bounce);
                
                // Draw Tools
                let showTool = null;
                
                if (s.state === 'CHOP' && s.tools.axe) showTool = 'AXE';
                else if (s.state === 'MINE' && s.tools.pick) showTool = 'PICK';
                else if (s.state === 'DEFEND' || s.state === 'HUNT' || s.state === 'FIGHTING') showTool = s.tools.spear ? 'SPEAR' : (s.tools.axe ? 'AXE' : (s.tools.pick ? 'PICK' : null));
                else if (s.tools.spear) showTool = 'SPEAR';
                else if (s.tools.axe) showTool = 'AXE';
                else if (s.tools.pick) showTool = 'PICK';

                if (showTool === 'SPEAR') {
                    ctx.fillStyle = PALETTE.TOOL_AXE; ctx.fillRect(px+24, py+4+bounce, 2, 16); 
                    ctx.fillStyle = '#bdc3c7'; ctx.fillRect(px+23, py+2+bounce, 4, 4); 
                } else if (showTool === 'AXE') {
                    ctx.fillStyle = PALETTE.TOOL_AXE; ctx.fillRect(px+22, py+10+bounce, 2, 10); 
                    ctx.fillStyle = '#7f8c8d'; ctx.fillRect(px+20, py+10+bounce, 6, 4); 
                } else if (showTool === 'PICK') {
                    ctx.fillStyle = PALETTE.TOOL_AXE; ctx.fillRect(px+22, py+10+bounce, 2, 10); 
                    ctx.fillStyle = '#95a5a6'; ctx.fillRect(px+18, py+10+bounce, 10, 2); 
                }

                if (s.state === 'FIGHTING' || s.state === 'DEFEND') { ctx.font='10px serif'; ctx.fillText('‚öîÔ∏è', px+8, py); }
                if (s.state.includes('CRAFT')) { ctx.font = '10px monospace'; ctx.fillStyle = '#ffff00'; ctx.fillText('üî®', px+8, py); }
                if (s.age < 16) { ctx.font='10px serif'; ctx.fillText('üë∂', px, py); } 
            };

            const drawCreature = (ctx, c) => {
                const px = Math.floor(c.x * TILE_SIZE); const py = Math.floor(c.y * TILE_SIZE);
                let matrix = SPRITE_MATRICES[c.type] || SPRITE_MATRICES.RABBIT;
                let colors = {'W': PALETTE.FUR_RABBIT, 'G': PALETTE.FUR_WOLF, 'B': PALETTE.FUR_BEAR, 'K': PALETTE.OUTLINE};
                if (c.type === 'DINOSAUR') {
                    colors = {'G': PALETTE.DINO_GREEN, 'Y': PALETTE.DINO_EYE, 'K': PALETTE.OUTLINE};
                }

                ctx.save(); 
                if (c.dir < 0) { 
                    const width = c.type === 'DINOSAUR' ? TILE_SIZE * 2 : TILE_SIZE;
                    ctx.translate(px + width, 0); ctx.scale(-1, 1); ctx.translate(-px, 0); 
                }
                renderMatrix(ctx, matrix, colors, px, py);
                
                // Boss HP Bar
                if (c.type === 'DINOSAUR') {
                    ctx.fillStyle = 'red'; ctx.fillRect(px + 10, py - 5, 40, 4);
                    ctx.fillStyle = '#00ff00'; ctx.fillRect(px + 10, py - 5, 40 * (c.hp / 800), 4);
                }

                ctx.restore();
            };

            useEffect(() => {
                const loop = () => {
                    tickRef.current++;
                    if (tickRef.current % 5 === 0) { setTime(t => (t + 1) % DAY_TICKS); if (time === 0) setDay(d => d+1); update(); }
                    draw(); requestRef.current = requestAnimationFrame(loop);
                };
                requestRef.current = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(requestRef.current);
            }, [draw, update]);

            const handleCanvasClick = useCallback((e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = (e.clientX - rect.left) / SCALE / TILE_SIZE;
                const y = (e.clientY - rect.top) / SCALE / TILE_SIZE;
                let closest = null; let minDist = 2.5;
                // Priority to LIVING sims/creatures first for selection
                [...sims.filter(s => !s.hidden), ...creatures].forEach(obj => { 
                    const d = Math.sqrt((obj.x+0.5-x)**2 + (obj.y+0.5-y)**2); 
                    // Skip dead bodies for primary selection unless very close and nothing else
                    if (obj.state === 'DEAD' && d > 0.5) return; 
                    if(d<minDist){ closest=obj; minDist=d; } 
                });
                
                if (closest) {
                    setSelectedId(closest.id);
                } else if (Math.sqrt((x-MAP_WIDTH/2)**2+(y-MAP_HEIGHT/2)**2) < 2.5) { 
                    setSelectedId('BASE_CENTER');
                } else {
                    setSelectedId(null);
                }
            }, [sims, creatures]);

            const selectedObj = [...sims, ...creatures].find(s => s.id === selectedId);

            return (
                <div className="flex flex-col h-[100dvh] bg-[#1a1c2c] text-[#c2c3c7]" style={{ fontFamily: PIXEL_FONT }}>
                    {/* Top Bar */}
                    <div className="bg-[#292b3c] p-2 border-b-4 border-[#121215] flex justify-between items-center shadow-lg shrink-0 z-20">
                        <div className="flex gap-4 items-center">
                            <div className="text-[#ffcd75] font-bold flex items-center gap-2"><Icons.Sparkles size={16}/> {mana}</div>
                            <div className="bg-black/40 px-3 py-1 rounded text-sm flex items-center gap-2">
                                <span className="text-2xl">{currentStage.icon}</span>
                                <div><div className="text-[10px] text-gray-400">Day {day}</div><div className="text-white font-bold">{currentStage.name}</div></div>
                            </div>
                        </div>
                        <div className="flex gap-3 text-xs font-bold text-[#8b9bb4]">
                            <span className="flex items-center gap-1"><Icons.Users size={12}/> {sims.filter(s=>s.state!=='DEAD').length}/{MAX_POPULATION}</span>
                            <span>üçé {Math.floor(tribe.food)}</span>
                            <span>üî® Tech Lv.{tribe.tech}</span>
                        </div>
                    </div>

                    {/* Main Game Area */}
                    <div className="flex-1 flex flex-col md:flex-row overflow-hidden relative">
                        {isGameOver && (
                            <div className="absolute inset-0 z-[60] bg-black/90 flex flex-col items-center justify-center animate-in fade-in zoom-in">
                                <h1 className="text-4xl text-red-500 font-bold mb-8">ÊñáÊòéÊÆûËêΩ</h1>
                                <button onClick={startNextEra} className="bg-red-900 px-8 py-4 rounded border-2 border-red-500 text-white flex items-center gap-2 hover:bg-red-800"><Icons.RefreshCw/> ÈáçÂïüÊñáÊòé</button>
                            </div>
                        )}

                        <div className="relative flex-1 bg-black overflow-hidden flex">
                            <div className="w-full h-full overflow-auto flex items-center justify-center p-4 bg-[#0d0d10]">
                                <canvas ref={canvasRef} width={MAP_WIDTH * TILE_SIZE * SCALE} height={MAP_HEIGHT * TILE_SIZE * SCALE} onClick={handleCanvasClick} className="border-4 border-[#3e2723] shadow-2xl cursor-crosshair" style={{ imageRendering: 'pixelated' }} />
                            </div>
                            
                            {/* Updated Log Window with Collapse and Mobile Scrolling */}
                            <div className={`absolute bottom-4 left-4 w-72 flex flex-col gap-1 z-30 transition-all duration-300 ${isLogOpen ? 'max-h-64' : 'max-h-10'}`}>
                                <div className="flex justify-between items-center bg-[#292b3c] p-1 rounded-t border-t border-l border-r border-[#5d4037] cursor-pointer shadow-lg" onClick={() => setIsLogOpen(!isLogOpen)}>
                                    <span className="text-xs text-[#ffcd75] font-bold px-2">üìú Ê≠∑Âè≤Á¥ÄÈåÑ</span>
                                    <button className="text-gray-400 hover:text-white px-2">
                                        {isLogOpen ? <Icons.ChevronDown size={14}/> : <Icons.ChevronUp size={14}/>}
                                    </button>
                                </div>
                                
                                {isLogOpen ? (
                                    <div className="bg-black/80 p-2 overflow-y-auto h-48 rounded-b border-b border-l border-r border-[#5d4037] scrollbar-thin pointer-events-auto touch-pan-y shadow-xl">
                                         {events.map((ev) => (
                                            <div key={ev.id} className="log-item text-white px-2 py-1 text-xs border-b border-gray-800 last:border-0">
                                                {ev.text}
                                            </div>
                                        ))}
                                         <div ref={logEndRef} />
                                    </div>
                                ) : (
                                    // Collapsed view: Show only latest message
                                    <div className="bg-black/80 p-2 rounded-b border-b border-l border-r border-[#5d4037] pointer-events-auto touch-pan-y shadow-xl">
                                        <div className="text-white text-xs truncate px-1">
                                            {events[events.length - 1]?.text || "..."}
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* Sidebar - Increased height to 45vh for mobile to prevent hiding details */}
                        <div className="w-full h-[45vh] md:w-72 md:h-auto bg-[#292b3c] border-t-4 md:border-t-0 md:border-l-4 border-[#121215] p-2 md:p-3 flex flex-col gap-2 md:gap-3 shadow-2xl z-20 shrink-0">
                            <div className="bg-[#1a1c2c] p-2 md:p-3 rounded border border-[#3e2723]">
                                <h3 className="text-[#ffcd75] text-sm mb-2 font-bold border-b border-[#3e2723] pb-1">Á•ûË´≠</h3>
                                <div className="grid grid-cols-4 gap-2">
                                    <button onClick={() => castSpell('SUN')} className="btn bg-[#3e2723] p-2 rounded flex items-center justify-center"><Icons.Sun className="text-yellow-400"/></button>
                                    <button onClick={() => castSpell('RAIN')} className="btn bg-[#3e2723] p-2 rounded flex items-center justify-center"><Icons.CloudRain className="text-blue-400"/></button>
                                    <button onClick={() => castSpell('TECH')} disabled={tribe.tech>=20} className="btn bg-[#3e2723] p-2 rounded relative group flex items-center justify-center">
                                        <Icons.Brain className="text-purple-400"/>
                                        <span className="absolute -top-8 left-1/2 -translate-x-1/2 bg-black text-white text-[10px] px-2 py-1 rounded opacity-0 group-hover:opacity-100 whitespace-nowrap">Ë≥ú‰∫àÁßëÊäÄ (50)</span>
                                    </button>
                                    <button onClick={handleTribeSaga} disabled={isWritingSaga} className="btn bg-indigo-900 p-2 rounded flex items-center justify-center"><Icons.ScrollText className="text-indigo-300"/></button>
                                    <button onClick={() => castSpell('DISASTER')} disabled={mana < 100} className="col-span-4 bg-red-900/50 p-2 rounded flex items-center justify-center gap-2 border border-red-700 text-red-200 text-xs font-bold hover:bg-red-900"><Icons.Biohazard/> Èôç‰∏ãÂ§©ÁÅΩ (100)</button>
                                </div>
                            </div>

                            <div className="flex-1 bg-[#1a1c2c] p-2 md:p-3 rounded border border-[#3e2723] flex flex-col overflow-hidden">
                                <div className="flex justify-between items-center border-b border-[#3e2723] mb-2 pb-1">
                                    <h3 className="text-[#8b9bb4] text-sm font-bold">Ë©≥Á¥∞Ë≥áË®ä</h3>
                                    {selectedId && <button onClick={() => setSelectedId(null)}><Icons.X size={14}/></button>}
                                </div>
                                
                                <div className="flex-1 overflow-y-auto pr-1">
                                    {selectedId === 'BASE_CENTER' ? (
                                        <div className="space-y-2">
                                            <div className="text-center py-2 border-b border-gray-700">
                                                <div className="text-4xl mb-1">{currentStage.icon}</div>
                                                <div className="font-bold text-[#ffcd75] text-lg">{currentStage.name}</div>
                                                <div className="text-xs text-gray-400 mt-1 px-2">{currentStage.desc}</div>
                                            </div>
                                            
                                            <div className="grid grid-cols-2 gap-2 text-xs bg-black/30 p-2 rounded">
                                                <div className="flex justify-between"><span>üõ°Ô∏è Èò≤Á¶¶</span><span className="text-blue-300">{currentStage.stats.def}</span></div>
                                                <div className="flex justify-between"><span>‚ù§Ô∏è ÊÅ¢Âæ©</span><span className="text-green-300">+{currentStage.stats.heal}/s</span></div>
                                                <div className="flex justify-between col-span-2 border-t border-gray-700 pt-1 mt-1"><span>üì¶ Â∫´Â≠òÂÆπÈáè</span><span className="text-yellow-300">{currentStage.stats.cap}</span></div>
                                            </div>

                                            <div className="bg-[#111] p-2 rounded border border-gray-800">
                                                <div className="text-xs text-gray-400 font-bold mb-2 flex items-center gap-1"><Icons.Box size={12}/> Ë≥áÊ∫êÂÄâÂ∫´</div>
                                                <div className="grid grid-cols-3 gap-1 text-center text-xs">
                                                    <div className="bg-[#222] p-1 rounded"><div className="text-orange-400">üçé</div>{Math.floor(tribe.food)}</div>
                                                    <div className="bg-[#222] p-1 rounded"><div className="text-[#8d6e63]">ü™µ</div>{tribe.wood}</div>
                                                    <div className="bg-[#222] p-1 rounded"><div className="text-gray-400">üß±</div>{tribe.stone}</div>
                                                </div>
                                            </div>

                                            <div className="text-xs text-gray-400 font-bold mt-2 mb-1">ÈÅøÈõ£‰∏≠ ({sims.filter(s=>s.hidden && s.state !== 'DEAD').length}):</div>
                                            <div className="max-h-32 overflow-y-auto space-y-1">
                                                {sims.filter(s => s.hidden).map(s => <div key={s.id} className="text-[10px] bg-black p-1 rounded flex justify-between items-center"><span>{s.sign}</span><span className="text-gray-500 italic">zZz...</span></div>)}
                                                {sims.filter(s => s.hidden).length === 0 && <div className="text-center text-gray-600 text-[10px] py-2">ÁÑ°‰∫∫ÈÅøÈõ£</div>}
                                            </div>
                                        </div>
                                    ) : selectedObj ? (
                                        <div className="flex flex-col gap-2">
                                            {selectedObj.sign ? (
                                                <>
                                                    <div className="flex items-center gap-3">
                                                        <div className="w-10 h-10 border border-gray-600 bg-black relative overflow-hidden"><div className="absolute top-2 left-2 w-6 h-6" style={{backgroundColor: selectedObj.hair, borderRadius: '50% 50% 0 0'}}></div><div className="absolute top-4 left-1 w-8 h-8" style={{backgroundColor: selectedObj.color, borderRadius: '50% 50% 0 0'}}></div></div>
                                                        <div>
                                                            <div className="font-bold text-[#ffccaa]">{selectedObj.sign} <span className="text-[10px] text-gray-500">Gen{selectedObj.generation}</span></div>
                                                            <div className="text-xs text-gray-400">{selectedObj.trait} / {selectedObj.state}</div>
                                                        </div>
                                                    </div>
                                                    
                                                    <div className="space-y-2 mt-3">
                                                        {/* HP */}
                                                        <div>
                                                            <div className="flex justify-between text-[10px] text-gray-400 mb-0.5"><span>‚ù§Ô∏è ÁîüÂëΩ</span><span>{Math.floor(selectedObj.hp)}</span></div>
                                                            <div className="h-1.5 bg-gray-800 rounded-full overflow-hidden border border-gray-700">
                                                                <div className="h-full bg-red-500 transition-all duration-500" style={{width: `${(selectedObj.hp / (selectedObj.type==='DINOSAUR'?800: (selectedObj.type==='BEAR'?200:100)))*100}%`}}></div>
                                                            </div>
                                                        </div>
                                                        {/* Hunger (Only for Sims) */}
                                                        {selectedObj.hunger !== undefined && (
                                                            <div>
                                                                <div className="flex justify-between text-[10px] text-gray-400 mb-0.5"><span>üçñ È£¢È§ì</span><span>{Math.floor(selectedObj.hunger)}</span></div>
                                                                <div className="h-1.5 bg-gray-800 rounded-full overflow-hidden border border-gray-700">
                                                                    <div className="h-full bg-orange-500 transition-all duration-500" style={{width: `${selectedObj.hunger}%`}}></div>
                                                                </div>
                                                            </div>
                                                        )}
                                                        {/* Mood (Only for Sims) */}
                                                        {selectedObj.mood !== undefined && (
                                                            <div>
                                                                <div className="flex justify-between text-[10px] text-gray-400 mb-0.5"><span>üß† Á≤æÁ•û</span><span>{Math.floor(selectedObj.mood)}</span></div>
                                                                <div className="h-1.5 bg-gray-800 rounded-full overflow-hidden border border-gray-700">
                                                                    <div className="h-full bg-blue-400 transition-all duration-500" style={{width: `${selectedObj.mood}%`}}></div>
                                                                </div>
                                                                <div className="text-right text-[10px] text-gray-400 mt-0.5">
                                                                    {selectedObj.mood > 80 ? 'üíñ Ê∏¥ÊúõÁπÅË°ç' : (selectedObj.mood < 20 ? 'üí¢ ÊòìÊÄíÊö¥Ë∫Å' : (selectedObj.mood < 10 ? 'üòµ Â¥©ÊΩ∞' : 'Âπ≥Èùú'))}
                                                                </div>
                                                            </div>
                                                        )}
                                                    </div>

                                                    {selectedObj.thought && <div className="bg-black p-2 rounded text-[10px] text-[#a5d6a7] italic mt-2">"{selectedObj.thought}"</div>}
                                                    
                                                    {selectedObj.sign && (
                                                        <>
                                                            <div className="grid grid-cols-3 gap-2 mt-4 pt-4 border-t border-[#3e2723]">
                                                                <button onClick={() => castSpell('FOOD')} className="bg-[#3e2723] hover:bg-[#5d4037] p-2 rounded flex flex-col items-center"><Icons.Utensils className="text-orange-400"/><span className="text-[10px]">Ë≥úÈ£ü</span></button>
                                                                <button onClick={() => castSpell('HEAL')} className="bg-[#3e2723] hover:bg-[#5d4037] p-2 rounded flex flex-col items-center"><Icons.Heart className="text-red-400"/><span className="text-[10px]">Ê≤ªÁôí</span></button>
                                                                <button onClick={() => castSpell('BUFF')} className="bg-[#3e2723] hover:bg-[#5d4037] p-2 rounded flex flex-col items-center"><Icons.Shield className="text-blue-400"/><span className="text-[10px]">Ë≥úÁ¶è</span></button>
                                                            </div>
                                                            <button onClick={() => handleSoulSearch(selectedObj)} className="w-full mt-2 bg-gray-800 p-1.5 rounded text-[10px] border border-gray-600 text-purple-300">ÈùàÈ≠ÇÂÇæËÅΩ (10)</button>
                                                        </>
                                                    )}
                                                </>
                                            ) : (
                                                <div>
                                                    <div className="font-bold text-lg">{selectedObj.type}</div>
                                                    <div className="text-xs text-gray-500">HP: {selectedObj.hp}</div>
                                                </div>
                                            )}
                                        </div>
                                    ) : <div className="text-center text-gray-600 mt-10">ÈªûÊìäÂú∞ÂúñÁâ©‰ª∂Êü•Áúã</div>}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>