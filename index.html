<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÂéüÂàù‰πãÁÅ´ Primal Spark (EmojiÁâà)</title>
    
    <!-- 1. ËºâÂÖ• Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. ËºâÂÖ• React Ëàá ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- 3. ËºâÂÖ• Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* Á¶ÅÊ≠¢ÊâãÊ©ü‰∏äÁöÑÂΩàÊÄßÊç≤ÂãïÊïàÊûúÔºåÈÅøÂÖçÊìç‰ΩúÈÅäÊà≤ÊôÇÊãâÂãïÈ†ÅÈù¢ */
        body { margin: 0; overflow: hidden; background-color: #111; touch-action: none; }
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        /* Ëá™ÂÆöÁæ©Êç≤Ëª∏ */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #4a4a4a; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const { createRoot } = ReactDOM;

        // --- Icon Components ---
        const Icon = ({ char, className, size }) => (
            <span className={className} style={{ fontSize: size || 16, lineHeight: 1, display: 'inline-block' }}>{char}</span>
        );

        const Icons = {
            Sparkles: (p) => <Icon char="‚ú®" {...p}/>,
            Heart: (p) => <Icon char="‚ù§Ô∏è" {...p}/>,
            Utensils: (p) => <Icon char="üçñ" {...p}/>,
            Shield: (p) => <Icon char="üõ°Ô∏è" {...p}/>,
            CloudRain: (p) => <Icon char="üåßÔ∏è" {...p}/>,
            Snowflake: (p) => <Icon char="‚ùÑÔ∏è" {...p}/>,
            Sun: (p) => <Icon char="‚òÄÔ∏è" {...p}/>,
            Cloud: (p) => <Icon char="‚òÅÔ∏è" {...p}/>,
            Flame: (p) => <Icon char="üî•" {...p}/>,
            Mountain: (p) => <Icon char="‚õ∞Ô∏è" {...p}/>,
            Skull: (p) => <Icon char="üíÄ" {...p}/>,
            RefreshCw: (p) => <Icon char="üîÑ" {...p}/>,
            X: (p) => <Icon char="‚ùå" {...p}/>,
            Brain: (p) => <Icon char="üß†" {...p}/>,
            ScrollText: (p) => <Icon char="üìú" {...p}/>,
            MessageCircle: (p) => <Icon char="üí¨" {...p}/>,
            HelpCircle: (p) => <Icon char="‚ùì" {...p}/>,
            Users: (p) => <Icon char="üë•" {...p}/>
        };

        const apiKey = ""; 

        // --- Game Constants & Logic ---
        const PIXEL_FONT = "'Courier New', Courier, monospace";
        const TILE_SIZE = 32;
        const SCALE = 2.0; 

        const PALETTE = {
            OUTLINE: '#1a1c2c', SKIN: '#ffccaa', SKIN_SHADOW: '#d48e7e',
            GRASS_BG: '#388e3c', GRASS_L: '#4caf50', GRASS_D: '#1b5e20',
            DIRT: '#5d4037', WATER: '#4a69bd',
            WHEAT_1: '#a5d6a7', WHEAT_2: '#e6ee9c', WHEAT_3: '#fbc02d',
            STONE_L: '#b0bec5', STONE_M: '#78909c', STONE_D: '#546e7a',
            WOOD_L: '#8d6e63', WOOD_D: '#3e2723',
            LEAF_L: '#66bb6a', LEAF_D: '#2e7d32', LEAF_PINE: '#1b5e20',
            FLOWER_R: '#e57373', FLOWER_Y: '#fff176', MUSHROOM: '#f44336',
            FUR_WOLF: '#90a4ae', FUR_BEAR: '#4e342e', FUR_DEER: '#a1887f', FUR_RABBIT: '#fafafa',
            WHITE: '#ffffff', TRANSPARENT: null,
            GRAVE_STONE: '#78909c', GRAVE_DIRT: '#3e2723'
        };

        const callGemini = async (prompt) => {
            if (!apiKey) { console.warn("API Key Êú™Ë®≠ÂÆö"); return null; }
            try {
                const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || null;
            } catch (error) { console.error("Gemini API Error:", error); return null; }
        };

        const SPRITE_MATRICES = {
            CHAR_M: ["........................",".......HHHHHH...........","......HSSSSSSH..........",".....HSSKSSKSSH.........",".....HSSSSSSSSH.........","......SSSSSSSS..........","....CCCSCCCCSCCC........","....CCCSCCCCSCCC........","....CCCCCCCCCCCC........","....KKKCCCCCCKKK........","....K.KCCCCCCK.K........","......KSSSSSSK..........","......KSSSSSSK..........","......KKK..KKK.........."],
            CHAR_F: ["........................","......HHHHHHHH..........",".....HSSSSSSSSH.........",".....HSSKSSKSSH.........",".....HSSSSSSSSH.........",".....SSSSSSSSSS.........","....CCCSCCCCSCCC........","...CCCCSCCCCSCCCC.......","...CCCCCCCCCCCCCC.......","...CCCCCCCCCCCCCC.......","....CCCCCCCCCCCC........",".....KSSSSSSssk.........",".....KSSSSSSssk.........",".....KKK....KKK........."],
            TREE_OAK: [".......LLLLLL.......",".....LLLLLLLLLL.....","....LLLLLLLLLLLL....","...LLLLLLLLLLLLLL...","...LLLLLLLLLLLLLL...","....LLLLLLLLLLLL....",".....LLLLLLLLLL.....",".......WWWWWW.......",".......WWWWWW.......",".......WWWWWW.......","......WWWWWWWW......"],
            TREE_PINE: ["..........L.........",".........LLL........","........LLLLL.......",".......LLLLLLL......",".........LLL........","........LLLLL.......",".......LLLLLLL......","......LLLLLLLLL.....",".....LLLLLLLLLLL....","........WWWWW.......",".......WWWWWWW......"],
            BUSH: ["....................","......LLLLLLL.......",".....LLLLLLLLL......","....LLLLLLLLLLL.....","....LLLLLLLLLLL.....",".....LLLLLLLLL......"],
            FLOWER: [".........R..........","........RYR.........",".........R..........",".........G..........",".........G.........."],
            MUSHROOM: ["........RRR.........",".......RRRRR........",".......RWWWR........","........WWW.........","........WWW........."],
            ROCK: [".......KKKKKK.......",".....KKMMMMMMKK.....","....KMMLLLLLLMMK....","...KMLLLLLLLLLLMK...","...KMMMMMMMMMMMMK...","...KDDDDDDDDDDDDK...","....KKDDDDDDDDKK....","......KKKKKKKK......"],
            RABBIT: [".......KK...........","......KWWK..........",".....KWWWWK.........",".....KWWWWK.........","......KKKK.........."],
            WOLF: ["....................",".......K............","......KGK...........",".....KGGGK..........","....KGGGGGK...K.....","...KGGGGGGGGKKGK....","...KGGGGGGGGGGGK....","....KGGGGGGGGGK.....","....K.K.....K.K....."],
            BEAR: [".........KK...KK....","......KKKBBKKKBBK...",".....KBBBBBBBBBBBK..","....KBBBBBBBBBBBBBK.","...KBBBBBBBBBBBBBBBK","...KBBBBBBBBBBBBBBBK","...KBBBBBBBBBBBBBBBK","....KB.B.B.....B.B..","....KK.K.K.....K.K.."],
            DEER: ["...........K...K....","............K.K.....","..........KKKBKK....",".........KBBBBBBK...","........KBBBBBBBBK..",".......KBBBBBBBBBK..",".......K.B.....B....",".......K.K.....K...."],
            WHEAT_GROW: ["................","....1......1....","...111....111...","....1......1....","................"],
            WHEAT_READY: ["....3......3....","...333....333...","...333....333...","....3......3....","....3......3...."],
            GRAVE: [".......................",".........KKK...........","........KGGGKB.........",".......KGGGGGB.........",".......KGGGGGB.........","......KGGGGGGB.........","......KGGGGGGB.........",".....KGGGGGGGGB........",".....KGGGGGGGGB........","....KGGGGGGGGGGB.......","....KGGGGGGGGGGB.......","...KGGGGGGGGGGGGB......","..KDDDDDDDDDDDDDDK.....","......................."]
        };

        const MAP_WIDTH = 24;
        const MAP_HEIGHT = 24;
        const DAY_TICKS = 800; 

        const WEATHER = {
            SUNNY: { id: 'SUNNY', name: 'Êô¥Â§©', color: 'rgba(255,255,0,0.1)' },
            RAIN: { id: 'RAIN', name: 'Èõ®Â§©', color: 'rgba(0,0,50,0.3)' },
            SNOW: { id: 'SNOW', name: 'ÈôçÈõ™', color: 'rgba(200,240,255,0.2)' }
        };

        const ZODIACS = [
            { sign: 'Áâ°Áæä', gender: 'M', color: '#c0392b', hair: '#2c3e50', trait: 'Â•ΩÈ¨•' },
            { sign: 'ÈáëÁâõ', gender: 'F', color: '#27ae60', hair: '#5d4037', trait: 'Âõ∫Âü∑' },
            { sign: 'ÈõôÂ≠ê', gender: 'M', color: '#f39c12', hair: '#e67e22', trait: 'ÂñÑËÆä' },
            { sign: 'Â∑®Ëüπ', gender: 'F', color: '#7f8c8d', hair: '#34495e', trait: 'È°ßÂÆ∂' },
            { sign: 'ÁçÖÂ≠ê', gender: 'M', color: '#e67e22', hair: '#f1c40f', trait: 'Èú∏Ê∞£' },
            { sign: 'ËôïÂ•≥', gender: 'F', color: '#16a085', hair: '#2ecc71', trait: 'Ë¨πÊÖé' },
            { sign: 'Â§©Áß§', gender: 'M', color: '#e84393', hair: '#fd79a8', trait: 'Áå∂Ë±´' },
            { sign: 'Â§©Ë†ç', gender: 'F', color: '#8e44ad', hair: '#2c3e50', trait: 'ÊïèÈä≥' },
            { sign: 'Â∞ÑÊâã', gender: 'M', color: '#2980b9', hair: '#3498db', trait: 'ÂÜíÈö™' },
            { sign: 'Êë©ÁæØ', gender: 'F', color: '#576574', hair: '#1e272e', trait: 'Â†ÖÂøç' },
            { sign: 'Ê∞¥Áì∂', gender: 'M', color: '#00d2d3', hair: '#00cec9', trait: 'Âè§ÊÄ™' },
            { sign: 'ÈõôÈ≠ö', gender: 'F', color: '#a29bfe', hair: '#6c5ce7', trait: 'Êµ™Êº´' }
        ];

        const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const noise = (x, y) => Math.sin(x/3.5) + Math.cos(y/4.5);

        const renderMatrix = (ctx, matrix, colors, offsetX = 0, offsetY = 0) => {
            matrix.forEach((row, y) => {
                for (let x = 0; x < row.length; x++) {
                    const char = row[x];
                    if (char === '.') continue;
                    let fill = colors[char] || PALETTE.OUTLINE;
                    if (char === 'K') fill = PALETTE.OUTLINE;
                    ctx.fillStyle = fill;
                    ctx.fillRect(offsetX + x, offsetY + y, 1, 1);
                }
            });
        };

        const createSprites = () => {
            const cache = {};
            const createCanvas = (w, h) => {
                const c = document.createElement('canvas');
                c.width = w; c.height = h;
                return { c, ctx: c.getContext('2d') };
            };

            const { c: grassC, ctx: grassCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            grassCtx.fillStyle = PALETTE.GRASS_BG; grassCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            grassCtx.fillStyle = PALETTE.GRASS_L; for(let i=0; i<30; i++) grassCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            grassCtx.fillStyle = PALETTE.GRASS_D; for(let i=0; i<20; i++) grassCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.grass = grassC;

            const { c: dirtC, ctx: dirtCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            dirtCtx.fillStyle = PALETTE.DIRT; dirtCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            dirtCtx.fillStyle = PALETTE.WOOD_D; for(let i=0; i<40; i++) dirtCtx.fillRect(rand(0,31), rand(0,31), 1, 1);
            cache.dirt = dirtC;

            const { c: oakC, ctx: oakCtx } = createCanvas(TILE_SIZE, TILE_SIZE*2);
            renderMatrix(oakCtx, SPRITE_MATRICES.TREE_OAK, {'L': PALETTE.LEAF_D, 'W': PALETTE.WOOD_D}, 6, 10);
            oakCtx.fillStyle = PALETTE.LEAF_L; oakCtx.fillRect(10, 12, 2, 2); oakCtx.fillRect(16, 14, 2, 2);
            cache.tree_oak = oakC;

            const { c: pineC, ctx: pineCtx } = createCanvas(TILE_SIZE, TILE_SIZE*2);
            renderMatrix(pineCtx, SPRITE_MATRICES.TREE_PINE, {'L': PALETTE.LEAF_PINE, 'W': PALETTE.WOOD_D}, 6, 8);
            cache.tree_pine = pineC;

            const { c: bushC, ctx: bushCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            renderMatrix(bushCtx, SPRITE_MATRICES.BUSH, {'L': PALETTE.LEAF_L}, 4, 16);
            cache.bush = bushC;

            const { c: flowerC, ctx: flowerCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            renderMatrix(flowerCtx, SPRITE_MATRICES.FLOWER, {'R': PALETTE.FLOWER_R, 'Y': PALETTE.FLOWER_Y, 'G': PALETTE.GRASS_L}, 10, 16);
            cache.flower = flowerC;

            const { c: mushC, ctx: mushCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            renderMatrix(mushCtx, SPRITE_MATRICES.MUSHROOM, {'R': PALETTE.MUSHROOM, 'W': PALETTE.WHITE}, 10, 16);
            cache.mushroom = mushC;

            const { c: rockC, ctx: rockCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            renderMatrix(rockCtx, SPRITE_MATRICES.ROCK, {'K': PALETTE.OUTLINE, 'M': PALETTE.STONE_M, 'L': PALETTE.STONE_L, 'D': PALETTE.STONE_D}, 8, 16);
            cache.rock = rockC;

            const { c: rabbitC, ctx: rabbitCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            renderMatrix(rabbitCtx, SPRITE_MATRICES.RABBIT, {'W': PALETTE.FUR_RABBIT}, 8, 16);
            cache.rabbit = rabbitC;

            const { c: wolfC, ctx: wolfCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            renderMatrix(wolfCtx, SPRITE_MATRICES.WOLF, {'G': PALETTE.FUR_WOLF}, 4, 12);
            cache.wolf = wolfC;

            const { c: bearC, ctx: bearCtx } = createCanvas(TILE_SIZE*1.5, TILE_SIZE*1.5);
            renderMatrix(bearCtx, SPRITE_MATRICES.BEAR, {'B': PALETTE.FUR_BEAR}, 4, 10);
            cache.bear = bearC;

            const { c: deerC, ctx: deerCtx } = createCanvas(TILE_SIZE, TILE_SIZE*1.5);
            renderMatrix(deerCtx, SPRITE_MATRICES.DEER, {'B': PALETTE.FUR_DEER}, 4, 10);
            cache.deer = deerC;

            const { c: w1C, ctx: w1Ctx } = createCanvas(TILE_SIZE, TILE_SIZE);
            renderMatrix(w1Ctx, SPRITE_MATRICES.WHEAT_GROW, { '1': PALETTE.WHEAT_1 }, 8, 16);
            cache.wheat_1 = w1C;
            const { c: w2C, ctx: w2Ctx } = createCanvas(TILE_SIZE, TILE_SIZE);
            renderMatrix(w2Ctx, SPRITE_MATRICES.WHEAT_READY, { '3': PALETTE.WHEAT_3 }, 8, 16);
            cache.wheat_2 = w2C;

            // Grave
            const { c: graveC, ctx: graveCtx } = createCanvas(TILE_SIZE, TILE_SIZE);
            renderMatrix(graveCtx, SPRITE_MATRICES.GRAVE, { 'G': PALETTE.GRAVE_STONE, 'D': PALETTE.GRAVE_DIRT, 'B': '#546e7a', 'K': PALETTE.OUTLINE }, 4, 8);
            cache.grave = graveC;

            return cache;
        };

        const generateMapData = () => {
            const newMap = [];
            for(let y=0; y<MAP_HEIGHT; y++) {
                const row = [];
                for(let x=0; x<MAP_WIDTH; x++) {
                    const n = noise(x + Math.random()*10, y + Math.random()*10);
                    let type = 'GRASS';
                    let decoration = null;
                    if (Math.abs(n) > 1.2) type = 'MOUNTAIN';
                    else if (n < -0.4) type = 'FOREST';
                    else if (n > 0.8) type = 'WATER';
                    const dist = Math.sqrt((x-MAP_WIDTH/2)**2 + (y-MAP_HEIGHT/2)**2);
                    if (dist < 5) type = 'BASE';
                    if (dist > 9 && n > 0.5) type = 'WATER';
                    if (type === 'FOREST') {
                        if (Math.random() > 0.6) decoration = 'TREE_OAK';
                        else decoration = 'TREE_PINE';
                        if (Math.random() < 0.1) decoration = 'MUSHROOM';
                    } else if (type === 'GRASS') {
                        const rnd = Math.random();
                        if (rnd < 0.05) decoration = 'ROCK';
                        else if (rnd < 0.1) decoration = 'BUSH';
                        else if (rnd < 0.15) decoration = 'FLOWER';
                    }
                    row.push({ x, y, type, decoration });
                }
                newMap.push(row);
            }
            return newMap;
        };

        const generateSimsData = () => ZODIACS.map((z, i) => ({
            id: `sim_${Date.now()}_${i}`, ...z,
            x: MAP_WIDTH/2 + rand(-2,2), y: MAP_HEIGHT/2 + rand(-2,2),
            hp: 100, hunger: 100, energy: 100,
            state: 'IDLE', targetX: null, targetY: null,
            inventory: { wood:0, food:0 },
            thought: 'ÂèàÊòØÊñ∞ÁöÑ‰∏ÄÂ§©...',
            animFrame: rand(0,10), dir: 1,
            blessedTimer: 0 // Êñ∞Â¢ûÔºöË≥úÁ¶èË®àÊôÇÂô®
        }));

        const generateCreaturesData = () => {
            const initCreatures = [];
            for(let i=0; i<8; i++) {
                const type = Math.random() < 0.4 ? 'RABBIT' : (Math.random() < 0.7 ? 'DEER' : (Math.random() < 0.9 ? 'WOLF' : 'BEAR'));
                initCreatures.push({
                    id: `c_${Date.now()}_${i}`, type,
                    x: rand(1, MAP_WIDTH-2), y: rand(1, MAP_HEIGHT-2),
                    hp: type==='BEAR'?200 : type==='WOLF'?80 : 30,
                    targetX: null, targetY: null,
                    state: 'WANDER', animFrame: rand(0,10), dir: 1
                });
            }
            return initCreatures;
        };

        const App = () => {
            const [sprites, setSprites] = useState(null);
            const [map, setMap] = useState([]);
            const [sims, setSims] = useState([]);
            const [creatures, setCreatures] = useState([]);
            const [farms, setFarms] = useState([]);
            const [particles, setParticles] = useState([]);
            const [tribe, setTribe] = useState({ wood: 0, stone: 0, food: 100, tech: 0 });
            const [weather, setWeather] = useState(WEATHER.SUNNY);
            const [weatherTimer, setWeatherTimer] = useState(1000);
            const [time, setTime] = useState(0);
            const [day, setDay] = useState(1);
            const [era, setEra] = useState(1); 
            const [mana, setMana] = useState(999999);
            const [selectedId, setSelectedId] = useState(null);
            const [events, setEvents] = useState(['Êóè‰∫∫‰ª∞ÊúõÊòüÁ©∫ÔºåÊïÖ‰∫ãÈñãÂßã‰∫Ü...']);
            const [isGameOver, setIsGameOver] = useState(false); 
            const [blessEffects, setBlessEffects] = useState([]); // Êñ∞Â¢ûÔºöË≥úÁ¶èÁâπÊïàÁ≤íÂ≠ê
            
            const [isSoulSearching, setIsSoulSearching] = useState(false);
            const [isWritingSaga, setIsWritingSaga] = useState(false);
            const [aiThoughtId, setAiThoughtId] = useState(null); // Ê®ôË®òÂì™Âè•Ë©±ÊòØ AI ÁîüÊàêÁöÑ

            const canvasRef = useRef(null);
            const tickRef = useRef(0);
            const requestRef = useRef();

            useEffect(() => {
                setSprites(createSprites());
                setMap(generateMapData());
                setSims(generateSimsData());
                setCreatures(generateCreaturesData());
            }, []);

            useEffect(() => {
                if (sims.length > 0 && sims.every(s => s.state === 'DEAD') && !isGameOver) {
                    setIsGameOver(true);
                }
            }, [sims, isGameOver]);

            const startNextEra = () => {
                setEra(e => e + 1);
                setDay(1);
                setTime(0);
                setMana(999999);
                setMap(generateMapData());
                setSims(generateSimsData());
                setCreatures(generateCreaturesData());
                setFarms([]);
                setTribe(prev => ({ ...prev, food: 100, wood: 0, stone: 0 }));
                setIsGameOver(false);
                setEvents(e => [`=== Á¨¨ ${era + 1} Á¥ÄÂÖÉÈñãÂïü ===`, `ÊñáÊòéÁ≠âÁ¥ö Lv.${tribe.tech} ÁπºÊâøÂÆåÁï¢`, ...e]);
            };

            const handleSoulSearch = async (sim) => {
                if (mana < 10) return;
                setIsSoulSearching(true);
                setMana(prev => prev - 10);
                const prompt = `You are an AI storytelling engine. Roleplay as a primitive tribesman (Sign:${sim.sign}, Trait:${sim.trait}, State:${sim.state}). Generate a short inner monologue (max 15 words) in Traditional Chinese.`;
                const thought = await callGemini(prompt);
                if (thought) {
                    setSims(prev => prev.map(s => s.id === sim.id ? { ...s, thought: thought.trim() } : s));
                    setAiThoughtId(sim.id); // Ê®ôË®òÈÄôÂÄãËßíËâ≤ÁöÑÊÉ≥Ê≥ïÊòØ AI Áî¢ÁîüÁöÑ
                    setEvents(e => [`${sim.sign} ÁöÑÈùàÈ≠ÇÁôºÂá∫‰∫Ü‰ΩéË™û...`, ...e]);
                }
                setIsSoulSearching(false);
            };

            const handleTribeSaga = async () => {
                if (mana < 50) return;
                setIsWritingSaga(true);
                setMana(prev => prev - 50);
                const prompt = `Write a cryptic, mythic, single-sentence log entry (max 20 words) for a primitive tribe in Traditional Chinese. Context: Era ${era}, Tech Lv ${tribe.tech}, Pop ${sims.length}, Food ${Math.floor(tribe.food)}, Weather ${weather.name}.`;
                const saga = await callGemini(prompt);
                if (saga) setEvents(e => [`üìú Âè≤Ë©©: ${saga.trim()}`, ...e]);
                setIsWritingSaga(false);
            };

            const update = useCallback(() => {
                if (isGameOver) return;

                const isNight = time > DAY_TICKS * 0.6;
                if (tickRef.current % 10 === 0) {
                    setWeatherTimer(prev => prev - 1);
                    if (weatherTimer <= 0) {
                        const r = Math.random();
                        let nextW = WEATHER.SUNNY;
                        if (r < 0.3) nextW = WEATHER.RAIN;
                        else if (r < 0.4) nextW = WEATHER.SNOW;
                        setWeather(nextW);
                        setWeatherTimer(rand(500, 1500));
                        setEvents(e => [`Â§©Ê∞£: ${nextW.name}`, ...e.slice(0,4)]);
                    }
                }

                // Ë≥úÁ¶èÁâπÊïàÊõ¥Êñ∞
                setBlessEffects(prev => prev.map(p => ({...p, y: p.y - 1, life: p.life - 1})).filter(p => p.life > 0));

                if (weather.id !== 'SUNNY') {
                    const pCount = weather.id === 'RAIN' ? 10 : 5;
                    setParticles(prev => {
                        const newP = [];
                        for(let i=0; i<pCount; i++) {
                            newP.push({ x: rand(0, MAP_WIDTH * TILE_SIZE), y: -10, speed: weather.id === 'RAIN' ? rand(8,12) : rand(1,3), life: 100 });
                        }
                        return [...prev.map(p => ({ ...p, y: p.y + p.speed, x: weather.id === 'SNOW' ? p.x + Math.sin(p.y/10) : p.x, life: p.life-1 })).filter(p => p.y < MAP_HEIGHT * TILE_SIZE && p.life > 0), ...newP];
                    });
                } else {
                    setParticles([]);
                }

                setFarms(prev => prev.map(f => {
                    const growRate = weather.id === 'RAIN' ? 2 : (weather.id === 'SNOW' ? 0 : 1);
                    return f.stage < 100 ? { ...f, stage: Math.min(100, f.stage + 0.1 * growRate) } : f;
                }));

                setCreatures(prev => prev.map(c => {
                    if (c.hp <= 0) return null;
                    let nextC = { ...c };
                    if (tickRef.current % 20 === 0 && Math.random() < 0.1) {
                        nextC.targetX = Math.max(0, Math.min(MAP_WIDTH-1, c.x + rand(-3, 3)));
                        nextC.targetY = Math.max(0, Math.min(MAP_HEIGHT-1, c.y + rand(-3, 3)));
                    }
                    if (nextC.targetX !== null) {
                        const speed = c.type === 'RABBIT' ? 0.08 : c.type === 'DEER' ? 0.06 : 0.04;
                        const dx = nextC.targetX - nextC.x;
                        const dy = nextC.targetY - nextC.y;
                        if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) nextC.targetX = null;
                        else { nextC.x += Math.sign(dx) * speed; nextC.y += Math.sign(dy) * speed; nextC.dir = Math.sign(dx); nextC.animFrame++; }
                    }
                    return nextC;
                }).filter(Boolean));

                setSims(prev => prev.map(s => {
                    if (s.hp <= 0) return { ...s, state: 'DEAD' };
                    let nextS = { ...s };
                    
                    if (nextS.blessedTimer > 0) {
                        nextS.blessedTimer--; // Ë≥úÁ¶èÂÄíÊï∏
                        // Áî¢ÁîüË≥úÁ¶èÁ≤íÂ≠ê
                        if (Math.random() < 0.2) {
                            setBlessEffects(curr => [...curr, {
                                x: nextS.x * TILE_SIZE + 16 + rand(-8, 8),
                                y: nextS.y * TILE_SIZE,
                                life: 30,
                                color: '#ffd700'
                            }]);
                        }
                    }

                    if (tickRef.current % 10 === 0) {
                        let hLoss = 0.2; let eLoss = 0.1;
                        if (weather.id === 'SNOW' && !isInBase(nextS)) eLoss *= 2;
                        // Ë≥úÁ¶èÊïàÊûúÔºöÊ∏õÂ∞ëÊ∂àËÄó
                        if (nextS.blessedTimer > 0) { hLoss *= 0.5; eLoss *= 0.5; }

                        nextS.hunger -= hLoss; nextS.energy -= eLoss;
                        if (nextS.hunger <= 0) nextS.hp -= 0.5;
                        if (Math.random() < 0.02) {
                            if (nextS.blessedTimer > 0) nextS.thought = 'Á•ûÂäõÂÖÖÊªøÂÖ®Ë∫´ÔºÅ';
                            else if (nextS.hunger < 30) nextS.thought = 'Â•ΩÈ§ì...';
                            else if (weather.id === 'RAIN') nextS.thought = '‰∏ãÈõ®‰∫Ü...';
                            else if (weather.id === 'SNOW') nextS.thought = 'Â•ΩÂÜ∑...';
                            else nextS.thought = '‰ªäÂ§©ÂÅö‰ªÄÈ∫ºÂ•ΩÂë¢...'; // reset thought
                            if (nextS.id === aiThoughtId) setAiThoughtId(null); // Reset AI thought flag
                        }
                    }
                    const distToTarget = nextS.targetX ? Math.abs(nextS.x - nextS.targetX) + Math.abs(nextS.y - nextS.targetY) : 0;
                    if (nextS.state === 'IDLE') {
                        if (nextS.hunger < 50) {
                            if (tribe.food > 0 && isInBase(nextS)) { setTribe(t => ({...t, food: Math.max(0, t.food-10)})); nextS.hunger = 100; nextS.thought = 'Â•ΩÂêÉÔºÅ'; }
                            else {
                                const harvestable = farms.find(f => f.stage >= 100);
                                if (harvestable && tribe.tech >= 1) { nextS.state = 'FARMING'; nextS.targetX = harvestable.x; nextS.targetY = harvestable.y; }
                                else { nextS.state = 'GATHER'; nextS.targetX = rand(1, MAP_WIDTH-2); nextS.targetY = rand(1, MAP_HEIGHT-2); }
                            }
                        } else if (nextS.energy < 20 || (isNight && !isInBase(nextS))) {
                            nextS.targetX = MAP_WIDTH/2; nextS.targetY = MAP_HEIGHT/2;
                            if (isInBase(nextS)) { nextS.state = 'SLEEP'; nextS.thought = '‰ºëÊÅØ...'; }
                        } else {
                            if (tribe.tech >= 1 && Math.random() < 0.05 && farms.length < 15) {
                                const potentialFarm = map.flat().find(t => t.type === 'BASE' && !farms.some(f => f.x===t.x && f.y===t.y));
                                if (potentialFarm) { nextS.state = 'PLANTING'; nextS.targetX = potentialFarm.x; nextS.targetY = potentialFarm.y; }
                            }
                            if (nextS.state === 'IDLE' && Math.random() < 0.05) { nextS.targetX = nextS.x + rand(-2, 2); nextS.targetY = nextS.y + rand(-2, 2); }
                        }
                    } else if (nextS.state === 'GATHER') {
                        if (distToTarget < 0.5) { nextS.inventory.food += 10; nextS.state = 'IDLE'; nextS.thought = 'Êé°ÈõÜÂà∞‰∫ÜÔºÅ'; }
                    } else if (nextS.state === 'PLANTING') {
                        if (distToTarget < 0.5) { setFarms(f => [...f, { x: Math.round(nextS.x), y: Math.round(nextS.y), stage: 0 }]); nextS.state = 'IDLE'; setEvents(e => [`${nextS.sign} ÈñãÂ¢æËæ≤Áî∞`, ...e.slice(0,4)]); }
                    } else if (nextS.state === 'FARMING') {
                        const cropIdx = farms.findIndex(f => Math.abs(f.x - nextS.x) < 1 && Math.abs(f.y - nextS.y) < 1 && f.stage >= 100);
                        if (cropIdx >= 0) { setFarms(pF => { const nF = [...pF]; nF[cropIdx].stage = 0; return nF; }); setTribe(t => ({...t, food: t.food + 20})); nextS.state = 'IDLE'; nextS.thought = 'Ë±êÊî∂ÔºÅ'; }
                        else if (distToTarget < 0.5) nextS.state = 'IDLE';
                    } else if (nextS.state === 'SLEEP') {
                        nextS.energy += 0.5; if (nextS.energy >= 100) { nextS.state = 'IDLE'; nextS.thought = 'Áù°È£Ω‰∫Ü„ÄÇ'; }
                    }
                    if (nextS.targetX !== null) {
                        const dx = nextS.targetX - nextS.x; const dy = nextS.targetY - nextS.y;
                        if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) nextS.targetX = null;
                        else {
                            const speed = (nextS.state==='SLEEP'?0:0.05) * (weather.id==='SNOW'?0.6:1);
                            nextS.x += Math.sign(dx) * speed; nextS.y += Math.sign(dy) * speed;
                            nextS.animFrame++; nextS.dir = Math.sign(dx);
                        }
                    }
                    return nextS;
                }));
            }, [time, weather, farms, tribe, isGameOver, aiThoughtId]);

            const isInBase = (sim) => Math.sqrt((sim.x - MAP_WIDTH/2)**2 + (sim.y - MAP_HEIGHT/2)**2) < 5;

            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas || !sprites) return;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;

                ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save(); ctx.scale(SCALE, SCALE);

                map.forEach(row => row.forEach(tile => {
                    const px = tile.x * TILE_SIZE; const py = tile.y * TILE_SIZE;
                    ctx.drawImage(sprites.grass, px, py);
                    if (tile.type === 'WATER') {
                        ctx.fillStyle = PALETTE.WATER; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                        if (Math.sin(time/20 + tile.x) > 0.5) { ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(px + 4, py + 8, 8, 2); }
                    } else if (tile.type === 'BASE') ctx.drawImage(sprites.dirt, px, py);
                }));

                farms.forEach(f => {
                    const px = f.x * TILE_SIZE; const py = f.y * TILE_SIZE;
                    ctx.drawImage(sprites.dirt, px, py);
                    if (f.stage > 80) ctx.drawImage(sprites.wheat_2, px, py);
                    else if (f.stage > 20) ctx.drawImage(sprites.wheat_1, px, py);
                    else { ctx.fillStyle = '#8d6e63'; ctx.fillRect(px+10, py+10, 2, 2); ctx.fillRect(px+20, py+16, 2, 2); }
                });

                const objects = [];
                map.forEach(row => row.forEach(tile => { if (tile.decoration) objects.push({ y: tile.y, type: 'DECO', subtype: tile.decoration, x: tile.x }); }));
                sims.forEach(sim => objects.push({ y: sim.y, type: 'SIM', data: sim }));
                creatures.forEach(c => objects.push({ y: c.y, type: 'CREATURE', data: c }));
                objects.sort((a, b) => a.y - b.y);

                objects.forEach(obj => {
                    const px = obj.x * TILE_SIZE; const py = obj.y * TILE_SIZE;
                    if (obj.type === 'DECO') {
                        if (obj.subtype === 'TREE_OAK') ctx.drawImage(sprites.tree_oak, px, py - TILE_SIZE);
                        else if (obj.subtype === 'TREE_PINE') ctx.drawImage(sprites.tree_pine, px, py - TILE_SIZE);
                        else if (obj.subtype === 'ROCK') ctx.drawImage(sprites.rock, px, py);
                        else if (obj.subtype === 'BUSH') ctx.drawImage(sprites.bush, px, py);
                        else if (obj.subtype === 'FLOWER') ctx.drawImage(sprites.flower, px, py);
                        else if (obj.subtype === 'MUSHROOM') ctx.drawImage(sprites.mushroom, px, py);
                    } else if (obj.type === 'SIM') drawSim(ctx, obj.data);
                    else if (obj.type === 'CREATURE') drawCreature(ctx, obj.data);
                });

                if (selectedId) {
                    const target = [...sims, ...creatures].find(i => i.id === selectedId);
                    if (target) {
                        const px = target.x * TILE_SIZE; const py = target.y * TILE_SIZE;
                        ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1.5; ctx.setLineDash([4, 2]);
                        ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
                        ctx.setLineDash([]);
                    }
                }

                if (tribe.tech >= 1) {
                    const bx = (MAP_WIDTH/2) * TILE_SIZE; const by = (MAP_HEIGHT/2) * TILE_SIZE;
                    const fireSize = weather.id === 'RAIN' ? 2 : (Math.sin(time/5)*2 + 6);
                    if (weather.id !== 'RAIN' || Math.random() > 0.5) {
                        ctx.fillStyle = '#ff5722'; ctx.beginPath(); ctx.arc(bx + 16, by + 16, fireSize, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#ffca28'; ctx.beginPath(); ctx.arc(bx + 16, by + 16, fireSize/2, 0, Math.PI*2); ctx.fill();
                    }
                }

                // Â§©Ê∞£Á≤íÂ≠ê
                particles.forEach(p => {
                    ctx.fillStyle = weather.id === 'RAIN' ? '#4fc3f7' : '#ffffff';
                    const w = weather.id === 'RAIN' ? 1 : 2; const h = weather.id === 'RAIN' ? 4 : 2;
                    ctx.fillRect(p.x / SCALE, p.y / SCALE, w, h);
                });

                // Ë≥úÁ¶èÁâπÊïàÁ≤íÂ≠ê
                blessEffects.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x / SCALE, p.y / SCALE, 2, 2);
                });

                if (time > DAY_TICKS * 0.6) { ctx.fillStyle = 'rgba(10, 10, 30, 0.6)'; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE); }
                ctx.fillStyle = weather.color; ctx.fillRect(0, 0, MAP_WIDTH*TILE_SIZE, MAP_HEIGHT*TILE_SIZE);

                ctx.restore();
            }, [map, sprites, sims, creatures, weather, particles, blessEffects, farms, time, selectedId, tribe]);

            const drawSim = (ctx, s) => {
                const px = Math.floor(s.x * TILE_SIZE); const py = Math.floor(s.y * TILE_SIZE);
                
                if (s.state === 'DEAD') { 
                    // Áπ™Ë£ΩÂ¢ìÁ¢ë
                    ctx.drawImage(sprites.grave, px, py);
                    return; 
                }
                
                // Ë≥úÁ¶èÂÖâÁí∞
                if (s.blessedTimer > 0) {
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(px + 16, py + 28, 10, 4, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }

                const bounce = (s.state !== 'IDLE' && s.state !== 'SLEEP') ? Math.sin(s.animFrame) * 2 : 0;
                const matrix = s.gender === 'M' ? SPRITE_MATRICES.CHAR_M : SPRITE_MATRICES.CHAR_F;
                const colorMap = { 'H': s.hair, 'S': PALETTE.SKIN, 's': PALETTE.SKIN_SHADOW, 'C': s.color, 'K': PALETTE.OUTLINE };
                renderMatrix(ctx, matrix, colorMap, px + 4, py + 4 + bounce);
                if (s.state === 'SLEEP') { ctx.font = '10px monospace'; ctx.fillStyle = '#fff'; ctx.fillText('zZ', px+20, py); }
            };

            const drawCreature = (ctx, c) => {
                const px = Math.floor(c.x * TILE_SIZE); const py = Math.floor(c.y * TILE_SIZE);
                const bounce = Math.sin(c.animFrame) * 2;
                let matrix, colorMap, ox=0, oy=0;
                if (c.type === 'RABBIT') { matrix = SPRITE_MATRICES.RABBIT; colorMap = {'W': PALETTE.FUR_RABBIT, 'K': PALETTE.OUTLINE}; ox=4; oy=10; }
                else if (c.type === 'WOLF') { matrix = SPRITE_MATRICES.WOLF; colorMap = {'G': PALETTE.FUR_WOLF, 'K': PALETTE.OUTLINE}; ox=2; oy=6; }
                else if (c.type === 'BEAR') { matrix = SPRITE_MATRICES.BEAR; colorMap = {'B': PALETTE.FUR_BEAR, 'K': PALETTE.OUTLINE}; ox=-6; oy=-6; }
                else if (c.type === 'DEER') { matrix = SPRITE_MATRICES.DEER; colorMap = {'B': PALETTE.FUR_DEER, 'K': PALETTE.OUTLINE}; ox=2; oy=-2; }
                ctx.save();
                if (c.dir < 0) { ctx.translate(px + TILE_SIZE, 0); ctx.scale(-1, 1); ctx.translate(-px, 0); }
                renderMatrix(ctx, matrix, colorMap, px + ox, py + oy + bounce);
                ctx.restore();
            };

            useEffect(() => {
                const loop = () => {
                    tickRef.current++;
                    if (tickRef.current % 5 === 0) {
                        setTime(t => (t + 1) % DAY_TICKS);
                        if (time === 0) setDay(d => d+1);
                        update();
                    }
                    draw();
                    requestRef.current = requestAnimationFrame(loop);
                };
                requestRef.current = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(requestRef.current);
            }, [draw, update]);

            const handleCanvasClick = useCallback((e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = (e.clientX - rect.left) / SCALE / TILE_SIZE;
                const y = (e.clientY - rect.top) / SCALE / TILE_SIZE;
                
                const allObjs = [...sims, ...creatures];
                let closest = null;
                let minDist = 2.5; 

                allObjs.forEach(obj => {
                    const dist = Math.sqrt((obj.x + 0.5 - x)**2 + (obj.y + 0.5 - y)**2);
                    if (dist < minDist) {
                        closest = obj;
                        minDist = dist;
                    }
                });

                setSelectedId(closest ? closest.id : null);
            }, [sims, creatures]);

            const castSpell = (type) => {
                if (mana < 20) return;
                if (['FOOD', 'HEAL', 'BUFF'].includes(type) && selectedId) {
                    setSims(prev => prev.map(s => {
                        if (s.id !== selectedId) return s;
                        if (type === 'FOOD') { setMana(m => m - 30); setEvents(e => [`Ë≥ú‰∫à ${s.sign} È£üÁâ©`, ...e]); return { ...s, hunger: 100 }; }
                        else if (type === 'HEAL') { setMana(m => m - 30); setEvents(e => [`${s.sign} ÂÇ∑Âè£ÁôíÂêà`, ...e]); return { ...s, hp: 100 }; }
                        else if (type === 'BUFF') { 
                            setMana(m => m - 30); 
                            setEvents(e => [`${s.sign} Áç≤ÂæóÁ•ûÂäõ`, ...e]); 
                            return { ...s, energy: 100, thought: 'Á•ûËàáÊàëÂêåÂú®ÔºÅ', blessedTimer: 500 }; // Ë≥úÁ¶èÊåÅÁ∫å 500 ticks
                        }
                        return s;
                    }));
                    return;
                }
                setMana(m => m - 20);
                if (type === 'SUN') { setWeather(WEATHER.SUNNY); setEvents(e => ['Á•ûËπüÔºöÁ•àÊô¥', ...e]); }
                else if (type === 'RAIN') { setWeather(WEATHER.RAIN); setEvents(e => ['Á•ûËπüÔºöÁ•àÈõ®', ...e]); }
                else if (type === 'TECH') { setTribe(t => ({...t, tech: t.tech + 1})); setEvents(e => ['Á•ûËπüÔºöÊô∫ÊÖßÂïüËíô', ...e]); }
            };

            const selectedObj = [...sims, ...creatures].find(s => s.id === selectedId);
            const aliveCount = sims.filter(s => s.state !== 'DEAD').length;

            return (
                <div className="flex flex-col h-screen bg-[#1a1c2c] text-[#c2c3c7] font-mono select-none" style={{ fontFamily: PIXEL_FONT }}>
                    {/* HUD */}
                    <div className="bg-[#292b3c] p-2 border-b-4 border-[#121215] flex flex-wrap justify-between items-center shadow-lg shrink-0 z-20 relative gap-2">
                        <div className="flex gap-3 items-center">
                            <div className="text-[#ffcd75] font-bold flex items-center gap-1 text-sm"><Icons.Sparkles size={14}/> {mana}</div>
                            <div className="flex items-center gap-1 bg-[#1a1c2c] px-2 py-1 rounded border border-[#5d4037]">
                                {weather.id === 'SUNNY' ? <Icons.Sun size={14} className="text-yellow-400"/> : weather.id === 'RAIN' ? <Icons.CloudRain size={14} className="text-blue-400"/> : <Icons.Snowflake size={14} className="text-white"/>}
                                <span className="text-xs">{weather.name}</span>
                            </div>
                            <div className="text-[10px] text-gray-400">Era {era} Day {day} ({time < DAY_TICKS/2 ? 'AM' : 'PM'})</div>
                        </div>
                        <div className="flex gap-2 text-xs font-bold text-[#8b9bb4] items-center">
                            <span className="flex items-center gap-1"><Icons.Users size={12}/> {aliveCount}</span>
                            <span className="hidden sm:inline">üçé {Math.floor(tribe.food)}</span>
                            <span className="hidden sm:inline">ü™µ {tribe.wood}</span>
                            <span>üî® Lv.{tribe.tech}</span>
                        </div>
                    </div>

                    {/* ‰∏ªÂÆπÂô® */}
                    <div className="flex-1 flex flex-col md:flex-row overflow-hidden relative">
                        {isGameOver && (
                            <div className="absolute inset-0 z-50 bg-black/90 flex flex-col items-center justify-center animate-in fade-in zoom-in duration-500 p-4 text-center">
                                <Icons.Skull size={64} className="text-red-600 mb-4 animate-bounce"/>
                                <h1 className="text-4xl text-red-500 font-bold mb-2">ÊñáÊòéÊªÖ‰∫°</h1>
                                <p className="text-gray-400 mb-8 text-lg">Á¨¨ {era} Á¥ÄÂÖÉÁµêÊùüÊñº Day {day}...</p>
                                <button 
                                    onClick={startNextEra} 
                                    className="bg-red-900 hover:bg-red-800 text-white px-8 py-4 rounded border-2 border-red-500 flex items-center gap-3 text-xl transition-transform hover:scale-105 shadow-lg shadow-red-900/50"
                                >
                                    <Icons.RefreshCw size={24}/> ÈñãÂïüÁ¨¨ {era+1} Á¥ÄÂÖÉ
                                </button>
                            </div>
                        )}

                        {/* Canvas */}
                        <div className="relative flex-1 bg-black overflow-auto flex items-center justify-center p-4 min-h-[50vh] shadow-inner">
                            <canvas
                                ref={canvasRef} width={MAP_WIDTH * TILE_SIZE * SCALE} height={MAP_HEIGHT * TILE_SIZE * SCALE}
                                onClick={handleCanvasClick} className="border-4 border-[#3e2723] shadow-2xl cursor-crosshair max-w-none"
                                style={{ imageRendering: 'pixelated' }}
                            />
                            <div className="absolute top-4 left-4 flex flex-col gap-1 pointer-events-none opacity-80">
                                {events.slice(0, 3).map((ev, i) => (
                                    <div key={i} className="bg-black/60 backdrop-blur-sm text-[#fff] px-2 py-1 text-[10px] rounded border-l-2 border-[#ffcd75] shadow-sm">{ev}</div>
                                ))}
                            </div>
                        </div>

                        {/* ÊéßÂà∂Èù¢Êùø */}
                        <div className="w-full md:w-72 h-64 md:h-auto bg-[#292b3c] border-t-4 md:border-t-0 md:border-l-4 border-[#121215] p-2 flex flex-row md:flex-col gap-2 shrink-0 z-10 shadow-2xl overflow-x-auto md:overflow-x-hidden md:overflow-y-auto">
                            
                            {/* Á•ûËπüÈù¢Êùø */}
                            <div className="min-w-[180px] w-1/2 md:w-full bg-[#1a1c2c] p-2 rounded border border-[#3e2723] flex flex-col overflow-y-auto">
                                <h3 className="text-[#ffcd75] text-xs mb-2 font-bold border-b border-[#3e2723] pb-1 sticky top-0 bg-[#1a1c2c] z-10">Á•ûËπü (Miracles)</h3>
                                <div className="grid grid-cols-2 gap-2">
                                    <button onClick={() => castSpell('SUN')} className="bg-[#3e2723] active:bg-[#5d4037] p-2 rounded flex flex-col items-center gap-1"><Icons.Sun size={16} className="text-yellow-400"/><span className="text-[10px]">Á•àÊô¥ (-20)</span></button>
                                    <button onClick={() => castSpell('RAIN')} className="bg-[#3e2723] active:bg-[#5d4037] p-2 rounded flex flex-col items-center gap-1"><Icons.CloudRain size={16} className="text-blue-400"/><span className="text-[10px]">Á•àÈõ® (-20)</span></button>
                                    <button onClick={() => castSpell('TECH')} className="bg-[#3e2723] active:bg-[#5d4037] p-2 rounded flex flex-col items-center gap-1 col-span-2"><Icons.Brain size={16} className="text-purple-400"/><span className="text-[10px]">Ë≥ú‰∫àÊô∫ÊÖß (-20)</span></button>
                                    <button 
                                        onClick={handleTribeSaga} 
                                        disabled={isWritingSaga || mana < 50}
                                        className={`bg-indigo-900 active:bg-indigo-800 p-2 rounded flex flex-col items-center gap-1 col-span-2 border border-indigo-500 ${isWritingSaga ? 'opacity-50' : ''}`}
                                    >
                                        <Icons.ScrollText size={16} className={isWritingSaga ? "animate-pulse text-indigo-300" : "text-indigo-300"}/>
                                        <span className="text-[10px] text-indigo-200">‚ú® ÈÉ®ËêΩÂè≤Ë©© (-50)</span>
                                    </button>
                                </div>
                            </div>

                            {/* ËßÄÂØüÈù¢Êùø */}
                            <div className="min-w-[180px] w-1/2 md:w-full bg-[#1a1c2c] p-2 rounded border border-[#3e2723] relative flex flex-col overflow-y-auto">
                                <div className="flex justify-between items-center border-b border-[#3e2723] mb-2 pb-1 sticky top-0 bg-[#1a1c2c] z-10">
                                    <h3 className="text-[#8b9bb4] text-xs font-bold">ËßÄÂØü (Inspector)</h3>
                                    {selectedObj && <button onClick={() => setSelectedId(null)} className="text-gray-500 active:text-white"><Icons.X size={12}/></button>}
                                </div>

                                {selectedObj ? (
                                    <div className="flex flex-col gap-2 flex-1">
                                        {selectedObj.sign ? ( 
                                            <>
                                                <div className="flex items-center gap-2">
                                                    <div className="w-8 h-8 border border-gray-600 bg-black relative overflow-hidden flex-shrink-0 rounded">
                                                        <div className="absolute top-1 left-1 w-6 h-6" style={{backgroundColor: selectedObj?.hair, borderRadius: '50% 50% 0 0'}}></div>
                                                        <div className="absolute top-3 left-0 w-8 h-5" style={{backgroundColor: selectedObj?.color, borderRadius: '50% 50% 0 0'}}></div>
                                                    </div>
                                                    <div>
                                                        <div className="font-bold text-[#ffccaa] text-xs">{selectedObj?.sign}Â∫ß <span className="text-[10px] text-gray-500">({selectedObj?.gender})</span></div>
                                                        <div className="text-[10px] text-gray-500">{selectedObj?.trait} ‚Ä¢ {selectedObj?.state}</div>
                                                    </div>
                                                </div>
                                                <div className="space-y-1">
                                                    <div className="flex justify-between text-[10px]"><span>HP</span><span>{Math.floor(selectedObj?.hp || 0)}</span></div>
                                                    <div className="h-1 bg-gray-700 rounded"><div className="h-full bg-red-500 rounded" style={{width: `${selectedObj?.hp || 0}%`}}></div></div>
                                                    <div className="flex justify-between text-[10px]"><span>È£ΩÈ£ü</span><span>{Math.floor(selectedObj?.hunger || 0)}</span></div>
                                                    <div className="h-1 bg-gray-700 rounded"><div className="h-full bg-orange-500 rounded" style={{width: `${selectedObj?.hunger || 0}%`}}></div></div>
                                                </div>
                                                
                                                <div className={`mt-1 p-1.5 text-[10px] italic border border-gray-800 flex flex-col gap-1 rounded ${aiThoughtId === selectedObj.id ? 'bg-indigo-900/50 border-indigo-500 text-indigo-200' : 'bg-[#111] text-[#a5d6a7]'}`}>
                                                    <span>"{selectedObj?.thought}"</span>
                                                    <button 
                                                        onClick={() => handleSoulSearch(selectedObj)} 
                                                        disabled={isSoulSearching || mana < 10}
                                                        className="self-end flex items-center gap-1 text-[10px] bg-gray-800 active:bg-gray-700 px-1.5 py-0.5 rounded text-purple-300 border border-purple-900"
                                                    >
                                                        <Icons.MessageCircle size={10} className={isSoulSearching ? "animate-spin" : ""}/>
                                                        ‚ú® ÂÇæËÅΩ (-10)
                                                    </button>
                                                </div>

                                                <div className="mt-auto grid grid-cols-3 gap-1 pt-2 border-t border-[#3e2723]">
                                                    <button onClick={() => castSpell('FOOD')} className="bg-[#3e2723] active:bg-[#5d4037] p-1 rounded flex flex-col items-center"><Icons.Utensils size={14} className="text-orange-400"/><span className="text-[10px] text-center">Ë≥úÈ£ü<br/>(-30)</span></button>
                                                    <button onClick={() => castSpell('HEAL')} className="bg-[#3e2723] active:bg-[#5d4037] p-1 rounded flex flex-col items-center"><Icons.Heart size={14} className="text-red-400"/><span className="text-[10px] text-center">Ê≤ªÁôí<br/>(-30)</span></button>
                                                    <button onClick={() => castSpell('BUFF')} className="bg-[#3e2723] active:bg-[#5d4037] p-1 rounded flex flex-col items-center"><Icons.Shield size={14} className="text-blue-400"/><span className="text-[10px] text-center">Ë≥úÁ¶è<br/>(-30)</span></button>
                                                </div>
                                            </>
                                        ) : (
                                            <>
                                                <div className="font-bold text-[#ffccaa] text-sm">{selectedObj?.type}</div>
                                                <div className="text-[10px] text-gray-500">ÈáéÁîüÂãïÁâ©</div>
                                                <div className="flex justify-between text-[10px] mt-2"><span>HP</span><span>{Math.floor(selectedObj?.hp || 0)}</span></div>
                                                <div className="h-1 bg-gray-700 rounded"><div className="h-full bg-red-500 rounded" style={{width: `${Math.min(100, (selectedObj?.hp || 0)/2)}%`}}></div></div>
                                            </>
                                        )}
                                    </div>
                                ) : (
                                    <div className="h-full flex flex-col items-center justify-center text-gray-600 text-xs gap-2 opacity-50">
                                        <Icons.HelpCircle size={24} />
                                        <div className="text-center">ÈªûÊìäÁï´Èù¢ËßíËâ≤<br/>ÈÄ≤Ë°åËßÄÂØü‰∫íÂãï</div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>